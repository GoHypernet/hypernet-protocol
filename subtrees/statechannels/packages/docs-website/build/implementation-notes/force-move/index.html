<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.59">
<link rel="search" type="application/opensearchdescription+xml" title="statechannels docs" href="/opensearch.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Chivo&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">
<script src="https://buttons.github.io/buttons.js"></script><title data-react-helmet="true">ForceMove.sol | statechannels docs</title><meta data-react-helmet="true" property="og:image" content="https://docs.statechannels.org/img/undraw_online.svg"><meta data-react-helmet="true" property="twitter:image" content="https://docs.statechannels.org/img/undraw_online.svg"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for statechannels docs"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="ForceMove.sol | statechannels docs"><meta data-react-helmet="true" name="description" content="ForceMove.sol is a base contract that is not actually deployed: it is inherited by NitroAdjudicator.sol, which is deployed."><meta data-react-helmet="true" property="og:description" content="ForceMove.sol is a base contract that is not actually deployed: it is inherited by NitroAdjudicator.sol, which is deployed."><meta data-react-helmet="true" property="og:url" content="https://docs.statechannels.org/implementation-notes/force-move"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="true"><link data-react-helmet="true" rel="canonical" href="https://docs.statechannels.org/implementation-notes/force-move"><link rel="stylesheet" href="/styles.e0b33fa7.css">
<link rel="preload" href="/styles.8e0db825.js" as="script">
<link rel="preload" href="/runtime~main.27671965.js" as="script">
<link rel="preload" href="/main.03452097.js" as="script">
<link rel="preload" href="/2.4ee922d7.js" as="script">
<link rel="preload" href="/3.4c7fc1f6.js" as="script">
<link rel="preload" href="/4.a5988223.js" as="script">
<link rel="preload" href="/1be78505.75ec5049.js" as="script">
<link rel="preload" href="/369.23cc9095.js" as="script">
<link rel="preload" href="/ec1ed54d.db84b9ba.js" as="script">
<link rel="preload" href="/17896441.61fde53e.js" as="script">
<link rel="preload" href="/1.12d0c272.js" as="script">
<link rel="preload" href="/2ae40723.60aeee63.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg"><strong class="navbar__title">statechannels docs</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Docs</a><a class="navbar__item navbar__link" href="/typescript-api/index">Typescript API</a><a class="navbar__item navbar__link" href="/contract-api/contract-inheritance">Contract API</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span><span class="DocSearch-Button-Key">âŒ˜</span><span class="DocSearch-Button-Key">K</span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg"><strong class="navbar__title">statechannels docs</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/typescript-api/index">Typescript API</a></li><li class="menu__list-item"><a class="menu__link" href="/contract-api/contract-inheritance">Contract API</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Overview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/">statechannels docs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/products">Our products</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">App Developers</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/app-devs-intro">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/quick-start-contracts">Quick start (contracts)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/quick-start-dapp">Quick start (Dapp)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/hook-up-messaging">Hook up your messaging layer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/make-api-calls">Make Wallet API calls</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/app-devs/recommended-patterns">Recommended patterns</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Protocol Docs</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-docs/wallet-devs-intro">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-docs/quick-start">Quick Start</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-docs/tutorial">Tutorial</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Protocol Tutorial</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/execute-state-transitions">Execute state transitions off chain</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/deposit-assets">Deposit Assets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/finalize-a-channel-happy">Finalize a channel (happy)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/finalize-a-channel-sad">Finalize a channel (sad)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/understand-channel-storage">Understand channel storage</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/clear-a-challenge">Clear a challenge</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/outcomes">Understand Outcomes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/release-assets">Release assets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/protocol-tutorial/off-chain-funding">Off-chain funding</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Implementation Notes</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/implementation-notes/contract-devs-intro">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/implementation-notes/asset-holder">AssetHolder.sol</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/implementation-notes/force-move">ForceMove.sol</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/implementation-notes/nitro-adjudicator">NitroAdjudicator.sol</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/implementation-notes/null-app">Null app</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/implementation-notes/single-asset-payments">SingleAssetPayments.sol</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">ForceMove.sol</h1></header><div class="markdown"><p>ForceMove.sol is a base contract that is not actually deployed: it is inherited by NitroAdjudicator.sol, which is deployed.</p><p>ForceMove is a state channel execution framework. It:</p><ol><li>Specifies a programmable state format and state transition rules;</li><li>Specifies a format for the data stored on chain against each channel;</li><li>Enables disputes to be raised and adjudicated;</li><li>Allows for a final <strong>outcome</strong> to be registered against a unique <code>channelId</code>.</li></ol><p>This page documents our reference implementation in <code>ForceMove.sol</code>: please also see the <a href="/../contract-api/natspec/ForceMove">API</a>.</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="state-format"></a>State Format<a aria-hidden="true" tabindex="-1" class="hash-link" href="#state-format" title="Direct link to heading">#</a></h2><p>A specified format of <em>state</em> is vital, since it constitutes much of the interface between the on- and off- chain behavior of the state channel network.</p><p>In ForceMove, the following fields must be included in state updates:</p><table><thead><tr><th><strong>Field</strong></th><th><strong>Data type</strong></th><th><strong>Definition / Explanation</strong></th></tr></thead><tbody><tr><td>chainId</td><td><code>uint256</code></td><td>e.g. 3 (ropsten) or 1 (mainnet)</td></tr><tr><td>participants</td><td><code>address[]</code></td><td>participant addresses</td></tr><tr><td>channelNonce</td><td><code>uint256</code></td><td>chosen by participants to make ChannelId unique</td></tr><tr><td>challengeDuration</td><td><code>uint256</code></td><td>duration of challenge (in seconds)</td></tr><tr><td>turnNum</td><td><code>uint256</code></td><td>turn number</td></tr><tr><td>outcome</td><td><code>bytes</code></td><td>the <em>outcome</em> if the channel were to finalize in this state</td></tr><tr><td>isFinal</td><td><code>boolean</code></td><td>is this state final?</td></tr><tr><td>appDefinition</td><td><code>address</code></td><td>on-chain address of library defining custom application rules</td></tr><tr><td>appData</td><td><code>bytes</code></td><td>application-specific data</td></tr></tbody></table><p>Since states must ultimately be interpreted by the adjudicator, the encoding of these fields must be carefully considered. The following encoding is designed around optimal gas consumption:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    struct State {</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        // participants sign the hash of this</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 turnNum;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bool isFinal;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 channelId; // keccack256(abi.encode(chainId, participants, channelNonce))</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 appPartHash;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        //     keccak256(abi.encode(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        //         fixedPart.challengeDuration,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        //         fixedPart.appDefinition,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        //         variablePart.appData</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        //     )</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        // )</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 outcomeHash; //  keccak256(abi.encode(outcome))</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    }</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="channelid"></a><code>channelId</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#channelid" title="Direct link to heading">#</a></h3><p>The id of a channel is the hash of the abi encoded <code>chainId</code>, <code>participants</code> and <code>channelNonce</code>.</p><p>By choosing a new <code>channelNonce</code> each time the same participants execute a state channel supported by the same chain, they can avoid replay attacks.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="fixed-and-variable-parts"></a>Fixed and Variable Parts<a aria-hidden="true" tabindex="-1" class="hash-link" href="#fixed-and-variable-parts" title="Direct link to heading">#</a></h3><p>It is convenient to define some other structs, each containing a subset of the above data:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">  struct FixedPart {</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 chainId;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        address[] participants;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 channelNonce;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        address appDefinition;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 challengeDuration;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    }</span></div></div></div></div></div><p>which contains information which must be identical in every state channel update, and</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">   struct VariablePart {</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes outcome;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes appData;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    }</span></div></div></div></div></div><p>which contains fields which are allowed to change. These structs, along with remaining fields, <code>turnNum</code> and <code>isFinal</code>, can be passed in to contract methods for more gas efficient execution.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="implementation-faqs"></a>Implementation FAQs<a aria-hidden="true" tabindex="-1" class="hash-link" href="#implementation-faqs" title="Direct link to heading">#</a></h3><p><strong>Why include the <code>channelId</code> in the State, rather than its pre-image?</strong> It is necessary for the chain to calculate (and hence store in memory) the <code>channelId</code> for every state-changing method, in order to read the correct slot from storage. When computing the hash of a State struct (which often happens next), it is more efficient (in terms of gas consumption) to reuse <code>channelId</code>, rather than to (re)hash the pre-image of <code>channelId</code> along with the rest of the data. This is because <code>channelId</code> is generally shorter than its pre-image, and the gas costs of hashing increase with the length of the input.</p><p><strong>Why not include the <code>appDefinition</code> in the <code>channelId</code>?</strong> The <code>appDefinition</code> is fixed as part of the transition rules, so it seems like it would make sense to include it in the <code>channelId</code>. However, this would rule out participants being able to collaboratively upgrade the app without refunding the channel.</p><p><strong>Why not hash the <code>appDefinition</code> together with the <code>channelId</code> into a <code>fixedPartHash</code>?</strong> By doing this you perform one extra hash but you have to hash less data in the variable part. This tradeoff makes sense if you&#x27;re hashing something like &gt;3 variable parts for the same fixed part (based on the relative gas costs). We anticipate that most of the time channels will have 2 participants, so we optimize for this case.</p><p><strong>Why not include <code>turnNum</code> or <code>isFinal</code> in the <code>variablePartHash</code>?</strong> Having the <code>turnNum</code> and <code>isFinal</code> separate makes the <code>conclude</code> method more efficient, as it can pass in just the <code>variablePartHash</code> and not the (potentially large) data within it.</p><p><strong>What happened to the &quot;commitment&quot; terminology?</strong>
This has been deprecated in favor of &quot;state&quot;.</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="transition-rules"></a>Transition Rules<a aria-hidden="true" tabindex="-1" class="hash-link" href="#transition-rules" title="Direct link to heading">#</a></h2><p>In ForceMove, every state has an associated &#x27;mover&#x27; - the participant who had the unique ability to progress the channel at the point the state was created. The mover can be calculated from the <code>turnNum</code> and the <code>participants</code> as follows:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">moverAddress = participants[turnNum % participants.length]</span></div></div></div></div></div><p>The implication of this formula is that participants take turns to update the state of the channel. Furthermore, there are strict rules about whether a state update is valid, based on the previous state that has been announced. Beyond conforming to the state format, there are certain relationships that must hold between the state in question, and the previously announced state.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="core-transition-rules"></a>Core transition rules<a aria-hidden="true" tabindex="-1" class="hash-link" href="#core-transition-rules" title="Direct link to heading">#</a></h3><p>The full rule set is:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">function validTransition(a, b) &lt;=&gt;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.turnNum == a.turnNum + 1</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.chainId == a.chainId</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.participants == a.participants</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.appDefinition == a.appDefinition</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.challengeDuration == a.challengeDuration</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  a.signer == a.mover</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  b.signer == b.mover</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  if b.isFinal</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     b.defaultOutcome == a.defaultOutcome</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">  else if b.turnNum &lt; 2n</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     a.isFinal == False</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     b.defaultOutcome == a.defaultOutcome</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     b.appData == a.appData</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">   else</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     a.isFinal == False</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">     b.app.validTransition(a, b)</span></div></div></div></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="core-_validtransition"></a>Core <code>_validTransition</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#core-_validtransition" title="Direct link to heading">#</a></h3><p>The actual signature for the internal, core <code>_validTransition</code> function makes use of the <code>VariablePart</code> struct defined in the section on <a href="#state-format">state format</a>.</p><p>In <code>/contracts/ForceMove.sol</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function _validTransition(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 nParticipants,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        ForceMoveApp.VariablePart[2] memory ab, // [a,b]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 turnNumB,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        address appDefinition</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) internal pure returns (bool)</span></div></div></div></div></div><p>A later <a href="#support-proofs">check for support</a> for the submitted states implies (if it passes) that the following fields are equal for a and b:
<code>chainId</code>, <code>participants</code>, <code>channelNonce</code>, <code>appDefinition</code>, <code>challengeDuration</code>, and that <code>b.turnNum = a.turnNum + 1</code>. This is because the <code>stateHashes</code> are computed on chain from a single <code>fixedPart</code> which is submitted (and implicitly copied across all states) as well as a single <code>largestTurnNum</code> (which is implicitly decremented as we step back through the submitted states). This means that the core <code>_validTransition</code> function need only perform the remaining checks. See the contract itself for the full implementation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="_validtransitionchain"></a><code>_validTransitionChain</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#_validtransitionchain" title="Direct link to heading">#</a></h3><p>The definition above applies to a pair of <code>States</code>. It is often necessary to verify that a list of <code>States</code> has the property that the second <code>State</code> in each consecutive pair is a <code>validTransition</code>from the first.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function _validTransitionChain(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        // returns stateHashes array (implies true) else reverts</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        ForceMoveApp.VariablePart[] memory variableParts,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8 isFinalCount,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 channelId,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        FixedPart memory fixedPart</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) internal pure returns (bytes32[] memory)</span></div></div></div></div></div><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="support-proofs"></a>Support Proofs<a aria-hidden="true" tabindex="-1" class="hash-link" href="#support-proofs" title="Direct link to heading">#</a></h2><p>As we will see in the method definitions later, in order for the chain to accept a channel state, <code>s</code>, that channel state must be <em>supported</em> by <code>n</code> signatures (where <code>n = participants.length</code>).
The simplest way for this to accomplish this is to provide a sequence of <code>n</code> states terminating is state <code>s</code>, where each state is signed by its mover and each consecutive pair of states form a valid transition.</p><p>ForceMove also allows an optimization where a state can be supported by <code>n</code> signatures on a sequence of <code>m &lt; n</code> states, provided again that each consecutive pair of those <code>m</code> states form a valid transition and further provided each participant has provided a signature on a state later or equal in the sequence than the state for which they were the mover.
In the extreme, this allows a single state signed by all <code>n</code> parties to be accepted by the chain.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="_statesupportedby"></a><code>_stateSupportedBy</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#_statesupportedby" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function _stateSupportedBy(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        ForceMoveApp.VariablePart[] memory variableParts,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8 isFinalCount,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 channelId,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        FixedPart memory fixedPart,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        Signature[] memory sigs,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) internal pure returns (bytes32)</span></div></div></div></div></div><p>Implementation:</p><ul><li>Check states form a valid transition chain and calculate <code>stateHashes</code>, by calling <code>_validTransitionChain</code>.</li><li>Check the signatures on the stateHashes are correct by requiring <code>_validSignatures</code>.</li><li>If checks pass, returns the final element in the <code>stateHashes</code> array.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="_validsignatures"></a><code>_validSignatures</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#_validsignatures" title="Direct link to heading">#</a></h3><p>Given an array of state hashes, checks the validity of the supplied signatures.</p><div class="admonition admonition-warning alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>warning</h5></div><div class="admonition-content"><p>Does not check the states to see if they form a chain of valid transitions.</p></div></div><p>Internal call</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function _validSignatures(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        address[] memory participants,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32[] memory stateHashes,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        Signature[] memory sigs,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) internal pure returns (bool)</span></div></div></div></div></div><p>Each signature is a struct:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    struct Signature {</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8 v;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 r;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 s;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    }</span></div></div></div></div></div><p>Requirements:</p><ul><li>There is a signature for each participant:<ul><li>either on the hash of the state for which they are a mover</li><li>or on the hash of a state that appears after that state in the array</li></ul></li></ul><p>Implementation:</p><ol><li>is <code>whoSignedWhat</code> acceptable?<ul><li>see <a href="#_acceptablewhosignedwhat">below</a></li></ul></li><li>Did who actually sign what?<ul><li>For each i from <code>0 .. (n - 1)</code>:<ul><li>Does <code>participants[i] == recoverSigner(stateHashes[whoSignedWhat[i]], sigs[i])</code></li></ul></li></ul></li></ol><p>Some examples:</p><p>In the following examples, we will let <code>n</code> be the number of participants in the channel.
We format the signatures <code>sigs</code> as an array of signatures, where <code>sigs[i]</code> are signatures for states <code>states[i]</code>.</p><p>Use the notation that <code>si</code> represents a state with <code>turnNum = i</code> and <code>xi</code> is a signature of participant <code>i</code> on the corresponding state.</p><p>Example 1: Suppose that <code>n = 3</code>, <code>states = [s4, s5]</code> and <code>sigs = [[x1], [x0, x2]]</code>.</p><p>In order for signatures to be valid, we need that:</p><ul><li>Participant 2 has signed <code>s5</code></li><li>Participant 1 has signed <code>s4</code> or <code>s5</code></li><li>Participant 0 has signed <code>s4</code> or <code>s5</code> (as <code>s3</code> hasn&#x27;t been provided)</li></ul><p>So the signatures are valid in this case</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="_acceptablewhosignedwhat"></a><code>_acceptableWhoSignedWhat</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#_acceptablewhosignedwhat" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function _acceptableWhoSignedWhat(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8[] memory whoSignedWhat,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 nParticipants,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 nStates</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) internal pure returns (bool)</span></div></div></div></div></div><p>Implementation: - Let <code>m</code> be the number of states passed in - Let <code>n</code> be the number of participants - Require <code>whoSignedWhat.length == n</code> (Namely, there must be precisely one signature for each participant). - For each <code>participant[i]</code>: - Calculate <code>offset = (largestTurnNum - i) % n</code> - If <code>offset &gt;= m - 1</code> then they can sign any state - Else they should have signed state <code>m - 1 - offset</code> or highe r</p><p>Example of whether <code>whoSignedWhat</code> is acceptable:</p><ul><li>Suppose: <code>m = 2</code>, <code>n = 3</code>, <code>largestTurnNum = 5</code>.</li><li><code>offset = [2, 1, 0]</code></li><li>so participant <code>[0, 1 ,2]</code> should have signed <code>[{0, 1}, {0, 1}, {1}]</code> respectively.</li><li>so valid <code>whoSignedWhat</code>s are all combinations:</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">[0, 0, 1] =&gt; true</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">[1, 1, 1] =&gt; true</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">[1, 0, 1] =&gt; true</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">[0, 1, 1] =&gt; true</span></div></div></div></div></div><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="channel-storage"></a>Channel Storage<a aria-hidden="true" tabindex="-1" class="hash-link" href="#channel-storage" title="Direct link to heading">#</a></h2><p>The adjudicator contract stores</p><ul><li><code>uint48 turnNumRecord</code></li><li><code>uint48 finalizesAt</code></li><li><code>uint160 fingerprint</code></li></ul><p>serialized, inside the following mapping (with <code>channelId</code> as the key):</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    mapping(bytes32 =&gt; bytes32) public channelStorageHashes;</span></div></div></div></div></div><p>The <code>fingerprint</code> uniquely identifies the channel&#x27;s current state, up to hash collisions.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="turnnumrecord"></a><code>turnNumRecord</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#turnnumrecord" title="Direct link to heading">#</a></h3><p><code>turNumRecord</code> is the highest turn number that is known to the chain to be supported by a full set of signatures.
The exception to this rule is that it is set to <code>0</code> when the channel is concluded via a <code>conclude</code> call.</p><p>For example, the <code>turnNumRecord</code> might be increased by a submitted transaction including</p><ul><li>a <code>validTransition</code> m-chain (i.e. an ordered list of <code>m &lt;= n</code> states such that each state in the list is a valid transition from its predecessor), and</li><li><code>n</code> signatures such that each participant has signed the state in the m-chain for which they are a mover (or a later one)</li></ul><p>One example of this is a transaction including a single state signed by all <code>n</code> participants.</p><p>Note that a new <code>validTransition</code> <code>m</code>-chain may be implied by a single, signed state that is a validTransition from a state already supported on-chain: and hence the <code>turnNumRecord</code> can be incremented by a <code>respond</code> transaction.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="channel-modes"></a>Channel Modes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#channel-modes" title="Direct link to heading">#</a></h3><ul><li><strong>Open</strong> if and only if <code>finalizesAt</code> is null<ul><li>implies that <code>stateHash</code> and <code>challengerAddress</code> are also null</li></ul></li><li><strong>Challenge</strong> if and only if <code>finalizesAt &lt; currentTime</code><ul><li>implies that all other fields are not null</li></ul></li><li><strong>Finalized</strong> if and only if <code>finalizesAt &gt;= currentTime</code><ul><li>implies that all other fields are not null</li></ul></li></ul><p>These states can be represented in the following state machine:</p><div class="mermaid" align="center">
graph LR
linkStyle default interpolate basis
Open --&gt;|forceMove| Challenge
Open --&gt;|checkpoint| Open
Open--&gt;|conclude| Finalized
Challenge--&gt;|forceMove| Challenge
Challenge--&gt;|respond| Open
Challenge--&gt;|checkpoint| Open
Challenge--&gt;|conclude| Finalized
Challenge--&gt;|timeout| Finalized</div><p>Storage costs on-chain are high and tend to dwarf other gas fees. The implementation therefore minimizes on-chain storage as much as possible.</p><p>ForceMove requires certain data to be available on-chain.</p><p>The value of <code>channelStorageHashes[someChannelId]</code> is obtained by:</p><ul><li>setting the most significant 48 bits to the <code>turnNumRecord</code></li><li>setting the next most significant 48 bits to <code>finalizesAt</code></li><li>setting the next most significant 160 bits to the <code>fingerprint</code></li></ul><p>The <code>fingerprint</code> is the 160 least significant bits of <code>keccak256(abi.encode(channelData))</code>, where <code>channelData</code> is a struct of type</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    struct ChannelData {</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 turnNumRecord;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 finalizesAt;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 stateHash; // keccak256(abi.encode(State))</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        address challengerAddress;</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        bytes32 outcomeHash // keccak256(abi.encode(Outcome));</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    }</span></div></div></div></div></div><p>When the adjudicator needs to verify the exact state or outcome, the data is provided in the function arguments, as part of the <code>calldata</code>. The chain will then check that the hydrated data hashes to the image that has been stored.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="faqs"></a>FAQs<a aria-hidden="true" tabindex="-1" class="hash-link" href="#faqs" title="Direct link to heading">#</a></h3><p><strong>Why include the <code>outcomeHash</code>?</strong></p><p>Although the <code>outcome</code> is included in the <code>state</code>, we include the <code>outcomeHash</code> at the top level of the <code>channelStorageHash</code> to make it easier for the <a href="/implementation-notes/nitro-adjudicator#push-outcome"><code>pushOutcome</code></a> method to prove what the outcome of the channel was. The tradeoff here is that the methods need to make sure they have the data to calculate it - which adds at most a <code>bytes32</code> to their <code>calldata</code>.</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="methods"></a>Methods<a aria-hidden="true" tabindex="-1" class="hash-link" href="#methods" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="forcemove"></a><code>forceMove</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#forcemove" title="Direct link to heading">#</a></h3><p>The <code>forceMove</code> function allows anyone holding the appropriate off-chain state to register a challenge on chain, and gives the framework its name. It is designed to ensure that a state channel can progress or be finalized in the event of inactivity on behalf of a participant (e.g. the current mover).</p><p>The off-chain state is submitted (in an optimized format), and once relevant checks have passed, an <code>outcome</code> is registered against the <code>channelId</code>, with a finalization time set at some delay after the transaction is processed. This delay allows the challenge to be cleared by a timely and well-formed <a href="#respond">respond</a> or <a href="#checkpoint">checkpoint</a> transaction. If no such transaction is forthcoming, the challenge will time out, allowing the <code>outcome</code> registered to be finalized. A finalized outcome can then be used to extract funds from the channel.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function forceMove(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        FixedPart memory fixedPart,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        ForceMoveApp.VariablePart[] memory variableParts,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8 isFinalCount, // how many of the states are final</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        Signature[] memory sigs,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8[] memory whoSignedWhat,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        Signature memory challengerSig</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ) public</span></div></div></div></div></div><p>Check:</p><ul><li><code>largestTurnNum</code> is greater than or equal to the stored value of <code>turnNumRecord</code></li><li>Channel is not finalized</li><li>States and signatures support the challenge state (the maximal state)</li><li><code>challengerSig</code> proves that some participant signed the challenge state.</li></ul><p>Effects:</p><ul><li>Sets or updates the following ChannelData properties:<ul><li><code>turnNumRecord</code> to the <code>largestTurnNum</code></li><li><code>finalizesAt</code> to <code>currentTime</code> + <code>challengeInterval</code></li><li><code>stateHash</code></li><li><code>challengerAddress</code></li></ul></li><li>Emit a <code>ChallengeRegistered</code> event</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>The challenger needs to sign this data:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">keccak256(abi.encode(challengeStateHash, &#x27;forceMove&#x27;))</span></div></div></div></div></div><p>in order to form <code>challengerSig</code>. This signals their intent to forceMove this channel with this particular state. This mechanism allows the forceMove to be authorized only by a channel participant.</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="respond"></a><code>respond</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#respond" title="Direct link to heading">#</a></h3><p>The respond method allows anyone with the appropriate, single off-chain state (usually the current mover) to clear an existing challenge stored against a <code>channelId</code>.</p><p>The off-chain state is submitted (in an optimized format), and once relevant checks have passed, the existing challenge is cleared and the <code>turnNumRecord</code> is incremented by one.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">function respond(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    address challenger,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    bool[2] memory isFinalAB, // [challengeStateIsFinal, responseStateIsFinal]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    FixedPart memory fixedPart,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    ForceMoveApp.VariablePart[2] memory variablePartAB, // [challengeState, responseState]</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    Signature memory sig</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">)</span></div></div></div></div></div><p>Requirements:</p><ul><li><code>challengeState</code> matches <code>stateHash</code>,</li><li><code>challengeState</code> to <code>responseState</code> is a valid transition,</li><li>Channel is in Challenge mode.</li></ul><p>Effects:</p><ul><li>Clears challenge,</li><li>Increments <code>turnNumRecord</code>.</li></ul><p>Implementation:</p><ul><li>Calculate <code>channelId</code> from fixedPart</li><li>Calculate <code>challengeStateHash</code> and <code>challengeStateOutcome</code> from <code>fixedPart, challengeVariablePart, turnNumRecord, challengStateIsFinal</code></li><li>Calculate <code>storageHash = hash(turnNumRecord, finalizesAt, challengeStateHash, challengeStateOutcome)</code></li><li>Check that <code>finalizesAt &gt; now</code></li><li>Check that <code>channelStorageHashes[channelId] == storageHash</code></li><li>Calculate <code>responseStateHash</code></li><li>Recover the signer from the <code>responseStateHash</code> and check that they are the mover for <code>turnNumRecord + 1</code></li><li>Check <code>validTransition(nParticipants, isFinalAB, variablePartAB, appDefiintion)</code></li><li>Set channelStorageHashes:<ul><li><code>turnNumRecord += 1</code></li><li>Other fields set to their null values (see <a href="/implementation-notes/force-move#channel-storage">Channel Storage</a>).</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="conclude"></a><code>conclude</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#conclude" title="Direct link to heading">#</a></h3><p>If a participant signs a state with <code>isFinal = true</code>, then in a cooperative channel-closing procedure the other players can countersign that state and broadcast it. Once a full set of <code>n</code> such signatures exists (this set is known as a <strong>finalization proof</strong>) anyone in possession may use it to finalize the channel on-chain. They would do this by calling <code>conclude</code> on the adjudicator.</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>In Nitro, the existence of this possibility can be relied on (counterfactually) to <a href="/protocol-docs/client-specification/auxiliary-protocols#closing-off-chain">close a channel off-chain</a>.</p></div></div><p>The conclude methods allow anyone with sufficient off-chain state to immediately finalize an outcome for a channel without having to wait for a challenge to expire.</p><p>The off-chain state is submitted (in an optimized format), and once relevant checks have passed, an expired challenge is stored against the <code>channelId</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain">    function conclude(States states, Signatures sigs)</span></div></div></div></div></div><p>Checks:</p><ul><li>Channel is not finalized</li><li>A finalization proof has been provided</li></ul><p>Effects:</p><ul><li>Sets <code>finalizesAt</code> to current time</li><li>Sets <code>outcomeHash</code> to be consistent with finalization proof</li><li>Clears <code>stateHash</code></li><li>Clears <code>turnNumRecord</code></li><li>Clears <code>challengerAddress</code></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="checkpoint"></a><code>checkpoint</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#checkpoint" title="Direct link to heading">#</a></h3><p>The <code>checkpoint</code> method allows anyone with a supported off-chain state to establish a new and higher <code>turnNumRecord</code> and leave the resulting channel in the &quot;Open&quot; mode.</p><p>The off-chain state is submitted (in an optimized format), and once relevant checks have passed, the <code>turnNumRecord</code> is updated, and a challenge, if exists is cleared.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-solidity codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="background-color:#282c34;color:#ffffff"><div class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    function checkpoint(</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        FixedPart memory fixedPart,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint256 largestTurnNum,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        ForceMoveApp.VariablePart[] memory variableParts,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8 isFinalCount, // how many of the states are final</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        Signature[] memory sigs,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">        uint8[] memory whoSignedWhat,</span></div><div class="token-line" style="color:#ffffff"><span class="token plain">    )</span></div></div></div></div></div><p>Requirements:</p><ul><li>The channel is not finalized</li><li>The <code>largestTurnNum</code> &gt; <code>turnNumRecord</code></li><li>States and signatures support the last state</li></ul><p>Effects:</p><ul><li>Increases <code>turnNumRecord</code>.</li><li>Clears challenge, when exists.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"></div><div class="col text--right"><em><small>Last updated on <time datetime="2020-09-14T23:28:53.000Z" class="docLastUpdatedAt_217_">9/14/2020</time> by <strong>Caleb Ditchfield</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/implementation-notes/asset-holder"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« AssetHolder.sol</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/implementation-notes/nitro-adjudicator"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">NitroAdjudicator.sol Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3klQ"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#state-format" class="table-of-contents__link">State Format</a><ul><li><a href="#channelid" class="table-of-contents__link"><code>channelId</code></a></li><li><a href="#fixed-and-variable-parts" class="table-of-contents__link">Fixed and Variable Parts</a></li><li><a href="#implementation-faqs" class="table-of-contents__link">Implementation FAQs</a></li></ul></li><li><a href="#transition-rules" class="table-of-contents__link">Transition Rules</a><ul><li><a href="#core-transition-rules" class="table-of-contents__link">Core transition rules</a></li><li><a href="#core-_validtransition" class="table-of-contents__link">Core <code>_validTransition</code></a></li><li><a href="#_validtransitionchain" class="table-of-contents__link"><code>_validTransitionChain</code></a></li></ul></li><li><a href="#support-proofs" class="table-of-contents__link">Support Proofs</a><ul><li><a href="#_statesupportedby" class="table-of-contents__link"><code>_stateSupportedBy</code></a></li><li><a href="#_validsignatures" class="table-of-contents__link"><code>_validSignatures</code></a></li><li><a href="#_acceptablewhosignedwhat" class="table-of-contents__link"><code>_acceptableWhoSignedWhat</code></a></li></ul></li><li><a href="#channel-storage" class="table-of-contents__link">Channel Storage</a><ul><li><a href="#turnnumrecord" class="table-of-contents__link"><code>turnNumRecord</code></a></li><li><a href="#channel-modes" class="table-of-contents__link">Channel Modes</a></li><li><a href="#faqs" class="table-of-contents__link">FAQs</a></li></ul></li><li><a href="#methods" class="table-of-contents__link">Methods</a><ul><li><a href="#forcemove" class="table-of-contents__link"><code>forceMove</code></a></li><li><a href="#respond" class="table-of-contents__link"><code>respond</code></a></li><li><a href="#conclude" class="table-of-contents__link"><code>conclude</code></a></li><li><a href="#checkpoint" class="table-of-contents__link"><code>checkpoint</code></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="text--center"><div class="margin-bottom--sm"><img class="footer__logo" src="/img/logo.svg"></div><div>Copyright Â© 2020</div></div></div></footer></div>
<script src="/styles.8e0db825.js"></script>
<script src="/runtime~main.27671965.js"></script>
<script src="/main.03452097.js"></script>
<script src="/2.4ee922d7.js"></script>
<script src="/3.4c7fc1f6.js"></script>
<script src="/4.a5988223.js"></script>
<script src="/1be78505.75ec5049.js"></script>
<script src="/369.23cc9095.js"></script>
<script src="/ec1ed54d.db84b9ba.js"></script>
<script src="/17896441.61fde53e.js"></script>
<script src="/1.12d0c272.js"></script>
<script src="/2ae40723.60aeee63.js"></script>
</body>
</html>