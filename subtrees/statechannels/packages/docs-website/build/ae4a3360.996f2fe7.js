(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{302:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return h}));var a=t(2),r=t(6),o=(t(0),t(420)),i={id:"clear-a-challenge",title:"Clear a challenge"},l={unversionedId:"protocol-tutorial/clear-a-challenge",id:"protocol-tutorial/clear-a-challenge",isDocsHomePage:!1,title:"Clear a challenge",description:"A challenge being registered does not mean that the channel will inexorably finalize. Participants have the timeout period in order to be able to respond. Perhaps they come back online after a brief spell of inactivity, or perhaps the challenger was trying to (maliciously) finalize the channel with a supported but outdated (or 'stale') state.",source:"@site/docs/protocol-tutorial/clear-a-challenge.md",permalink:"/protocol-tutorial/clear-a-challenge",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Understand channel storage",permalink:"/protocol-tutorial/understand-channel-storage"},next:{title:"Understand Outcomes",permalink:"/protocol-tutorial/outcomes"}},c=[{value:"Call <code>checkpoint</code>",id:"call-checkpoint",children:[]},{value:"Call <code>respond</code>",id:"call-respond",children:[]},{value:"Call <code>challenge</code> again",id:"call-challenge-again",children:[]},{value:"Extract info from Adjudicator Events",id:"extract-info-from-adjudicator-events",children:[]}],s={rightToc:c};function h(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A challenge being registered does ",Object(o.b)("em",{parentName:"p"},"not")," mean that the channel will inexorably finalize. Participants have the timeout period in order to be able to respond. Perhaps they come back online after a brief spell of inactivity, or perhaps the challenger was trying to (maliciously) finalize the channel with a supported but outdated (or 'stale') state."),Object(o.b)("h2",{id:"call-checkpoint"},"Call ",Object(o.b)("inlineCode",{parentName:"h2"},"checkpoint")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"checkpoint")," method allows anyone with a supported off-chain state to establish a new and higher ",Object(o.b)("inlineCode",{parentName:"p"},"turnNumRecord"),' on chain, and leave the resulting channel in the "Open" mode. It can be used to clear a challenge.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson8.test.ts\n\n/* \n  Register a challenge with a very long timeout, following the preceding tutorial step\n  Form a new support proof (you should be familiar with how to do this by now) with an increased largestTurnNum\n*/\n\n/* Submit this transaction: */\n\nconst tx = NitroAdjudicator.checkpoint(\n  fixedPart,\n  largestTurnNum,\n  variableParts,\n  isFinalCount,\n  signatures,\n  whoSignedWhat\n);\n\nawait(await tx).wait();\n\n/* \n    Form an expectation about the new state of the chain:\n  */\nconst channelData: ChannelData = {\n  turnNumRecord: largestTurnNum,\n  finalizesAt: 0x0 // 0 here implies the channel is open again\n};\nconst expectedChannelStorageHash = channelDataToChannelStorageHash(channelData);\n\n/* \n    Check channelStorageHash against the expected value (it is a public mapping)\n  */\nexpect(await NitroAdjudicator.channelStorageHashes(channelId)).toEqual(expectedChannelStorageHash);\n")),Object(o.b)("h2",{id:"call-respond"},"Call ",Object(o.b)("inlineCode",{parentName:"h2"},"respond")),Object(o.b)("p",null,"The respond method allows anyone with the appropriate, ",Object(o.b)("em",{parentName:"p"},"single")," off-chain state (usually the current mover) to clear an existing challenge stored against a ",Object(o.b)("inlineCode",{parentName:"p"},"channelId"),". This might be significantly cheaper than calling checkpoint (it leverages the fact that the chain has already seen a support for the challenge state, so providing a single validTransition from the challenge state to the response state implies the existence of a support proof for the response state)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson9.test.ts\n// Put the chain in a challenge mode, following the tutorial above.\n// Preserve the variables used.\n\n/* Form a response state */\nlargestTurnNum += 1;\nconst responseState: State = {\n  turnNum: largestTurnNum,\n  isFinal: false,\n  channel,\n  outcome: [],\n  appDefinition: process.env.TRIVIAL_APP_ADDRESS,\n  appData: HashZero,\n  challengeDuration\n};\n\nconst responder = wallets[0];\nconst responseSignature = await signState(responseState, responder.privateKey).signature;\nconst isFinalAB = [false, false];\nconst variablePartAB = [\n  getVariablePart(challengeSignedState.state),\n  getVariablePart(responseState)\n];\n\nconst tx = NitroAdjudicator.respond(\n  challenger.address,\n  isFinalAB,\n  fixedPart,\n  variablePartAB,\n  responseSignature\n);\nawait(await tx).wait();\n\n/* \n    Form an expectation about the new state of the chain:\n*/\nconst expectedChannelStorageHash = channelDataToChannelStorageHash({\n  turnNumRecord: largestTurnNum,\n  finalizesAt: 0x0 // 0 here implies the channel is open again.\n});\n\n/* \n    Check channelStorageHash against the expected value (it is a public mapping)\n*/\nexpect(await NitroAdjudicator.channelStorageHashes(channelId)).toEqual(expectedChannelStorageHash);\n")),Object(o.b)("h2",{id:"call-challenge-again"},"Call ",Object(o.b)("inlineCode",{parentName:"h2"},"challenge")," again"),Object(o.b)("p",null,"It is important to understand that a challenge may be \"cleared\" by another more recent challenge. The channel will be left in challenge mode (so it has not really been 'cleared' in that sense), but some ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/protocol-tutorial/understand-channel-storage"}),"on chain storage")," will be updated, such as the deadline for responding."),Object(o.b)("h2",{id:"extract-info-from-adjudicator-events"},"Extract info from Adjudicator Events"),Object(o.b)("p",null,"You may have noticed that to respond, the challenge state itself must be (re)submitted to the chain. To save gas, information is only stored on chain in a hashed format. Clients should, therefore, cache information emitted in Events emitted by the adjudicator, in order to be able to respond to challenges."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson10.test.ts\n\n// Prepare a forceMove transaction as above, and store the transaction receipt\nconst receipt = await(\n  await NitroAdjudicator.forceMove(\n    fixedPart,\n    largestTurnNum,\n    variableParts,\n    isFinalCount,\n    signatures,\n    whoSignedWhat,\n    challengeSignature\n  )\n).wait();\n\n// Extract the information out of the ForceMove event\nconst event = receipt.events.pop();\nconst {\n  channelId: eventChannelId,\n  turnNumRecord: eventTurnNumRecord,\n  finalizesAt: eventFinalizesAt,\n  challenger: eventChallenger,\n  isFinal: eventIsFinal,\n  fixedPart: eventFixedPart,\n  variableParts: eventVariableParts\n} = event.args;\n")),Object(o.b)("hr",null))}h.isMDXComponent=!0},420:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return b}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=r.a.createContext({}),h=function(e){var n=r.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=h(e.components);return r.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=h(t),u=a,b=p["".concat(i,".").concat(u)]||p[u]||d[u]||o;return t?r.a.createElement(b,l(l({ref:n},s),{},{components:t})):r.a.createElement(b,l({ref:n},s))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);