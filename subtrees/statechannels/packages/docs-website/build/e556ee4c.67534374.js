(window.webpackJsonp=window.webpackJsonp||[]).push([[326],{377:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(2),i=n(6),o=(n(0),n(420)),c=n(425),r={id:"quick-start-contracts",title:"Quick start (contracts)"},p={unversionedId:"app-devs/quick-start-contracts",id:"app-devs/quick-start-contracts",isDocsHomePage:!1,title:"Quick start (contracts)",description:"You should begin your application design process by creating a single smart contract conforming to the ForceMoveApp interface.",source:"@site/docs/app-devs/quick-start-contracts.md",permalink:"/app-devs/quick-start-contracts",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Introduction",permalink:"/app-devs/app-devs-intro"},next:{title:"Quick start (Dapp)",permalink:"/app-devs/quick-start-dapp"}},s=[{value:"Examples",id:"examples",children:[]},{value:"Design guide",id:"design-guide",children:[]}],l={rightToc:s};function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"You should begin your application design process by creating a single smart contract conforming to the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../contract-api/natspec/ForceMoveApp"}),Object(o.b)("inlineCode",{parentName:"a"},"ForceMoveApp"))," interface."),Object(o.b)("p",null,"You'll want to pull this interface, as well as the ",Object(o.b)("inlineCode",{parentName:"p"},"Outcome")," library contract, into your project using your favourite node package manager:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-console"}),"> yarn add @statechannels/nitro-protocol\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ForceMoveApp")," interface calls for an application-specific ",Object(o.b)("inlineCode",{parentName:"p"},"validTransition(a,b)")," function. This function needs to decode the ",Object(o.b)("inlineCode",{parentName:"p"},"appData"),", from state channel updates ",Object(o.b)("inlineCode",{parentName:"p"},"a")," and ",Object(o.b)("inlineCode",{parentName:"p"},"b"),", and decide if ",Object(o.b)("inlineCode",{parentName:"p"},"b")," is an acceptable transition from ",Object(o.b)("inlineCode",{parentName:"p"},"a"),". For example, in a game of chess, the position of the king in ",Object(o.b)("inlineCode",{parentName:"p"},"b.appData")," must be within one square of its position in ",Object(o.b)("inlineCode",{parentName:"p"},"a.appData"),"."),Object(o.b)("h2",{id:"examples"},"Examples"),Object(o.b)("p",null,"For example, one can implement a simple counting application, where the stae of the channel can only be updated by incrementing a counter variable:"),Object(o.b)("p",null,"In ",Object(o.b)("inlineCode",{parentName:"p"},"/contracts/CountingApp.sol"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport '@statechannels/nitro-protocol/contracts/interfaces/ForceMoveApp.sol';\nimport '@statechannels/nitro-protocol/contracts/Outcome.sol';\n\ncontract CountingApp is ForceMoveApp {\n  struct CountingAppData {\n    uint256 counter;\n  }\n\n  function appData(bytes memory appDataBytes) internal pure returns (CountingAppData memory) {\n    return abi.decode(appDataBytes, (CountingAppData));\n  }\n\n  function validTransition(\n    VariablePart memory a,\n    VariablePart memory b,\n    uint256 turnNumB,\n    uint256 nParticipants\n  ) public pure override returns (bool) {\n    require(\n      appData(b.appData).counter == appData(a.appData).counter + 1,\n      'CountingApp: Counter must be incremented'\n    );\n    require(keccak256(b.outcome) == keccak256(a.outcome), 'CountingApp: Outcome must not change');\n    return true;\n  }\n}\n")),Object(o.b)("p",null,"This example is unrepresentative, however, in that it does not allow any changes to the ",Object(o.b)("inlineCode",{parentName:"p"},"outcome")," of the channel. This means nothing of any value can change hands as the application is executed. A full ForceMoveApp should specify how the outcome is allowed to change during a transition: for example, if a chess player achieves checkmate, they might be permitted to claim all of the money in the channel."),Object(o.b)("p",null,"More realistic ForceMoveApp examples exist: such as games of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/statechannels/apps/blob/master/packages/rps/contracts/RockPaperScissors.sol"}),"Rock Paper Scissors")," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/statechannels/apps/blob/master/packages/tic-tac-toe/contracts/TicTacToe.sol"}),"Tic Tac Toe"),", as well as a simple ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../implementation-notes/single-asset-payments"}),"Payment Channel")," app."),Object(o.b)("h2",{id:"design-guide"},"Design guide"),Object(o.b)("p",null,"In more complicated applications, it can help to adopt a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Finite-state_machine"}),"finite state machine")," model, which means the application can be represented in a digram such as this:"),Object(o.b)(c.a,{chart:"\nstateDiagram-v2\n[*] --\x3e Resting\nResting --\x3e Propose\nPropose --\x3e Resting\nPropose --\x3e Accept\nAccept --\x3e Reveal\nReveal --\x3e Resting\n",mdxType:"Mermaid"}),Object(o.b)("p",null,"These finite states could be represented as a Solidity ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://solidity.readthedocs.io/en/v0.6.0/types.html#enums"}),Object(o.b)("inlineCode",{parentName:"a"},"enum")),'. In ForceMove, the participants "leapfrog" each other on this diagram, i.e.:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"A starts at Resting"),Object(o.b)("li",{parentName:"ul"},"B transitions to Propose"),Object(o.b)("li",{parentName:"ul"},"A transitions to Accept"),Object(o.b)("li",{parentName:"ul"},"B transitions to Reveal"),Object(o.b)("li",{parentName:"ul"},"repeat")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"validTransition")," function returns ",Object(o.b)("inlineCode",{parentName:"p"},"true")," only if the transition is one allowed by the arrows in the diagram (this is necessary but not sufficient, there are of course other checks made, too). On the other hand, Accept --\x3e Propose is not allowed, so ",Object(o.b)("inlineCode",{parentName:"p"},"validTransition")," could return ",Object(o.b)("inlineCode",{parentName:"p"},"false")," in this case."),Object(o.b)("p",null,"In fact, to provide more information, it actually calls ",Object(o.b)("inlineCode",{parentName:"p"},"revert('No valid transition found');"),"."))}b.isMDXComponent=!0},425:function(e,t,n){"use strict";var a=n(0),i=n.n(a),o=n(438),c=n.n(o);c.a.initialize({startOnLoad:!0});t.a=function(e){var t=e.chart;return Object(a.useEffect)((function(){c.a.contentLoaded()}),[]),i.a.createElement("div",{className:"mermaid",align:"center"},t)}},441:function(e,t,n){var a={"./locale":424,"./locale.js":424};function i(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=o,e.exports=i,i.id=441}}]);