(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{288:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return l}));var a=t(2),r=t(6),o=(t(0),t(420)),i={id:"recommended-patterns",title:"Recommended patterns"},s={unversionedId:"app-devs/recommended-patterns",id:"app-devs/recommended-patterns",isDocsHomePage:!1,title:"Recommended patterns",description:"This page details some of the patterns we have adopted in our example apps (Web3Torrent and Rock Paper Scissors).",source:"@site/docs/app-devs/recommended-patterns.md",permalink:"/app-devs/recommended-patterns",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Make Wallet API calls",permalink:"/app-devs/make-api-calls"},next:{title:"Introduction",permalink:"/protocol-docs/wallet-devs-intro"}},p=[{value:"Decide on a funding strategy",id:"decide-on-a-funding-strategy",children:[{value:"Direct",id:"direct",children:[]},{value:"Virtual",id:"virtual",children:[]}]},{value:"Application coding",id:"application-coding",children:[]},{value:"Wrapping the channelClient",id:"wrapping-the-channelclient",children:[]},{value:"Maintain a cache of channel state",id:"maintain-a-cache-of-channel-state",children:[]}],c={rightToc:p};function l(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This page details some of the patterns we have adopted in our example apps (",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.statechannels.org/introducing-web3torrent/"}),"Web3Torrent")," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.statechannels.org/deconstructing-a-state-channel-application/"}),"Rock Paper Scissors"),")."),Object(o.b)("h2",{id:"decide-on-a-funding-strategy"},"Decide on a funding strategy"),Object(o.b)("p",null,"This decision has an impact on how your design your application."),Object(o.b)("h3",{id:"direct"},"Direct"),Object(o.b)("p",null,"The user experience for a ",Object(o.b)("strong",{parentName:"p"},"directly")," funded channel is that users need to deposit funds on chain during channel setup, and release them on chain during channel teardown. The wallet UI will pop up at the appropriate time to guide the user through those transactions."),Object(o.b)("h3",{id:"virtual"},"Virtual"),Object(o.b)("p",null,"The user experience for a ",Object(o.b)("strong",{parentName:"p"},"virtually"),' funded channel is improved, in that users need only perform blockchain transactions in order to setup and a teard own a "site budget" and ',Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../protocol-tutorial/off-chain-funding"}),"ledger channel")," connection to a state channel hub."),Object(o.b)("p",null,"They might set this up on their first visit to your application, and maintain it for the lifetime of many application channels, which are then funded virtually through the hub. Importantly, the wallet UI ",Object(o.b)("strong",{parentName:"p"},"will")," pop up when administering the hub connection, but will ",Object(o.b)("strong",{parentName:"p"},"not")," pop up during management of application channels."),Object(o.b)("p",null,"This route is best when you need to setup and teardown many channels between many distinct peers during the course of the application (as you would, for example, in a torrenting application)."),Object(o.b)("p",null,"Using the virtual funding strategy demands a much greater effort with respect to infastructure you must provide -- in particular it requires a state channel hub to be running. At the protocol level, this is just another statechannel participant: but in practice it needs to fulfill a number of important properties: for example, to be well funded, operate without user input and so on. Our reference implementation of such a hub is coming soon."),Object(o.b)("p",null,"For a simple game like Rock Paper Scissors, the advantages of virtual funding may or may not be considered necessary. Regardless, switching from direct-funding to virtual-funding at a later stage should be straightforward: statechannel execution should be completely independent of the funding mechanism."),Object(o.b)("h2",{id:"application-coding"},"Application coding"),Object(o.b)("p",null,"In order for your app to construct state updates of the right format, you'll need to write some Javascript or Typescript helper code. The purpose of this code is to translate between the general-purpose, ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/app-devs/quick-start-contracts"}),"protocol-level concepts of ",Object(o.b)("inlineCode",{parentName:"a"},"appData")," and ",Object(o.b)("inlineCode",{parentName:"a"},"outcome"))," and the specific data structures that your application needs to work with. Those structures should mirror those in the Solidity code you have already written. Here's an idea of what we did in Rock Paper Scissors (see the Solidity code ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/statechannels/apps/blob/master/packages/rps/contracts/RockPaperScissors.sol"}),"here"),"):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"import {defaultAbiCoder, bigNumberify, keccak256} from 'ethers/utils';\nimport {HashZero} from 'ethers/constants';\nimport {randomHex} from '../utils/randomHex';\nimport {unreachable} from '../utils/unreachable';\n\nexport enum Weapon {\n  Rock = 0,\n  Paper = 1,\n  Scissors = 2\n}\n\nexport enum PositionType {\n  Start, // 0\n  RoundProposed, // 1\n  RoundAccepted, // 2\n  Reveal // 3\n}\n\nexport interface RPSData {\n  positionType: PositionType;\n  stake: string; // uint256\n  preCommit: string; // bytes32\n  playerAWeapon: Weapon;\n  playerBWeapon: Weapon;\n  salt: string; // bytes32\n}\n\nexport interface Start {\n  type: 'start';\n  stake: string;\n}\n\nexport interface RoundProposed {\n  type: 'roundProposed';\n  stake: string;\n  preCommit: string;\n}\n\nexport interface RoundAccepted {\n  type: 'roundAccepted';\n  stake: string;\n  preCommit: string;\n  playerBWeapon: Weapon;\n}\n\nexport interface Reveal {\n  type: 'reveal';\n  playerAWeapon: Weapon;\n  playerBWeapon: Weapon;\n  stake: string;\n  salt;\n}\n\nexport type AppData = Start | RoundProposed | RoundAccepted | Reveal;\n\nfunction toRPSData(appData: AppData): RPSData {\n  let positionType;\n  switch (appData.type) {\n    case 'start':\n      positionType = PositionType.Start;\n      break;\n    case 'roundProposed':\n      positionType = PositionType.RoundProposed;\n      break;\n    case 'roundAccepted':\n      positionType = PositionType.RoundAccepted;\n      break;\n    case 'reveal':\n      positionType = PositionType.Reveal;\n      break;\n  }\n  const defaults: RPSData = {\n    positionType,\n    stake: bigNumberify(0).toString(),\n    preCommit: HashZero,\n    playerAWeapon: Weapon.Rock,\n    playerBWeapon: Weapon.Rock,\n    salt: randomHex(64)\n  };\n\n  return {...defaults, ...appData};\n}\n\nexport function encodeAppData(appData: AppData): string {\n  return encodeRPSData(toRPSData(appData));\n}\n\nexport function encodeRPSData(rpsData: RPSData): string {\n  return defaultAbiCoder.encode(\n    [\n      'tuple(uint8 positionType, uint256 stake, bytes32 preCommit, uint8 playerAWeapon, uint8 playerBWeapon, bytes32 salt)'\n    ],\n    [rpsData]\n  );\n}\n\nexport function decodeAppData(appDataBytes: string): AppData {\n  const parameters = defaultAbiCoder.decode(\n    [\n      'tuple(uint8 positionType, uint256 stake, bytes32 preCommit, uint8 playerAWeapon, uint8 playerBWeapon, bytes32 salt)'\n    ],\n    appDataBytes\n  )[0];\n\n  const positionType = parameters[0] as PositionType;\n  const stake = parameters[1].toString();\n  const preCommit = parameters[2];\n  const playerAWeapon = parameters[3];\n  const playerBWeapon = parameters[4];\n  const salt = parameters[5];\n\n  switch (positionType) {\n    case PositionType.Start:\n      const start: Start = {\n        type: 'start',\n        stake\n      };\n      return start;\n    case PositionType.RoundProposed:\n      const roundProposed: RoundProposed = {\n        type: 'roundProposed',\n        stake,\n        preCommit\n      };\n      return roundProposed;\n    case PositionType.RoundAccepted:\n      const roundAccepted: RoundAccepted = {\n        type: 'roundAccepted',\n        stake,\n        preCommit,\n        playerBWeapon\n      };\n      return roundAccepted;\n    case PositionType.Reveal:\n      const reveal: Reveal = {\n        type: 'reveal',\n        playerAWeapon,\n        playerBWeapon,\n        salt,\n        stake\n      };\n      return reveal;\n    default:\n      return unreachable(positionType);\n  }\n}\n\nexport function hashPreCommit(weapon: Weapon, salt: string) {\n  return keccak256(defaultAbiCoder.encode(['uint256', 'bytes32'], [weapon, salt]));\n}\n")),Object(o.b)("h2",{id:"wrapping-the-channelclient"},"Wrapping the channelClient"),Object(o.b)("p",null,"We recommend that you wrap the channelClient in an ",Object(o.b)("inlineCode",{parentName:"p"},"AppSecificChannelClient"),", which can leverage your app-specific coding ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#application-coding"}),"as above"),". This additional layer of abstraction should result in cleaner code for the rest of your application."),Object(o.b)("p",null,"Here's a sketch of what we did with Rock Paper Scissors (full code available ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/statechannels/apps/blob/master/packages/rps/src/utils/rps-channel-client.ts"}),"here"),"):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"export class RPSChannelClient {\n  // store our instance of the ChannelClient as a propery of this class\n  constructor(readonly channelClient: ChannelClient) {}\n\n  async createChannel(\n    aAddress: string,\n    bAddress: string,\n    aBal: string,\n    bBal: string,\n    appAttrs: AppData,\n    aOutcomeAddress: string = aAddress,\n    bOutcomeAddress: string = bAddress\n  ): Promise<ChannelState> {\n    const participants = formatParticipants(aAddress, bAddress, aOutcomeAddress, bOutcomeAddress);\n    const allocations = formatAllocations(aOutcomeAddress, bOutcomeAddress, aBal, bBal);\n    const appDefinition = RPS_ADDRESS;\n    const appData = encodeAppData(appAttrs);\n\n    const channelResult = await this.channelClient.createChannel(\n      participants,\n      allocations,\n      appDefinition,\n      appData,\n      'Direct'\n    );\n\n    return convertToChannelState(channelResult);\n  }\n\n  // Accepts an app-specific callback,\n  // performs the necessary encoding, and subscribes to the\n  // channelClient with an appropriate, API-compliant callback\n  onChannelUpdated(appCallback: (channelState: ChannelState) => any) {\n    return this.channelClient.onChannelUpdated(async cr => {\n      const channelState = convertToChannelState(cr);\n      appCallback(channelState);\n    });\n  }\n\n  // ... and wrappers for the other methods\n}\n\nconst convertToChannelState = (channelResult: ChannelResult): ChannelState => {\n  const {\n    turnNum,\n    channelId,\n    status,\n    participants,\n    allocations,\n    appData,\n    challengeExpirationTime\n  } = channelResult;\n  return {\n    channelId,\n    turnNum: turnNum.toString(),\n    status,\n    challengeExpirationTime,\n    appData: decodeAppData(appData),\n    aUserId: participants[0].participantId,\n    bUserId: participants[1].participantId,\n    aAddress: participants[0].destination,\n    bAddress: participants[1].destination,\n    aOutcomeAddress: participants[0].destination,\n    bOutcomeAddress: participants[1].destination,\n    aBal: bigNumberify(allocations[0].allocationItems[0].amount).toString(),\n    bBal: bigNumberify(allocations[0].allocationItems[1].amount).toString()\n  };\n};\n\nconst formatParticipants = (\n  aAddress: string,\n  bAddress: string,\n  aOutcomeAddress: string = aAddress,\n  bOutcomeAddress: string = bAddress\n) => [\n  {participantId: aAddress, signingAddress: aAddress, destination: aOutcomeAddress},\n  {participantId: bAddress, signingAddress: bAddress, destination: bOutcomeAddress}\n];\n\nconst formatAllocations = (aAddress: string, bAddress: string, aBal: string, bBal: string) => {\n  return [\n    {\n      token: '0x0', // We are sticking to ETH here\n      allocationItems: [\n        {destination: aAddress, amount: bigNumberify(aBal).toHexString()},\n        {destination: bAddress, amount: bigNumberify(bBal).toHexString()}\n      ]\n    }\n  ];\n};\n")),Object(o.b)("h2",{id:"maintain-a-cache-of-channel-state"},"Maintain a cache of channel state"),Object(o.b)("p",null,"This is convenient data structure to maintain inside your channel client wrapper, as it can provide data synchronously to your UI."))}l.isMDXComponent=!0},420:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return b}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),l=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=l(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},h=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=l(t),h=a,b=d["".concat(i,".").concat(h)]||d[h]||u[h]||o;return t?r.a.createElement(b,s(s({ref:n},c),{},{components:t})):r.a.createElement(b,s({ref:n},c))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);