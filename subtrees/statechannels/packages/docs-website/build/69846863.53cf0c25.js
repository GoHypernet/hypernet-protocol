(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{210:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(2),o=n(6),i=(n(0),n(420)),r={id:"asset-holder",title:"AssetHolder.sol"},s={unversionedId:"implementation-notes/asset-holder",id:"implementation-notes/asset-holder",isDocsHomePage:!1,title:"AssetHolder.sol",description:"The asset-holder contracts describe how ETH and/or tokens are held on-chain for any given channel, and how to interpret the channel outcomes in order to determine and execute any payouts that are due.",source:"@site/docs/implementation-notes/asset-holder.md",permalink:"/implementation-notes/asset-holder",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Introduction",permalink:"/implementation-notes/contract-devs-intro"},next:{title:"ForceMove.sol",permalink:"/implementation-notes/force-move"}},c=[{value:"Outcomes",id:"outcomes",children:[{value:"Destinations",id:"destinations",children:[]}]},{value:"Storage",id:"storage",children:[]},{value:"<code>deposit</code>",id:"deposit",children:[{value:"<code>ETHAssetHolder</code> checks",id:"ethassetholder-checks",children:[]},{value:"<code>ERC20AssetHolder</code> checks",id:"erc20assetholder-checks",children:[]}]},{value:"<code>setAssetOutcomeHash</code>",id:"setassetoutcomehash",children:[{value:"Permissions",id:"permissions",children:[]}]},{value:"<code>transferAll</code>",id:"transferall",children:[]},{value:"<code>claimAll</code>",id:"claimall",children:[]},{value:"<code>_transferAsset</code>",id:"_transferasset",children:[{value:"<code>ETHAssetHolder</code> transfer",id:"ethassetholder-transfer",children:[]},{value:"<code>ERC20AssetHolder</code> transfer",id:"erc20assetholder-transfer",children:[]}]}],l={rightToc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The asset-holder contracts describe how ETH and/or tokens are held on-chain for any given channel, and how to interpret the channel outcomes in order to determine and execute any payouts that are due."),Object(i.b)("p",null,"AssetHolder.sol is a base contract that it is not actually deployed. It is inherited by (for example) ETHAssetHolder.sol and ERC20AssetHolder.sol (which are deployed)."),Object(i.b)("p",null,"In Nitro a payout is of one of two types: it is either a payout to a channel participant or it is a payout to another channel. It is this second type of payout that allows channels to fund one another in Nitro, enabling the virtual channels that are used to build state channel networks."),Object(i.b)("p",null,"Nitro is implemented in ",Object(i.b)("inlineCode",{parentName:"p"},"AssetHolder.sol"),", which conforms to the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../contract-api/natspec/IAssetHolder"}),Object(i.b)("inlineCode",{parentName:"a"},"IAssetHolder"))," interface and"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Interprets final outcomes supplied by adjudicator contracts"),Object(i.b)("li",{parentName:"ol"},"Allows escrowed assets to be transferred from channels to their beneficiaries")),Object(i.b)("p",null,"This contract is only used as a base contract, and is extended by ",Object(i.b)("inlineCode",{parentName:"p"},"ETHAssetHolder.sol")," and ",Object(i.b)("inlineCode",{parentName:"p"},"ERC20AssetHolder.sol")," which additionally:"),Object(i.b)("ol",{start:3},Object(i.b)("li",{parentName:"ol"},"Stipulate how assets are deposited and paid out to external destinations.")),Object(i.b)("hr",null),Object(i.b)("h2",{id:"outcomes"},"Outcomes"),Object(i.b)("p",null,"ForceMove specifies that a state should have a default ",Object(i.b)("inlineCode",{parentName:"p"},"outcome")," but does not specify the format of that ",Object(i.b)("inlineCode",{parentName:"p"},"outcome"),", and simply treats it as an unstructured ",Object(i.b)("inlineCode",{parentName:"p"},"bytes")," field. In this section we look at the outcome formats needed for Nitro."),Object(i.b)("p",null,"Nitro supports multiple different assets (e.g. ETH and one or more ERC20s) being held in the same channel."),Object(i.b)("p",null,"The outcome is stored in two places: first, as a single hash in the adjudicator contract; second, in multiple hashes across multiple asset holder contracts."),Object(i.b)("p",null,"The adjudicator stores (the hash of) an encoded ",Object(i.b)("inlineCode",{parentName:"p"},"outcome")," for each finalized channel. As a part of the process triggered by ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/implementation-notes/nitro-adjudicator#push-outcome"}),Object(i.b)("inlineCode",{parentName:"a"},"pushOutcome")),", a decoded outcome will be stored across multiple asset holder contracts in a number of hashes. A decoded ",Object(i.b)("inlineCode",{parentName:"p"},"outcome")," is an array of ",Object(i.b)("inlineCode",{parentName:"p"},"OutcomeItems"),". These individual ",Object(i.b)("inlineCode",{parentName:"p"},"OutcomeItems")," contain a pointer to the asset holder contract in question, as well as some ",Object(i.b)("inlineCode",{parentName:"p"},"bytes")," that encode a ",Object(i.b)("inlineCode",{parentName:"p"},"AssetOutcome"),". The ",Object(i.b)("inlineCode",{parentName:"p"},"AssetOutcomes")," are each stored (abi encoded and hashed) by the asset holder contract specified. This data structure contains some more ",Object(i.b)("inlineCode",{parentName:"p"},"bytes")," encoding either an allocation or a guarantee, as well as the ",Object(i.b)("inlineCode",{parentName:"p"},"AssetOutcomeType"),": an integer which indicates which."),Object(i.b)("p",null,"In ",Object(i.b)("inlineCode",{parentName:"p"},"Outcome.sol"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary Outcome {\n  // An outcome is an array of OutcomeItems\n  // Outcome = OutcomeItem[]\n  // OutcomeItem = (AssetHolderAddress, AssetOutcome)\n  // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\n  // Allocation = AllocationItem[]\n  // AllocationItem = (Destination, Amount)\n  // Guarantee = (ChannelId, Destination[])\n  // Destination = ChannelId | ExternalDestination\n\n  struct OutcomeItem {\n    address assetHolderAddress;\n    bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\n  }\n\n  enum AssetOutcomeType {Allocation, Guarantee}\n\n  struct AssetOutcome {\n    uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\n    bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\n  }\n\n  // reserve Allocation to refer to AllocationItem[]\n  struct AllocationItem {\n    bytes32 destination;\n    uint256 amount;\n  }\n\n  struct Guarantee {\n    bytes32 targetChannelId;\n    bytes32[] destinations;\n  }\n\n}\n")),Object(i.b)("h3",{id:"destinations"},"Destinations"),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"Destination")," is a ",Object(i.b)("inlineCode",{parentName:"p"},"bytes32")," and either:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"A ",Object(i.b)("inlineCode",{parentName:"li"},"ChannelId")," (see the section on ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/implementation-notes/force-move#channelid"}),"channelId"),"), or"),Object(i.b)("li",{parentName:"ol"},"An ",Object(i.b)("inlineCode",{parentName:"li"},"ExternalDestination"),", which is an ethereum address left-padded with zeros.")),Object(i.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"In JavaScript, the ",Object(i.b)("inlineCode",{parentName:"p"},"ExternalDestination")," corresponding to ",Object(i.b)("inlineCode",{parentName:"p"},"address")," may be computed as"),Object(i.b)("pre",{parentName:"div"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"'0x' + address.padStart(64, '0')\n")))),Object(i.b)("hr",null),Object(i.b)("h2",{id:"storage"},"Storage"),Object(i.b)("p",null,"An AssetHolder will store the following information:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"address AdjudicatorAddress; // used to apply permissions to certain methods\n\nmapping(bytes32 => uint256) public holdings; // assets stored against channelIds\n\nmapping(bytes32 => bytes32) public assetOutcomeHashes; // asset outcomes stored against channelIds\n\n")),Object(i.b)("h2",{id:"deposit"},Object(i.b)("inlineCode",{parentName:"h2"},"deposit")),Object(i.b)("p",null,"The deposit method allows ETH or ERC20 tokens to be escrowed against a channel."),Object(i.b)("p",null,"Call signature:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"function deposit(bytes32 destination, uint256 expectedHeld, uint256 amount) public payable\n")),Object(i.b)("p",null,"Checks:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"destination")," must NOT be an ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#destinations"}),"external destination"),"."),Object(i.b)("li",{parentName:"ul"},"The holdings for ",Object(i.b)("inlineCode",{parentName:"li"},"destination")," must be greater than or equal to ",Object(i.b)("inlineCode",{parentName:"li"},"expectedHeld"),"."),Object(i.b)("li",{parentName:"ul"},"The holdings for ",Object(i.b)("inlineCode",{parentName:"li"},"destination")," must be less than the sum of the amount expected to be held and the amount declared in the deposit.")),Object(i.b)("h3",{id:"ethassetholder-checks"},Object(i.b)("inlineCode",{parentName:"h3"},"ETHAssetHolder")," checks"),Object(i.b)("p",null,"The transaction must be accompanied by exactly ",Object(i.b)("inlineCode",{parentName:"p"},"amount")," wei."),Object(i.b)("h3",{id:"erc20assetholder-checks"},Object(i.b)("inlineCode",{parentName:"h3"},"ERC20AssetHolder")," checks"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"ERC20AssetHolder.sol")," includes an interface to a particular ERC20 Token with an address baked in at deploy-time."),Object(i.b)("p",null,"This contract must be able to successfully call ",Object(i.b)("inlineCode",{parentName:"p"},"transferFrom")," on that ERC20 Token contract, with the Token account being ",Object(i.b)("inlineCode",{parentName:"p"},"msg.sender")," with a sufficient number of tokens specified."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"// ...\n  IERC20 Token;\n//...\n}\n\ncontract IERC20 {\n    // Abstraction of the parts of the ERC20 Interface that we need\n    function transfer(address to, uint256 tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n}\n\n")),Object(i.b)("p",null,"Effects:"),Object(i.b)("p",null,"Increase holdings for ",Object(i.b)("inlineCode",{parentName:"p"},"destination")," to the sum of the amount expected to be held and the amount declared in the deposit."),Object(i.b)("p",null,"Emit a ",Object(i.b)("inlineCode",{parentName:"p"},"Deposited")," event with ",Object(i.b)("inlineCode",{parentName:"p"},"indexed")," parameter ",Object(i.b)("inlineCode",{parentName:"p"},"destination"),"."),Object(i.b)("div",{className:"admonition admonition-warning alert alert--danger"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"You may only deposit to a channel address. This is currently enforced at the contract level, but this may change in future. Do not attempt to deposit into external destinations."))),Object(i.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"Depositing ahead of those with higher precedence is not safe (they can steal your funds). Always ensure that the channel is funded up to and including all players with higher precedence, before making a deposit."))),Object(i.b)("h2",{id:"setassetoutcomehash"},Object(i.b)("inlineCode",{parentName:"h2"},"setAssetOutcomeHash")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"setAssetOutcomeHash")," method allows an outcome (more strictly, an ",Object(i.b)("inlineCode",{parentName:"p"},"outcomeHash"),") to be registered against a channel."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        AdjudicatorOnly\n        returns (bool success)\n")),Object(i.b)("p",null,"It may only be called by the Nitro Adjudicator."),Object(i.b)("h3",{id:"permissions"},"Permissions"),Object(i.b)("p",null,"The following function modifier restricts permission to a certain Adjudicator."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"    modifier AdjudicatorOnly {\n        require(msg.sender == AdjudicatorAddress, 'Only the NitroAdjudicator is authorized');\n        _;\n    }\n")),Object(i.b)("p",null,"Checks:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A single adjudicator address is baked into this contract at deploy-time"),Object(i.b)("li",{parentName:"ul"},"Is ",Object(i.b)("inlineCode",{parentName:"li"},"msg.sender")," equal to this address?")),Object(i.b)("p",null,"Effects:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"store ",Object(i.b)("inlineCode",{parentName:"li"},"assetOutcomeHash")," against ",Object(i.b)("inlineCode",{parentName:"li"},"channelId"),".")),Object(i.b)("hr",null),Object(i.b)("h2",{id:"transferall"},Object(i.b)("inlineCode",{parentName:"h2"},"transferAll")),Object(i.b)("p",null,"The transferAll method takes the funds escrowed against a channel, and attempts to transfer them to the beneficiaries of that channel. The transfers are attempted in priority order, so that beneficiaries of underfunded channels may not receive a transfer, depending on their priority. Surplus funds remain in escrow against the channel. Full or partial transfers to a beneficiary results in deletion or reduction of that beneficiary's allocation (respectively). A transfer to another channel results in explicit escrow of funds against that channel. A transfer to an external destination results in ETH or ERC20 tokens being transferred out of the AssetHolder contract."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"function transferAll(bytes32 channelId, bytes calldata allocationBytes) external\n")),Object(i.b)("p",null,"This algorithm works by counting the number of ",Object(i.b)("inlineCode",{parentName:"p"},"AllocationItems")," that are to be completely converted into payouts. The remaining ",Object(i.b)("inlineCode",{parentName:"p"},"AllocationItems")," will be stored in a new ",Object(i.b)("inlineCode",{parentName:"p"},"Allocation")," and the storage mapping updated. There can be at most a single item that is a partial payout -- in this case the appropriately modified ",Object(i.b)("inlineCode",{parentName:"p"},"AllocationItem")," is also preserved. This is called the 'overlap' case."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"claimall"},Object(i.b)("inlineCode",{parentName:"h2"},"claimAll")),Object(i.b)("p",null,"The claimAll method takes the funds escrowed against a guarantor channel, and attempts to transfer them to the beneficiaries of the target channel specified by the guarantor. The transfers are first attempted in a nonstandard priority order given by the guarantor, so that beneficiaries of underfunded channels may not receive a transfer, depending on their nonstandard priority. Full or partial transfers to a beneficiary results in deletion or reduction of that beneficiary's allocation (respectively). Surplus funds are then subject to another attempt to transfer them to the beneficiaries of the target channel, but this time with the standard priority order given by the target channel. Any funds that still remain after this step remain in escrow against the guarantor."),Object(i.b)("p",null,"As with ",Object(i.b)("inlineCode",{parentName:"p"},"transferAll"),", a transfer to another channel results in explicit escrow of funds against that channel. A transfer to an external destination results in ETH or ERC20 tokens being transferred out of the AssetHolder contract."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"   function claimAll(\n        bytes32 channelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external\n")),Object(i.b)("p",null,"In comparison to ",Object(i.b)("inlineCode",{parentName:"p"},"transferAll"),", in ",Object(i.b)("inlineCode",{parentName:"p"},"claimAll")," it is more difficult to track the unknown number of payouts and new ",Object(i.b)("inlineCode",{parentName:"p"},"AllocationItems"),". An array of payouts is initialized with the same length as the target channel's allocation. While the balance is positive, and for each destination in the guarantee, find the first occurrence of that destination in the target channel's allocation. If there is sufficient balance remaining, increase the payout and decrease the number of new allocation items. If there is insufficient balance remaining, assign all of it to a payout (and the balance becomes zero), decrease the amount in the allocation item, and do not decrease the number of new allocation items. With the remaining balance (if any) continue thus: While the balance remains positive, and for each item in the target channel's allocation, if there is sufficient balance remaining, increase the payout and decrease the number of new allocation items. If there is insufficient balance remaining, assign all of it to a payout (and the balance becomes zero), decrease the amount in the allocation item, and do not decrease the number of new allocation items."),Object(i.b)("p",null,"Finally, update the holdings, compute the new allocation and update the storage, and execute the payouts."),Object(i.b)("hr",null),Object(i.b)("h2",{id:"_transferasset"},Object(i.b)("inlineCode",{parentName:"h2"},"_transferAsset")),Object(i.b)("p",null,"This internal method executes transfers of assets external to the Nitro network."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"function _transferAsset(address payable destination, uint256 amount) internal {}\n")),Object(i.b)("p",null,"The behavior is slightly different depending on the asset that has been escrowed:"),Object(i.b)("h3",{id:"ethassetholder-transfer"},Object(i.b)("inlineCode",{parentName:"h3"},"ETHAssetHolder")," transfer"),Object(i.b)("p",null,"Executes an ethereum ",Object(i.b)("inlineCode",{parentName:"p"},"transfer")," of ",Object(i.b)("inlineCode",{parentName:"p"},"amount")," to ",Object(i.b)("inlineCode",{parentName:"p"},"destination"),"."),Object(i.b)("h3",{id:"erc20assetholder-transfer"},Object(i.b)("inlineCode",{parentName:"h3"},"ERC20AssetHolder")," transfer"),Object(i.b)("p",null,"Calls ",Object(i.b)("inlineCode",{parentName:"p"},"transfer(destination,amount)")," on the specified Token contract."))}d.isMDXComponent=!0},420:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=d(n),h=a,u=b["".concat(r,".").concat(h)]||b[h]||p[h]||i;return n?o.a.createElement(u,s(s({ref:t},l),{},{components:n})):o.a.createElement(u,s({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);