(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{329:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return h}));var a=n(2),i=n(6),o=(n(0),n(420)),s=n(425),r={id:"execute-state-transitions",title:"Execute state transitions off chain"},c={unversionedId:"protocol-tutorial/execute-state-transitions",id:"protocol-tutorial/execute-state-transitions",isDocsHomePage:!1,title:"Execute state transitions off chain",description:"A state channel can be thought of as an emergent property of data (which we call state) exchanged between a fixed set of actors (which we call participants). The participants have the ability to digitially sign the states that they exchange, and they also keep track of the underlying chainId and channelNonce to uniquely identify the interaction they are about to perform.",source:"@site/docs/protocol-tutorial/execute-state-transitions.md",permalink:"/protocol-tutorial/execute-state-transitions",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Tutorial",permalink:"/protocol-docs/tutorial"},next:{title:"Deposit Assets",permalink:"/protocol-tutorial/deposit-assets"}},l=[{value:"Construct a State with the correct format",id:"construct-a-state-with-the-correct-format",children:[]},{value:"Fixed and Variable Parts",id:"fixed-and-variable-parts",children:[]},{value:"Conform to an on chain <code>validTransition</code> function",id:"conform-to-an-on-chain-validtransition-function",children:[{value:"Application logic",id:"application-logic",children:[]},{value:"Setup states",id:"setup-states",children:[]}]},{value:"Support a state in several different ways",id:"support-a-state-in-several-different-ways",children:[]}],p={rightToc:l};function h(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A state channel can be thought of as an emergent property of data (which we call ",Object(o.b)("inlineCode",{parentName:"p"},"state"),") exchanged between a fixed set of actors (which we call ",Object(o.b)("inlineCode",{parentName:"p"},"participants"),"). The participants have the ability to digitially sign the states that they exchange, and they also keep track of the underlying ",Object(o.b)("inlineCode",{parentName:"p"},"chainId")," and ",Object(o.b)("inlineCode",{parentName:"p"},"channelNonce")," to uniquely identify the interaction they are about to perform."),Object(o.b)("h2",{id:"construct-a-state-with-the-correct-format"},"Construct a State with the correct format"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"@statechannels/nitro-protocol")," exposes a ",Object(o.b)("inlineCode",{parentName:"p"},"State")," type as a container for all the fields that are required:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson1.test.ts\n\n/* Import ethereum wallet utilities  */\nimport {ethers} from 'ethers';\nconst {bigNumberify} = ethers.utils;\nconst {AddressZero, HashZero} = ethers.constants;\n\n/* Import statechannels wallet utilities  */\nimport {Channel, Outcome, State} from '@statechannels/nitro-protocol';\n\n/* Form the participants array */\nconst participants = [];\nfor (let i = 0; i < 3; i++) {\n  participants[i] = ethers.Wallet.createRandom().address;\n}\n\n/* Mock out a chainId: this could be '1' for mainnet or '3' for ropsten */\nconst chainId = '0x1234';\n\n/* \n    Define the channelNonce \n    :~ how many times have these participants\n    already run a channel on this chain?\n  */\nconst channelNonce = 0;\n\n/* \n    Define the challengeDuration \n    :~ how long should participants get to respond to challenges?\n  */\nconst challengeDuration = 1;\n\n/* \n    Mock out the appDefinition and appData.\n    We will get to these later in the tutorial\n  */\nconst appDefinition = AddressZero;\nconst appData = HashZero;\n\n/* Construct a Channel object */\nconst channel: Channel = {chainId, channelNonce, participants};\n\n/* Mock out an outcome */\nconst outcome: Outcome = [];\n\n/* Putting it all together */\nconst state: State = {\n  turnNum: 0,\n  isFinal: false,\n  channel,\n  challengeDuration,\n  outcome,\n  appDefinition,\n  appData\n};\n")),Object(o.b)("p",null,"Notice that the outcome field must conform to the ",Object(o.b)("inlineCode",{parentName:"p"},"Outcome")," type, which we also imported from ",Object(o.b)("inlineCode",{parentName:"p"},"@statechannels/nitro-protocol"),". The outcome is some data that specifies a redistribution of funds when the channel finalizes. Don't worry about this field just yet, we will revisit it later (we got away with an empty array, for now)."),Object(o.b)("h2",{id:"fixed-and-variable-parts"},"Fixed and Variable Parts"),Object(o.b)("p",null,"It is convenient to define some solidity structs, each containing a subset of the above data:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"  struct FixedPart {\n        uint256 chainId;\n        address[] participants;\n        uint256 channelNonce;\n        address appDefinition;\n        uint256 challengeDuration;\n    }\n")),Object(o.b)("p",null,"which contains information which must be identical in every state channel update, and"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"   struct VariablePart {\n        bytes outcome;\n        bytes appData;\n    }\n")),Object(o.b)("p",null,"which contains fields which are allowed to change. These structs are part of the contract API, and we can import helper functions to extract a javascript encoding of them:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"import {getFixedPart, getVariablePart} from '@statechannels/nitro-protocol';\n\nconst fixedPart = getFixedPart(state);\nconst getVariablePart = getVariablePart(state);\n")),Object(o.b)("h2",{id:"conform-to-an-on-chain-validtransition-function"},"Conform to an on chain ",Object(o.b)("inlineCode",{parentName:"h2"},"validTransition")," function"),Object(o.b)("p",null,"In ForceMove, every state has an associated 'mover' - the participant who had the unique ability to progress the channel at the point the state was created. The mover can be calculated from the ",Object(o.b)("inlineCode",{parentName:"p"},"turnNum")," and the ",Object(o.b)("inlineCode",{parentName:"p"},"participants")," as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"moverAddress = participants[turnNum % participants.length]\n")),Object(o.b)("p",null,"The implication of this formula is that participants take turns to update the state of the channel. Furthermore, there are strict rules about whether a state update is valid, based on the previous state that has been announced. Beyond conforming to the state format, there are certain relationships that must hold between the state in question, and the previously announced state."),Object(o.b)("p",null,"The full rule set is (pseudo-code):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-solidity"}),"function validTransition(a, b) <=>\n  b.turnNum == a.turnNum + 1\n  b.chainId == a.chainId\n  b.participants == a.participants\n  b.appDefinition == a.appDefinition\n  b.challengeDuration == a.challengeDuration\n  a.signer == a.mover\n  b.signer == b.mover\n  if b.isFinal\n     b.defaultOutcome == a.defaultOutcome\n  else if b.turnNum < 2n\n     a.isFinal == False\n     b.defaultOutcome == a.defaultOutcome\n     b.appData == a.appData\n   else\n     a.isFinal == False\n     b.app.validTransition(a, b)\n")),Object(o.b)("h3",{id:"application-logic"},"Application logic"),Object(o.b)("p",null,"Note the use of ",Object(o.b)("inlineCode",{parentName:"p"},"app.ValidTransition"),". This function should be written by third party DApp developers. We provide a ",Object(o.b)("inlineCode",{parentName:"p"},"TrivialApp")," contract which always returns ",Object(o.b)("inlineCode",{parentName:"p"},"true"),", to aid in testing:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson2.test.ts\n\n/* Construct a state */\nconst fromState: State = {\n  channel,\n  outcome: [],\n  turnNum: 0,\n  isFinal: false,\n  challengeDuration: 0x0,\n  appDefinition: process.env.TRIVIAL_APP_ADDRESS,\n  appData: '0x0'\n};\n\n/* Construct another state */\nconst toState: State = {...fromState, turnNum: 1};\n\n/* \n  Check validity of transition from one state to the other\n  using on chain function\n */\nexpect(\n  await NitroAdjudicator.validTransition(\n    channel.participants.length,\n    [fromState.isFinal, toState.isFinal],\n    [getVariablePart(fromState), getVariablePart(toState)],\n    toState.turnNum, // We only get to submit one turn number so cannot check validity\n    // If incorrect, transactions will fail during a check on state signatures\n    fromState.appDefinition\n  )\n).toBe(true);\n")),Object(o.b)("h3",{id:"setup-states"},"Setup states"),Object(o.b)("p",null,"If ",Object(o.b)("inlineCode",{parentName:"p"},"n")," is the number of participants, then states with turn numbers ",Object(o.b)("inlineCode",{parentName:"p"},"0")," through ",Object(o.b)("inlineCode",{parentName:"p"},"n-1"),' (inclusive) are known as "pre fund setup" states. They signal each participant\'s intention to join the channel with a particular outcome specified.'),Object(o.b)("p",null,"Once a pre fund setup state with turn number ",Object(o.b)("inlineCode",{parentName:"p"},"n-1")," is supported, it is safe for the channel to be funded."),Object(o.b)("p",null,"States with turn numbers ",Object(o.b)("inlineCode",{parentName:"p"},"n")," through ",Object(o.b)("inlineCode",{parentName:"p"},"2n-1"),' (inclusive) are known as "post fund setup" states. They signal each participant\'s agreement that the channel is fully funded. Once a post fund setup state with turn number ',Object(o.b)("inlineCode",{parentName:"p"},"2n-1")," is supported, the state channel can begin execution in earnest (updating the ",Object(o.b)("inlineCode",{parentName:"p"},"appData")," and ",Object(o.b)("inlineCode",{parentName:"p"},"outcome"),")."),Object(o.b)("h2",{id:"support-a-state-in-several-different-ways"},"Support a state in several different ways"),Object(o.b)("p",null,"Although you can check the validity of a state transition by providing the data above to an on-chain method, to cause any meaningful change in on-chain state (such as releasing funds), digitial signatures on those states are also required."),Object(o.b)("p",null,"Nitro protocol uses the idea of supporting a state: in order for the chain to accept a channel state, ",Object(o.b)("inlineCode",{parentName:"p"},"s"),", that channel state must be accompanied by a ",Object(o.b)("em",{parentName:"p"},"support proof"),": i.e. exactly ",Object(o.b)("inlineCode",{parentName:"p"},"n")," signatures (where ",Object(o.b)("inlineCode",{parentName:"p"},"n = participants.length"),"). The simplest way to accomplish this is to provide a sequence of ",Object(o.b)("inlineCode",{parentName:"p"},"n")," states terminating is state ",Object(o.b)("inlineCode",{parentName:"p"},"s"),", where each state is signed by its mover and each consecutive pair of states form a valid transition."),Object(o.b)("p",null,"There is also an optimization where a state can be supported by ",Object(o.b)("inlineCode",{parentName:"p"},"n")," signatures on a sequence of ",Object(o.b)("inlineCode",{parentName:"p"},"m < n")," states, provided again that each consecutive pair of those ",Object(o.b)("inlineCode",{parentName:"p"},"m")," states form a valid transition and further provided each participant has provided a signature on a state later or equal in the sequence than the state for which they were the mover."),Object(o.b)("p",null,"In the extreme, this allows a single state signed by all ",Object(o.b)("inlineCode",{parentName:"p"},"n")," parties to be accepted by the chain."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"In most cases where a support proof is required for some change of state of the chain, the entire proof is submitted with the blockchain transaction: no on-chain channel states are involved. The ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"protocol-tutorial/clear-a-challenge#call-respond"}),Object(o.b)("inlineCode",{parentName:"a"},"respond"))," method is an exception to this rule, and allows for the submission of only a single state in certain circumstances, with the support proof being implied by a combination of on-chain storage and submitted data."))),Object(o.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},'Nitro wallets need only store the "last" ',Object(o.b)("inlineCode",{parentName:"p"},"n")," states, because they never need to submit more than ",Object(o.b)("inlineCode",{parentName:"p"},"n")," states to the chain."))),Object(o.b)("p",null,"In the following diagram, A is participant 0, B is participant 1 and C is participant 2. The states are shown by circles and numbered 0, 1, and 2. We are considering whether state with ",Object(o.b)("inlineCode",{parentName:"p"},"turnNum = 2")," is supported by various sets of signatures on the states in the sequence."),Object(o.b)("p",null,"The yellow boxes show who signed what: in the first example, everyone signed their own state. This ",Object(o.b)("em",{parentName:"p"},"is")," acceptable:"),Object(o.b)(s.a,{chart:"\ngraph LR;\nsubgraph A\nzero((0))\nend\nsubgraph B\none((1))\nend\nsubgraph C\ntwo((2))\nend\nzero--\x3eone;\none--\x3etwo;\n",mdxType:"Mermaid"}),Object(o.b)("p",null,"Alternatively, A could sign a later state in the sequence:"),Object(o.b)(s.a,{chart:'\ngraph LR;\nsubgraph " "\nzero((0))\nend\nsubgraph "A, B"\none((1))\nend\nsubgraph C\ntwo((2))\nend\nzero--\x3eone;\none--\x3etwo;\n',mdxType:"Mermaid"}),Object(o.b)("p",null,"or A, B and C could all sign the final state in the sequence:"),Object(o.b)(s.a,{chart:'\ngraph LR;\nsubgraph " "\nzero((0))\nend\nsubgraph " "\none((1))\nend\nsubgraph "A, B, C"\ntwo((2))\nend\nzero--\x3eone;\none--\x3etwo;\n',mdxType:"Mermaid"}),Object(o.b)("p",null,"The following signatures would ",Object(o.b)("em",{parentName:"p"},"not")," be acceptable:"),Object(o.b)(s.a,{chart:'\ngraph LR;\nsubgraph " "\nzero((0))\nend\nsubgraph "B, C"\none((1))\nend\nsubgraph A\ntwo((2))\nend\nzero--\x3eone;\none--\x3etwo;\n',mdxType:"Mermaid"}),Object(o.b)("p",null,"This is because C signed a state ",Object(o.b)("em",{parentName:"p"},"earlier")," in the sequence than the one she is the mover for."),Object(o.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Note that there is no need to submit a state if it is ",Object(o.b)("em",{parentName:"p"},"both")," not signed by anybody ",Object(o.b)("em",{parentName:"p"},"and")," is not preceeded by any signed states."))),Object(o.b)("p",null,"We provide a helper function to sign a ",Object(o.b)("inlineCode",{parentName:"p"},"State"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"import {signState} from '@statechannels/nitro-protocol';\n\nconst wallet = Wallet.createRandom();\nconst state: State = {\n  channel: {chainId: '0x1', channelNonce: 1, participants: [wallet.address]},\n  outcome: [],\n  turnNum: 1,\n  isFinal: false,\n  appData: '0x0',\n  appDefinition: AddressZero,\n  challengeDuration: 0x5\n};\n\nconst signedState: SignedState = signState(state, wallet.privateKey);\n")),Object(o.b)("p",null,"it returns an object of the ",Object(o.b)("inlineCode",{parentName:"p"},"SignedState")," type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"import {Signature} from '@statechannels/nitro-protocol';\nexport interface SignedState {\n  state: State;\n  signature: Signature;\n}\n")),Object(o.b)("p",null,"which we can make use of in the rest of the tutorial."),Object(o.b)("p",null,"Alternatively you may use ",Object(o.b)("inlineCode",{parentName:"p"},"signStates(states, wallets, whoSignedWhat)"),",\nwhich accepts an array of ",Object(o.b)("inlineCode",{parentName:"p"},"States"),", an array of ethers.js ",Object(o.b)("inlineCode",{parentName:"p"},"Wallets")," and a ",Object(o.b)("inlineCode",{parentName:"p"},"whoSignedWhat")," array of integers. The implicit definition of this last argument is as follows: For each participant, we are asserting that ",Object(o.b)("inlineCode",{parentName:"p"},"participant[i]")," signed ",Object(o.b)("inlineCode",{parentName:"p"},"states[whoSignedWhat[i]]"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson3.test.ts\n\n/* Construct an array of 3 States */\nconst numStates = 3;\nconst largestTurnNum = 2;\nconst states: State[] = [];\nfor (let i = 1; i <= numStates; i++) {\n  states.push({\n    isFinal: false,\n    channel,\n    outcome: [],\n    appDefinition: AddressZero,\n    appData: HashZero,\n    challengeDuration: 1,\n    turnNum: largestTurnNum + i - numStates\n  });\n}\n\n/* Sign the states */\nconst whoSignedWhat = [0, 1, 2];\nconst sigs = await signStates(states, wallets, whoSignedWhat);\n\n/*\n * Use the checkpoint method to test our signatures\n * Tx will revert if they are incorrect\n */\nconst fixedPart = getFixedPart(states[0]);\nconst variableParts = states.map(s => getVariablePart(s));\nconst isFinalCount = states.filter(s => s.isFinal).length;\n\nconst tx = NitroAdjudicator.checkpoint(\n  fixedPart,\n  largestTurnNum,\n  variableParts,\n  isFinalCount,\n  sigs,\n  whoSignedWhat\n);\nawait(await tx).wait();\n")))}h.isMDXComponent=!0},425:function(e,t,n){"use strict";var a=n(0),i=n.n(a),o=n(438),s=n.n(o);s.a.initialize({startOnLoad:!0});t.a=function(e){var t=e.chart;return Object(a.useEffect)((function(){s.a.contentLoaded()}),[]),i.a.createElement("div",{className:"mermaid",align:"center"},t)}},441:function(e,t,n){var a={"./locale":424,"./locale.js":424};function i(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=o,e.exports=i,i.id=441}}]);