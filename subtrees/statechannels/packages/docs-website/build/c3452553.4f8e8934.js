(window.webpackJsonp=window.webpackJsonp||[]).push([[283],{334:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return r})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return h}));var a=t(2),i=t(6),s=(t(0),t(420)),l=t(425),o={id:"off-chain-funding",title:"Off-chain funding"},r={unversionedId:"protocol-tutorial/off-chain-funding",id:"protocol-tutorial/off-chain-funding",isDocsHomePage:!1,title:"Off-chain funding",description:"This advanced section of the tutorial covers funding and defunding channels by redistributing assets off chain. This has the great advantage of removing the need for most on-chain transactions.",source:"@site/docs/protocol-tutorial/off-chain-funding.md",permalink:"/protocol-tutorial/off-chain-funding",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Release assets",permalink:"/protocol-tutorial/release-assets"},next:{title:"Introduction",permalink:"/implementation-notes/contract-devs-intro"}},c=[{value:"Indirect funding",id:"indirect-funding",children:[]},{value:"Indirect defunding",id:"indirect-defunding",children:[{value:"Challenging with a deep funding tree",id:"challenging-with-a-deep-funding-tree",children:[]}]}],d={rightToc:c};function h(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"This advanced section of the tutorial covers funding and defunding channels by redistributing assets off chain. This has the great advantage of removing the need for most on-chain transactions."),Object(s.b)("h2",{id:"indirect-funding"},"Indirect funding"),Object(s.b)("p",null,'Let\'s introduce one level of indirection between the chain and the state channel we want to fund. We will first set up a ledger channel (L) with a counterparty (we\'ll call this counterparty "the hub"). We will fund the ledger channel "directly" -- in the same way as we have done ',Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/protocol-tutorial/deposit-assets"}),"earlier in the tutorial"),"."),Object(s.b)("p",null,"A ledger channel is a special channel that runs the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/implementation-notes/null-app"}),"null app")," (meaning that all transitions are considered invalid, and the channel may only be updated by a state being supported by all participants signing it). The sole purpose of this ledger channel is to reallocate some or all of its funding to other channels and/or state channel participants."),Object(s.b)("p",null,"Now imagine that we want to play Rock Paper Scissors (or run some other state channel application) with that same participant. We'll open a new channel (A1) for that."),Object(s.b)("p",null,"Instead of funding it on chain, let's just divert some money from our existing ledger channel."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// In lesson16.test.ts\n// Construct a ledger channel with the hub\nconst mySigningKey = '0x7ab741b57e8d94dd7e1a29055646bafde7010f38a900f55bbd7647880faa6ee8';\nconst hubSigningKey = '0x2030b463177db2da82908ef90fa55ddfcef56e8183caf60db464bc398e736e6f';\nconst me = new ethers.Wallet(mySigningKey).address;\nconst hub = new ethers.Wallet(hubSigningKey).address;\nconst myDestination = convertAddressToBytes32(me);\nconst hubDestination = convertAddressToBytes32(hub);\nconst participants = [me, hub];\nconst chainId = '0x1234';\nconst ledgerChannel: Channel = {\n  chainId,\n  channelNonce: bigNumberify(0).toHexString(),\n  participants\n};\nconst ledgerChannelId = getChannelId(ledgerChannel);\n\n// Construct a state for that allocates 6 wei to each of us, and has turn numer n - 1\n// This is called the \"pre fund setup\" state\n\nconst sixEachStatePreFS: State = {\n  isFinal: false,\n  channel: ledgerChannel,\n  outcome: [\n    {\n      assetHolderAddress: ETH_ASSET_HOLDER_ADDRESS,\n      allocationItems: [\n        {destination: myDestination, amount: parseUnits('6', 'wei').toHexString()},\n        {destination: hubDestination, amount: parseUnits('6', 'wei').toHexString()}\n      ]\n    }\n  ],\n  appDefinition: AddressZero,\n  appData: HashZero,\n  challengeDuration: 1,\n  turnNum: 1\n};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(sixEachStatePreFS, mySigningKey);\nsignState(sixEachStatePreFS, hubSigningKey);\n\n// Desposit plenty of funds ON CHAIN\nconst amount = parseUnits('12', 'wei');\nconst destination = ledgerChannelId;\nconst expectedHeld = 0;\nconst tx0 = ETHAssetHolder.deposit(destination, expectedHeld, amount, {\n  value: amount\n});\nawait(await tx0).wait();\n\n// Construct a state that allocates 6 wei to each of us, but with turn number 2n - 1\n// This is called the \"post fund setup\" state\n\nconst sixEachStatePostFS: State = {...sixEachStatePreFS, turnNum: 3};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(sixEachStatePostFS, mySigningKey);\nsignState(sixEachStatePostFS, hubSigningKey);\n")),Object(s.b)("p",null,"So far, so standard. We have directly funded a channel, but this time we are calling it a ledger channel, L. The funding graph looks like this:"),Object(s.b)(l.a,{chart:"\ngraph LR;\nlinkStyle default interpolate basis;\nETHAssetHolder( )\nledger((L))\nme(( )):::external\nhub(( )):::external\nETHAssetHolder--\x3e|12|ledger;\nledger--\x3e|6|me;\nledger--\x3e|6|hub;\nclassDef external fill:#f96\n",mdxType:"Mermaid"}),Object(s.b)("hr",null),Object(s.b)("p",null,"Let's create the application channel:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Construct an application channel with the hub\nconst applicationChannel1: Channel = {\n  chainId,\n  channelNonce: bigNumberify(1).toHexString(),\n  participants\n};\nconst applicationChannel1Id = getChannelId(applicationChannel1);\n\n// Construct a state that allocates 3 wei to each of us, and has turn numer n - 1\n// This is the \"pre fund setup\" state for our application channel A1\n\nconst threeEachStatePreFS: State = {\n  isFinal: false,\n  channel: applicationChannel1,\n  outcome: [\n    {\n      assetHolderAddress: ETH_ASSET_HOLDER_ADDRESS,\n      allocationItems: [\n        {destination: myDestination, amount: parseUnits('3', 'wei').toHexString()},\n        {destination: hubDestination, amount: parseUnits('3', 'wei').toHexString()}\n      ]\n    }\n  ],\n  appDefinition: ROCK_PAPER_SCISSORS_ADDRESS,\n  appData: HashZero,\n  challengeDuration: 1,\n  turnNum: 1\n};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(threeEachStatePreFS, mySigningKey);\nsignState(threeEachStatePreFS, hubSigningKey);\n")),Object(s.b)("p",null,"We are now in the following situation:"),Object(s.b)(l.a,{chart:"\ngraph LR;\nlinkStyle default interpolate basis;\nETHAssetHolder( )\nledger((L))\nme(( )):::external\nhub(( )):::external\nme(( )):::external\nhub(( )):::external\nETHAssetHolder--\x3e|12|ledger;\nledger--\x3e|6|me;\nledger--\x3e|6|hub;\napp((A1)):::defunded\napp--\x3e|3|me;\napp--\x3e|3|hub;\nlinkStyle 3,4 opacity:0.2;\nclassDef external fill:#f96\nclassDef defunded opacity:0.2;\n",mdxType:"Mermaid"}),Object(s.b)("p",null,"The application channel A1 exists, but it is not yet funded."),Object(s.b)("hr",null),Object(s.b)("p",null,"Now we proceed to divert the funds:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Fund our first application channel OFF CHAIN\n// simply by collecting a support proof for a state such as this:\n\nconst threeEachAndSixForTheApp: State = {\n  isFinal: false,\n  channel: ledgerChannel,\n  outcome: [\n    {\n      assetHolderAddress: ETH_ASSET_HOLDER_ADDRESS,\n      allocationItems: [\n        {destination: myDestination, amount: parseUnits('3', 'wei').toHexString()},\n        {destination: hubDestination, amount: parseUnits('3', 'wei').toHexString()},\n        {\n          destination: applicationChannel1Id,\n          amount: parseUnits('6', 'wei').toHexString()\n        }\n      ]\n    }\n  ],\n  appDefinition: AddressZero,\n  appData: HashZero,\n  challengeDuration: 1,\n  turnNum: 4\n};\n\n// Construct the \"post fund setup\" state for the application channel\n\nconst threeEachStatePostFS: State = {\n  ...threeEachStatePreFS,\n  turnNum: 3\n};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(threeEachStatePostFS, mySigningKey);\nsignState(threeEachStatePostFS, hubSigningKey);\n")),Object(s.b)("p",null,"Finally, we have our indirectly funded channel"),Object(s.b)(l.a,{chart:"\ngraph LR;\nlinkStyle default interpolate basis;\nETHAssetHolder( )\nledger((L))\nme(( )):::external\nhub(( )):::external\nme(( )):::external\nhub(( )):::external\nETHAssetHolder--\x3e|12|ledger;\nledger--\x3e|3|me;\nledger--\x3e|3|hub;\nledger--\x3e|6|app\napp((A1))\napp--\x3e|3|me;\napp--\x3e|3|hub;\nclassDef external fill:#f96\n",mdxType:"Mermaid"}),Object(s.b)("p",null,"We could fund more application channels from the same ledger channel in the same way, if we wanted to."),Object(s.b)("h2",{id:"indirect-defunding"},"Indirect defunding"),Object(s.b)("p",null,"Let's say application A1 finished and between me and the hub, we finalize it off chain with an outcome that allocates all the funds to me. To defund it off chain, we just agree to get the funds back into the ledger channel in a manner that preserves each of our balances in the funding graph."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Construct a state that allocates 6 wei to me\n\nconst sixForMe: State = {\n  isFinal: true,\n  channel: applicationChannel1,\n  outcome: [\n    {\n      assetHolderAddress: ETH_ASSET_HOLDER_ADDRESS,\n      allocationItems: [{destination: myDestination, amount: parseUnits('6', 'wei').toHexString()}]\n    }\n  ],\n  appDefinition: ROCK_PAPER_SCISSORS_ADDRESS,\n  appData: HashZero,\n  challengeDuration: 1,\n  turnNum: 100\n};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(sixForMe, mySigningKey);\nsignState(sixForMe, hubSigningKey);\n")),Object(s.b)(l.a,{chart:"\ngraph LR;\nlinkStyle default interpolate basis;\nETHAssetHolder( )\nledger((L))\nme(( )):::external\nhub(( )):::external\nme(( )):::external\nhub(( )):::external\nETHAssetHolder--\x3e|12|ledger;\nledger--\x3e|3|me;\nledger--\x3e|3|hub;\nledger--\x3e|6|app\napp((A1))\napp--\x3e|6|me;\nclassDef external fill:#f96\n",mdxType:"Mermaid"}),Object(s.b)("hr",null),Object(s.b)("p",null,"Now"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"// Fund our first application channel OFF CHAIN\n// simply by collecting a support proof for a state such as this:\n\nconst nineForMeThreeForTheHub: State = {\n  isFinal: false,\n  channel: ledgerChannel,\n  outcome: [\n    {\n      assetHolderAddress: ETH_ASSET_HOLDER_ADDRESS,\n      allocationItems: [\n        {destination: myDestination, amount: parseUnits('9', 'wei').toHexString()},\n        {destination: hubDestination, amount: parseUnits('3', 'wei').toHexString()}\n      ]\n    }\n  ],\n  appDefinition: AddressZero,\n  appData: HashZero,\n  challengeDuration: 1,\n  turnNum: 5\n};\n\n// Collect a support proof by getting all participants to sign this state\nsignState(nineForMeThreeForTheHub, mySigningKey);\nsignState(nineForMeThreeForTheHub, hubSigningKey);\n")),Object(s.b)("p",null,"and the funding graph now looks like this:"),Object(s.b)(l.a,{chart:"\ngraph LR;\nlinkStyle default interpolate basis;\nETHAssetHolder( )\nledger((L))\nme(( )):::external\nhub(( )):::external\nme(( )):::external\nhub(( )):::external\nETHAssetHolder--\x3e|12|ledger;\nledger--\x3e|9|me;\nledger--\x3e|3|hub;\napp((A1)):::defunded\napp--\x3e|6|me;\nlinkStyle 3 opacity:0.2;\nclassDef external fill:#f96\nclassDef defunded opacity:0.2;\n",mdxType:"Mermaid"}),"The defunded channel A1 can now safely be discarded.",Object(s.b)("h3",{id:"challenging-with-a-deep-funding-tree"},"Challenging with a deep funding tree"),Object(s.b)("p",null,"If the hub goes AWOL, in the worst-case scenario we would need to finalize the ledger channel as well as ",Object(s.b)("em",{parentName:"p"},"all")," of the channels funded by that ledger channel, in order to recover our on chain deposit. See the section on ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/protocol-tutorial/finalize-a-channel-sad"}),"sad-path finalization"),"."))}h.isMDXComponent=!0},425:function(e,n,t){"use strict";var a=t(0),i=t.n(a),s=t(438),l=t.n(s);l.a.initialize({startOnLoad:!0});n.a=function(e){var n=e.chart;return Object(a.useEffect)((function(){l.a.contentLoaded()}),[]),i.a.createElement("div",{className:"mermaid",align:"center"},n)}},441:function(e,n,t){var a={"./locale":424,"./locale.js":424};function i(e){var n=s(e);return t(n)}function s(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=s,e.exports=i,i.id=441}}]);