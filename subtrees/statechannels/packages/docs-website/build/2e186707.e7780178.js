(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{129:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return d})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return r}));var l=t(2),a=t(6),i=(t(0),t(420)),s=t(425),d={id:"make-api-calls",title:"Make Wallet API calls"},o={unversionedId:"app-devs/make-api-calls",id:"app-devs/make-api-calls",isDocsHomePage:!1,title:"Make Wallet API calls",description:"Direct Funding",source:"@site/docs/app-devs/make-api-calls.md",permalink:"/app-devs/make-api-calls",lastUpdatedBy:"Caleb Ditchfield",lastUpdatedAt:1600126133,sidebar:"docs",previous:{title:"Hook up your messaging layer",permalink:"/app-devs/hook-up-messaging"},next:{title:"Recommended patterns",permalink:"/app-devs/recommended-patterns"}},c=[{value:"Direct Funding",id:"direct-funding",children:[]}],p={rightToc:c};function r(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(l.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"direct-funding"},"Direct Funding"),Object(i.b)("p",null,"In the following diagram, ",Object(i.b)("inlineCode",{parentName:"p"},"p = window.channelProvider"),", and Client(A/B) is an instance of the ",Object(i.b)("a",Object(l.a)({parentName:"p"},{href:"/typescript-api/channel-client.channelclient"}),Object(i.b)("inlineCode",{parentName:"a"},"ChannelClient")," class")," created by each participants' application."),Object(i.b)("p",null,'The diagram shows a typical "happy path", directly-funded state channel interaction between two instances A and B of ChannelClient, their respective Wallets, and the Blockchain.'),Object(i.b)("p",null,'Also shown is the "activation" of each wallet at certain times, indicating the UI will popup and the user may be required to send a blockchain transaction or otherwise signal their intent to perform an action.'),Object(i.b)(s.a,{chart:"\nsequenceDiagram\nparticipant WalletA\nparticipant ClientA\nparticipant ClientB\nparticipant WalletB\npar setup for Wallet A\nClientA->>WalletA: p.mountWalletComponent();\nClientA->>WalletA: p.enable();\nClientA->>WalletA: onMessageQueued(callback)\nClientA->>WalletA: onChannelProposed(callback)\nClientA->>WalletA: onChannelUpdated(callback)\nand setup for Wallet B\nClientB->>WalletB: p.mountWalletComponent();\nClientB->>WalletB: p.enable();\nClientB->>WalletB: onMessageQueued(callback)\nClientB->>WalletB: onChannelProposed(callback)\nClientB->>WalletB: onChannelUpdated(callback)\nend\nrect rgba(0, 0, 255, .1)\nnote left of WalletB: Opening a channel\nClientA->>WalletA: createChannel();\nWalletA--\x3e>ClientA: ChannelUpdated('proposed')\nWalletA--\x3e>ClientA: MessageQueued(msg0)\nClientA->>ClientB: msg0\nClientB->>WalletB: pushMessage(msg0)\nWalletB--\x3e>ClientB: ChannelProposed('id')\nClientB->>+WalletB: joinChannel('id');\nWalletB--\x3e>ClientB: ChannelUpdated('funding');\nWalletB--\x3e>ClientB: MessageQueued(msg1)\nClientB->>ClientA: msg1;\nClientA->>+WalletA: pushMessage(msg1);\nWalletA--\x3e>ClientA: ChannelUpdated('funding')\nWalletA->>Chain: deposit()\nChain--\x3e>WalletA: Deposited\nChain--\x3e>WalletB: Deposited\nWalletB->>Chain: deposit()\nChain--\x3e>WalletA: Deposited\nChain--\x3e>WalletB: Deposited\nWalletA--\x3e>ClientA: MessageQueued(msg2)\nClientA->>ClientB: msg2\nClientB->>WalletB: pushMessage(msg2)\nWalletB--\x3e>-ClientB: ChannelUpdated('running')\nWalletB--\x3e>ClientB: MessageQueued(msg3)\nClientB->>ClientA: msg3;\nClientA->>WalletA: pushMessage(msg3);\nWalletA--\x3e>-ClientA: ChannelUpdated('running')\nend\nloop 0...m\nnote left of WalletB: Running a channel\nClientA--\x3e>ClientA: Wait for UI\nClientA->>WalletA: updateChannel(state-A);\nWalletA--\x3e>ClientA: ChannelUpdated(state-A)\nClientA--\x3e>ClientA: Update UI\nWalletA--\x3e>ClientA: MessageQueued(msg-4+2m)\nClientA->>ClientB: msg-4+2m\nClientB->>WalletB: pushMessage(msg-4+2m)\nWalletB--\x3e>ClientB: ChannelUpdated(state-4+2m)\nClientB--\x3e>ClientB: Update UI\nClientB--\x3e>ClientB: Wait for UI\nClientB->>WalletB: updateChannel(state-5+2m);\nWalletB--\x3e>ClientB: ChannelUpdated(state-5+2m);\nClientB--\x3e>ClientB: Update UI\nWalletB--\x3e>ClientB: MessageQueued(msg-5+2m)\nClientB->>ClientA: msg-5+2m\nClientA->>WalletA: pushMessage(msg-5+2m)\nWalletA--\x3e>ClientA: ChannelUpdated(state-5+2m)\nClientA--\x3e>ClientA: Update UI\nend\nrect rgba(0, 0, 255, .1)\nnote left of WalletB: Closing a channel\nClientA--\x3e>ClientA: Wait for UI\nClientA->>WalletA: closeChannel();\nactivate WalletA\nWalletA--\x3e>ClientA: ChannelUpdated('closing')\nWalletA--\x3e>ClientA: MessageQueued(isFinalA)\nClientA->>ClientB: isFinalA\nClientB->>WalletB: pushMessage(isFinal)\nactivate WalletB\nWalletB--\x3e>ClientB: ChannelUpdated('closed')\nWalletB--\x3e>ClientB: MessageQueued(isFinalB)\nClientB->>ClientA: isFinalB\nClientA->>WalletA: pushMessage(isFinalB)\nWalletA--\x3e>ClientA: ChannelUpdated('closed')\nWalletA->>Chain: concludePushOutcomeAndTransferAll()\ndeactivate WalletA\ndeactivate WalletB\nChain--\x3e>WalletA: AssetTransferred x2\nChain--\x3e>WalletB: AssetTransferred x2\nend\n",mdxType:"Mermaid"}))}r.isMDXComponent=!0},425:function(e,n,t){"use strict";var l=t(0),a=t.n(l),i=t(438),s=t.n(i);s.a.initialize({startOnLoad:!0});n.a=function(e){var n=e.chart;return Object(l.useEffect)((function(){s.a.contentLoaded()}),[]),a.a.createElement("div",{className:"mermaid",align:"center"},n)}},441:function(e,n,t){var l={"./locale":424,"./locale.js":424};function a(e){var n=i(e);return t(n)}function i(e){if(!t.o(l,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return l[e]}a.keys=function(){return Object.keys(l)},a.resolve=i,e.exports=a,a.id=441}}]);