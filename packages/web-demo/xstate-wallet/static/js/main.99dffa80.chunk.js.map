{"version":3,"sources":["../../client-api-schema/lib/src/index.js","../../nitro-protocol/lib/src/contract/channel.js","../../nitro-protocol/lib/src/signatures.js","../../wallet-core/lib/src/config.js","../../wire-format/lib/src/index.js","../../wallet-core/lib/src/state-utils.js","../../wallet-core/lib/src/utils/helpers.js","../../wallet-core/lib/src/types.js","../../nitro-protocol/lib/src/contract/channel-storage.js","../../nitro-protocol/lib/src/contract/challenge.js","../../nitro-protocol/lib/src/contract/transaction-creators/asset-holder.js","../../client-api-schema/lib/src/types.js","../../client-api-schema/lib/src/jsonrpc-header-types.js","../../client-api-schema/lib/src/validation.js","../../nitro-protocol/lib/test/test-helpers.js","../../nitro-protocol/lib/src/contract/asset-holder.js","../../nitro-protocol/lib/src/ethers-utils.js","../../nitro-protocol/lib/src/contract/force-move-app.js","../../nitro-protocol/lib/src/contract/transaction-creators/erc20-asset-holder.js","../../nitro-protocol/lib/src/contract/transaction-creators/eth-asset-holder.js","../../nitro-protocol/lib/src/transactions.js","../../nitro-protocol/lib/src/contract/transaction-creators/force-move.js","../../nitro-protocol/lib/src/contract/transaction-creators/nitro-adjudicator.js","../../wallet-core/lib/src/utils/outcome.js","../../wallet-core/lib/src/utils/budget-utils.js","../../wallet-core/lib/src/utils/contract-utils.js","../../wallet-core/lib/src/constants.js","../../wallet-core/lib/src/utils/messages.js","../../wallet-core/lib/src/serde/app-messages/deserialize.js","../../wallet-core/lib/src/serde/app-messages/serialize.js","../../wallet-core/lib/src/serde/wire-format/deserialize.js","../../wire-format/lib/src/types.js","../../wire-format/lib/src/validator.js","../../wallet-core/lib/src/serde/wire-format/serialize.js","utils/helpers.ts","config.ts","utils/contract-utils.ts","logger.ts","chain.ts","constants.ts","store/index.ts","store/memory-backend.ts","store/store.ts","store/channel-store-entry.ts","store/dexie-backend.ts","messaging.ts","workflows/support-state.ts","utils/workflow-utils.ts","workflows/conclude-channel.ts","workflows/depositing.ts","workflows/direct-funding.ts","workflows/ledger-funding.ts","workflows/virtual-funding-as-leaf.ts","workflows/virtual-funding-as-hub.ts","workflows/create-and-fund.ts","workflows/virtual-defunding-as-leaf.ts","workflows/create-and-fund-ledger.ts","workflows/virtual-defunding-as-hub.ts","workflows/challenge-channel.ts","workflows/approve-budget-and-fund.ts","workflows/close-ledger-and-withdraw.ts","workflows/application.ts","workflows/confirm.ts","workflows/ethereum-enable.ts","ui/window-context.tsx","ui/channel-id.tsx","ui/selectors.ts","ui/challenge-channel-workflow.tsx","segment-analytics.ts","ui/confirm-create-channel-workflow.tsx","ui/application-workflow.tsx","ui/enable-ethereum-workflow.tsx","ui/theme.ts","images/logo.svg","ui/layout.tsx","ui/approve-budget-and-fund-workflow.tsx","ui/close-ledger-and-withdraw.tsx","ui/wallet.tsx","channel-wallet.ts","ui/app.tsx","ui/factory-reset.tsx","index.ts","../../wallet-core/lib/src/index.js","../../nitro-protocol/lib/src/index.js","../../nitro-protocol/lib/src/contract/outcome.js","../../wallet-core/lib/src/bignumber.js","../../nitro-protocol/lib/src/contract/state.js","../../wallet-core/lib/src/utils/index.js"],"names":["__export","m","p","exports","hasOwnProperty","Object","defineProperty","value","validation_1","parseRequest","parseResponse","parseNotification","parseErrorResponse","ethers_1","getChannelId","channel","chainId","participants","channelNonce","utils","keccak256","defaultAbiCoder","encode","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","adopt","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","challenge_1","channel_1","state_1","sign","wallet","msgHash","_a","_b","_c","splitSignature","signMessage","arrayify","signData","hashedData","privateKey","signingKey","SigningKey","signDigest","hashMessage","getStateSignerAddress","signedState","stateHash","hashState","state","recoveredAddress","verifyMessage","signature","indexOf","Error","signState","Wallet","address","signStates","states","wallets","whoSignedWhat","stateHashes","promises","_this","map","s","w","i","all","signChallengeMessage","signedStates","challengeState","hashChallengeMessage","constants_1","getBool","val","undefined","GIT_VERSION","NODE_ENV","CHAIN_NETWORK_ID","INFURA_API_KEY","CLEAR_STORAGE_ON_START","ETH_ASSET_HOLDER_ADDRESS","AddressZero","HUB_PARTICIPANT_ID","HUB_ADDRESS","HUB_DESTINATION","LOG_DESTINATION","concat","NITRO_ADJUDICATOR_ADDRESS","TRIVIAL_APP_ADDRESS","USE_INDEXED_DB","CHALLENGE_DURATION","Number","JEST_WORKER_ID","ADD_LOGS","LOG_LEVEL","HUB","destination","signingAddress","participantId","TARGET_NETWORK","FAUCET_LINK","validator_1","validateMessage","validateState","_slicedToArray","nitro_protocol_1","bytes_1","bignumber_1","toNitroState","x","assign","pick","outcome","convertToNitroOutcome","nitroState","simpleAllocationsEqual","left","right","assetHolderAddress","allocationItems","every","index","BN","eq","amount","type","a","convertAddressToBytes32","guarantee","targetChannelId","destinations","console","warn","simpleAllocations","fromNitroOutcome","singleOutcomeItem","from","substr","convertBytes32ToAddress","fromNitroState","appData","isFinal","challengeDuration","appDefinition","turnNum","padStart","toNitroSignedState","signatures","sig","calculateChannelId","channelConstants","addresses","createSignatureEntry","joinSignature","signer","getSignerAddress","statesEqual","outcomesEqual","isEqual","firstState","_ref","nextState","unreachable","exists","checkThat","isTypeT","throwError","fn","name","createDestination","hexZeroPad","formatAmount","arrayToRecord","array","idProperty","reduce","obj","item","recordToArray","record","keys","k","filter","isAllocation","guard","o","isOpenChannel","isVirtuallyFund","isFundGuarantor","isFundLedger","isCloseLedger","isIndirectFunding","funding","isVirtualFunding","isGuarantee","isGuarantees","outcome_1","channelDataToChannelStorageHash","channelData","turnNumRecord","finalizesAt","hash","encodeChannelData","fingerprint","hexDataSlice","hexlify","slice","parseChannelStorageHash","channelStorageHash","validateHexString","hexString","isHexString","cursor","asNumber","BigNumber","toNumber","channelDataStruct","challengerAddress","isOpen","JSON","stringify","constants","HashZero","outcomeHash","hashOutcome","data","channelDataLiteStruct","encodeChannelStorageLite","channelDataLite","__importDefault","mod","__esModule","Interface","NitroAdjudicator_json_1","getChallengeRegisteredEvent","eventResult","args","challenger","fixedPart","variablePartsUnstructured","variableParts","sigs","toHexString","challengeStates","decodeOutcome","getChallengeClearedEvent","tx","newTurnNumRecord","decodedTransaction","default","abi","parseTransaction","kind","newStates","r","_vs","recoveryParam","claimAllArgs","channelId","allocation","encodeGuarantee","encodeAllocation","createTransferAllTransaction","assetHolderContractInterface","encodeFunctionData","createClaimAllTransaction","createSetOutcomeTransaction","isStateChannelsResponse","message","isStateChannelsNotification","isStateChannelsRequest","isStateChannelsErrorResponse","isJsonRpc","isJsonRpcRequest","isJsonRpcNotification","isJsonRpcResponse","isJsonRpcErrorResponse","ajv","jsonPointers","verbose","apiSchema","prettyPrintError","keyword","unexpected","params","additionalProperty","dataPath","missing","missingProperty","addSchema","validateRequest","compile","$ref","validateResponse","validateErrorResponse","validateNotification","jsonBlob","errors","join","__assign","arguments","prototype","fs_1","channel_storage_1","allocationToParams","hashAssetOutcome","getTestProvider","GANACHE_PORT","ethers","providers","JsonRpcProvider","setupContracts","provider","artifact","getSigner","Contract","getPlaceHolderContractAddress","COUNTING_APP_ADDRESS","nonParticipant","createRandom","clearedChallengeHash","ongoingChallengeHash","finalizedOutcomeHash","newChallengeRegisteredEvent","contract","filters","ChallengeRegistered","on","eventChannelIdArg","eventTurnNumRecordArg","eventFinalizesAtArg","eventChallengerArg","eventIsFinalArg","eventFixedPartArg","eventChallengeVariablePartArg","event","removeAllListeners","newChallengeClearedEvent","ChallengeCleared","eventChannelId","eventTurnNumRecord","newConcludedEvent","Concluded","newDepositedEvent","Deposited","eventDestination","amountDeposited","amountHeld","newTransferEvent","to","Transfer","eventFrom","eventTo","amountTransferred","newAssetTransferredEvent","payout","toLowerCase","randomChannelId","randomExternalDestination","sendTransaction","contractAddress","transaction","wait","guaranteeToParams","replaceAddressesAndBigNumberify","object","newObject","forEach","key","resetMultipleHoldings","multipleHoldings","contractsArray","assetHolder","holdings","setHoldings","expect","toBe","checkMultipleHoldings","checkMultipleAssetOutcomeHashes","assetOutcome","allocationAfter","expectedNewAssetOutcomeHash","assetOutcomeHashes","toEqual","computeOutcome","outcomeShortHand","assetTransferredEventsFromPayouts","singleAssetPayouts","assetTransferredEvents","gt","compileEventsFromLogs","logs","events","log","interface","parseLog","writeGasConsumption","filename","description","gas","appendFile","toString","err","ethers_utils_1","getDepositedEvent","parseEventResult","destinationHoldings","getAssetTransferredEvent","bytes32","normalized","getAddress","normalizedAddress","ForceMoveApp_json_1","ForceMoveAppContractInterface","validTransition","fromState","toState","appContract","numberOfParticipants","fromVariablePart","toVariablePart","turnNumB","getVariablePart","createValidTransitionTransaction","__importStar","ERC20AssetHolder_json_1","assetHolderTransactionCreator","Erc20AssetHolderContractInterface","createDepositTransaction","expectedHeld","functions","deposit","ETHAssetHolder_json_1","EthAssetHolderContractInterface","forceMoveTrans","nitroAdjudicatorTrans","signatures_1","createSignatureArguments","Array","uniqueSignedStates","uniqueStates","_loop_1","_i","signedStatesForUniqueState_1","ss","participantIndex","getChannelStorage","ForceMoveContractInterface","createForceMoveTransaction","challengePrivateKey","createRespondTransaction","response","responseState","responseSignature","createCheckpointTransaction","createConcludePushOutcomeAndTransferAllTransaction","createConcludeTransaction","conclusionProof","ForceMove_json_1","respondArgs","getFixedPart","checkpointArgs","largestTurnNum","Math","max","concludeArgs","lastState","s1","s2","hashAppPart","challengerPrivateKey","isFinalCount","challengerSignature","NitroAdjudicatorContractInterface","concludePushOutcomeAndTransferAllArgs","encodeOutcome","createPushOutcomeTransaction","encodedOutcome","Errors","config_1","helpers_1","isSimpleEthAllocation","makeDestination","addressOrDestination","isSimpleAllocation","assertSimpleEthAllocation","simpleEthAllocation","simpleEthGuarantee","_len","_key","simpleTokenAllocation","allocateToTarget","currentOutcome","deductions","InvalidOutcomeType","cloneDeep","total","Zero","currentItems","targetItem","ledgerItem","find","DestinationMissing","add","sub","lt","InsufficientFunds","_defineProperty","ethBudget","domain","opts","hubAddress","forAsset","availableReceiveCapacity","availableSendCapacity","channels","forEthAsset","budget","ethPart","extractEthAssetBudget","tokenAddress","isZero","MOCK_TOKEN","MOCK_ASSET_HOLDER_ADDRESS","ETH_TOKEN","CONCLUDE_TIMEOUT","_1","convertToParticipant","participant","utils_1","deserializeAllocation","token","deserializeAllocationItem","allocationItem","deserializeBudgetRequest","budgetRequest","assetBudget","requestedSendCapacity","requestedReceiveCapacity","hub","deserializeDomainBudget","DomainBudget","budgets","b","deserializeAllocations","allocations","types_1","serializeAllocation","serializeSimpleAllocation","serializeAllocationItem","serializeDomainBudget","serializeChannelEntry","channelEntry","_channelEntry$latest","latest","_channelEntry$channel","status","hasConclusionProof","isSupported","supported","wire_format_1","state_utils_1","convertToInternalParticipant","deserializeState","stateWithoutChannelId","deserializedState","deserializeOutcome","deserializeObjective","objective","isAllocations","deserializeMessage","_d","_e","_f","objectives","Ajv","messageIsValid","errorMessages","stateIsValid","serializeState","serializeOutcome","serializeMessage","recipient","sender","getDataAndInvoke","service","onDone","initial","src","invoke","onError","id","entry","process","getProvider","window","ethereum","mockingInfuraProvider","InfuraProvider","Web3Provider","oldNetwork","location","reload","IS_BROWSER_CONTEXT","LOG_TO_CONSOLE","LOG_TO_FILE","pino","postMessageAndCallConsoleFn","consoleFn","withName","parent","postMessage","logEvent","parse","msg","omit","prettyPrint","translateTime","browser","write","error","info","debug","trace","level","localStorage","logger","lvl","prevLvl","prevVal","addEventListener","setItem","removeItem","FakeChain","blockNumber","channelStatus","eventEmitter","EventEmitter","fakeSelectedAddress","channelStorage","finalized","emit","depositSync","support","challengeExpiry","finalizationProof","finalizeSync","blockNum","current","gte","first","getChainInfo","updates","fromEvent","pipe","merge","selectedAddress","chainLogger","child","module","GAS_PRICE","parseUnits","ChainWatcher","_adjudicator","_assetHolders","mySelectedAddress","configureContracts","ethereumIsEnabled","ContractArtifacts","EthAssetHolderArtifact","NitroAdjudicatorArtifact","numAssetHolders","getBlockNumber","enable","transactionRequest","Transactions","flatMap","convertNitroTransactionRequest","gasPrice","convertedSignedStates","previous","sort","transactionHash","createETHDepositTransaction","ethAssetHolder","lte","getBalance","distinctUntilChanged","polledData","interval","depositEvents","async","assetTransferEvents","nitroTransactionRequest","gasLimit","nonce","DB_NAME","MemoryBackend","_channels","_objectives","_nonces","_destinationAddress","_privateKeys","_ledgers","_budgets","transactionOngoing","channelsData","ChannelStoreEntry","nonces","_mode","_stores","cb","abort","track","identify","Store","chain","backend","_eventEmitter","initialize","privateKeys","cleanSlate","dbName","ObjectStores","currentAddress","segmentId","pk","setPrivateKey","getDestinationAddress","setDestinationAddress","destinationAddress","initializeChannel","applicationDomain","myIndex","findIndex","notInChannel","setNonce","stateVariables","setChannel","setFunding","getEntry","channelFunded","ledgerLock","AsyncLock","getLedger","peerId","ledgers","ledgerId","noLedger","setapplicationDomain","domainExistsOnChannel","setLedger","getApplicationChannels","includeClosed","createChannel","stateVars","getNonce","signAndAddStateWithinTx","emitChannelUpdatedEventAfterTX","nonceKeyFromAddresses","updateChannel","updateData","existingState","myTurn","notMyTurn","newState","signFinalState","latestSignedByMe","signAndAddState","supportState","isSupportedByMe","getPrivateKey","myAddress","signAndAdd","addState","getChannel","memoryChannelStorage","createBudget","getBudget","budgetAlreadyExists","setBudget","clearBudget","deleteBudget","releaseFunds","ledgerChannelId","noDomainForChannel","currentBudget","noBudget","channelNotInBudget","playerAddress","playerDestination","cannotFindDestination","getAllocationAmount","reserveFunds","noAssetBudget","send","receive","budgetInsufficient","newEntries","cs","currentEntry","c","acquire","release","invalidNonce","ret","cannotFindPrivateKey","emittingDuringTransaction","addToOutbox","addObjective","channelMissing","newObjectives","currentObjectives","of","concatAll","amountNotFound","some","secondState","nParticipants","staleState","signatureEntry","signedStateVars","withHash","signerIndex","uniqWith","clearOldStates","checkInvariants","groupedByTurnNum","groupBy","_signedByMe","num","multipleSignedStates","turnNums","duplicateTurnNums","isReverseSorted","arr","len","notSorted","reverse","sortBy","firstSupportStateHash","_support","supportIndex","sv","_supported","latestSupport","previousState","participantsWhoHaveNotSigned","Set","validChain","moverIndex","moverForThisTurn","delete","size","vars","_latestSupportedByMe","mySignature","STORES","Backend","_db","indexedDB","databaseName","create","createdDB","clear","bind","Dexie","version","stores","upgrade","numberify","table","each","storeName","getAll","cd","fromJson","get","put","mode","callback","dexieMode","dump","store","toArray","keyBy","mapValues","test","currentTransaction","MessagingService","jsonrpc","notificationData","notification","method","ourAddress","objectiveRecipients","stateRecipients","displayMessage","showWallet","jsonRpcRequest","fromDomain","request","requestId","walletVersion","sendResponse","channelEntries","serializedChannelEntries","convertToInternalEvent","appRequest","pushMessage","success","closeAndWithdrawDestination","hubParticipantId","player","playerParticipantId","config","SUPPORTED","notifyWhenSupported","channelUpdatedFeed","machine","Machine","options","services","actions","spawnObserver","ctx","observer","spawn","createMockGuard","guardName","predicate","getDataAndInvoke2","autoForward","CommonActions","assignError","displayUI","messagingService","sendDisplayMessage","hideUI","sendUserDeclinedResponse","messageService","context","sendError","code","Services","commonWorkflowActions","sendUserDeclinedErrorResponse","FUNDED","idle","SAFE_TO_DEPOSIT","submit","failure","submitDepositTransaction","currentHoldings","totalAfterDeposit","assignChainWatcher","chainWatcher","subscribeDepositEvent","chainUpdatedFeed","chainInfo","fundedAt","depositAt","withConfig","target","fundingTarget","checkTarget","unSupportedTargetChannel","acquiringLock","exit","lock","checkingTarget","updatingFunding","acquireLock","acquireChannelLock","getTargetOutcome","ledgerState","currentlyAllocated","toDeduct","underfunded","underallocated","updateFunding","SupportState","escalateError","escalate","releaseLock","getFundGuarantorObjective","jointChannelId","jointParticipants","ParticipantIdx","Hub","guarantorId","waitForSupportedGuarantorState","guarantorChannelId","u","toPromise","States","setupJointChannel","ActionTypes","ErrorCustom","determineDeductions","fundJointChannel","Actions","getObjective","preparingGuarantorChannel","runObjective","fundTargetChannel","waitForFirstJointState","sortedStates","tap","amounts","OutcomeIdx","A","B","take","jointChannelUpdate","supportedStateFeed","getDeductions","latestSupportedByMe","outcomeIdx","updateJointChannelFunding","ledgerFunding","LedgerFunding","fundGuarantor","assignObjectiveData","role","guarantorState","waitThenFundGuarantor","Events","waitForObjective","supportingGuarantorState","VirtualFundingAsLeaf","fundGuarantorAH","fundGuarantorBH","preFundSetup","cond","isDirect","isVirtual","direct","depositing","triggerObjective","supportedState","targetParticipants","assignJointChannelId","sendBudgetNotification","virtual","virtualFunding","postFundSetup","Depositing","getDepositingInfo","getPreFundSetup","getPostFundSetup","setFundingToDirect","setFundingToVirtual","objectiveFeed","checkChannelsService","targetFunding","jointFunding","guarantorFunding","checkChannels","finalTargetState","closeTarget","finalJointChannelUpdate","targetChannelState","targetNotFinalized","jointState","noSupportedJointState","jointAllocation","targetOutcome","defundTarget","defundGuarantorInLedger","jAlloc","lAlloc","ledgerWithoutGuarantor","leaf","BadOutcome","invalidOutcome","defundGuarantor","ledgerUpdate","getApplicationDomain","ledgerEntry","releaseFundsFromBudget","guarantorChannelIds","Leaf","leftGuarantorFunding","leftLedgerId","rightGuarantorFunding","rightLedgerId","ledgerChannelIds","newItems","supportedItems","defundLeftGuarantor","defundRightGuarantor","waitForConclusionProof","concludeChannel","getFunding","determineFundingType","Virtual","Direct","getRole","getDirectFundingRole","virtualDefunding","gettingRole","AmHub","AmLeaf","asLeaf","asHub","observeFundsWithdrawal","submitWithdrawTransaction","finalizeAndWithdraw","withdrawing","FUNDS_WITHDRAWN","AmA","AmB","submitTransaction","transactionId","waitForWithdrawalToComplete","virtualDefundingAsLeaf","VirtualDefundingAsLeaf","noChallengeOnchain","challengeOnchainAsExpected","challengeFinalized","submitChallengeTransaction","challenge","setTransactionId","createMachine","strict","CHANNEL_UPDATED","CHAIN_EVENT","init","observeOnChainChannelStorage","waitForResponseOrTimeout","waitMining","retry","USER_APPROVES_RETRY","USER_REJECTS_RETRY","waitForUserApproval","USER_APPROVES_BUDGET","USER_REJECTS_BUDGET","createLedger","setLedgerInfo","waitForPreFS","notifyWhenPreFSSupported","assignDepositingInfo","waitForSufficientFunds","notifyWhenSufficientFunds","waitForFunds","INSUFFICIENT_FUNDS_DETECTED","SUFFICIENT_FUNDS_DETECTED","observeLedgerOnChainBalance","assignChainData","fullAmountConfirmed","myAmountConfirmed","myTurnNow","notMyTurnYet","waitTurn","waitFullyFunded","initialOutcome","convertPendingBudgetToAllocation","latestState","playerItem","hubItem","exec","calculateDepositInfo","ourAmount","hubAmount","totalAmount","depositAmount","balanceUpdatedFeed","balance","ledgerTotal","currentBlockNum","lastChangeBlockNum","fetchBudget","assignBudget","USER_APPROVES_CLOSE","USER_REJECTS_CLOSE","createObjective","assignLedgerId","closeLedger","constructFinalState","withdraw","userDeclinedFailure","budgetFailure","opponent","workflow","withContext","signFinalStateIfMyTurn","generateConfig","guards","sendChannelUpdatedNotification","joiningChannel","joining","isLedgerFunding","amCreator","JOIN_CHANNEL","assignRequestId","sendJoinChannelResponse","settingDomain","isDirectFunding","confirmingWithUser","displayUi","creatingChannel","amJoiner","assignChannelId","sendCreateChannelResponse","fundingChannel","fundingStrategy","hideUi","running","spawnObservers","SPAWN_OBSERVERS","PLAYER_STATE_UPDATE","channelClosing","channelChallenging","PLAYER_REQUEST_CONCLUDE","closeChannel","after","PLAYER_REQUEST_CHALLENGE","closing","sendChallenge","sendChallengeChannelResponse","notifyOnChannelRequest","requestFeed","notifyOnUpdate","storeEntry","entry1","entry2","updateObserver","requestObserver","sendChannelNotification","matches","reason","RegExp","invokeClosingProtocol","ConcludeChannel","invokeChallengingProtocol","ChallengeChannel","invokeCreateChannelAndFundProtocol","CreateAndFund","invokeCreateChannelConfirmation","CCC","channelOpen","isChallenging","channelClosed","mockGuards","mockOptions","waitForUserConfirmation","USER_APPROVES","USER_REJECTS","explainToUser","USER_APPROVES_ENABLE","USER_REJECTS_ENABLE","enabling","enabledAddress","settingDestinationAddress","sendErrorResponse","mockActions","WindowContext","React","createContext","ChannelId","props","Tooltip","Avatar","ml","mr","Blockie","seed","color","bgcolor","scale","spotcolor","getApplicationStateValue","applicationWorkflowState","getChallengeChannelService","children","isConfirmCreateChannel","isApplicationChallenging","getApplicationOpenProgress","stateValue","getAmountsFromBudget","pending","playerAmount","segmentFunction","action","analytics","noop","ConfirmCreateChannel","useService","_send","prompt","Flex","alignItems","flexDirection","Text","fontSize","pb","Button","onClick","ApplicationWorkflow","style","paddingTop","textAlign","className","Heading","mb","branchingOnFundingStrategy","openChannelAndFundProtocol","px","height","mt","mx","isApplicationOpening","Progress","EnableEthereum","currentState","targetNetwork","useContext","networkVersion","currentNetwork","metaMaskButton","disabled","MetaMaskButton","Outline","NoNetwork","Flash","variant","justifyContent","Box","Icon","fontWeight","as","href","WrongNetwork","RimbleUtils","getEthNetworkNameById","NotWeb3Browser","isMobileDevice","connectionBanner","requiredNetwork","notWeb3CapableBrowserMessage","noNetworkAvailableMessage","onWrongNetworkMessage","button","theme","rimbleTheme","fonts","serif","sansSerif","Layout","Modal","Card","width","borderBottom","borderColor","Image","alt","logo","ApproveBudgetAndFund","stateTimer","useState","stateTimerExpired","setStateTimerExpired","useEffect","setTimeout","clearTimeout","waitForSufficientFundsInit","formatEther","Link","Loader","depositInit","depositWaitTurn","depositSubmitTransaction","depositFullyFunded","hubTimeout","waiting","depositWaitMining","depositRetry","CloseLedgerAndWithdraw","talkingToHub","working","withdrawSubmitTransaction","withdrawWaitMining","Provider","ChannelWallet","workflows","outboxFeed","subscribe","sendMessageNotification","isWorkflowIdInUse","calculateWorkflowId","startWorkflow","Application","handleRequest","workflowId","Guid","getWorkflow","ethereumEnableWorkflow","enableEthereum","ethereumEnable","setDestinationAddressIfEmpty","machineConfig","devTools","interpret","onTransition","logTransition","start","renderUI","document","getElementById","ReactDOM","render","createElement","WalletUi","jsonRpcMessage","receiveRequest","alreadyLogging","transitionLogger","eventType","history","configuration","subId","RoutePath","FactoryReset","destroyed","setDestroyed","destroyStore","confirm","App","exact","path","Root","Sentry","dsn","channelWallet","scope","setUser","host","Url","origin","onSendMessage","jsonRpcResponse","walletReadyMessage","TrivialApp_json_1","Token_json_1","AssetHolder_json_1","TrivialAppArtifact","Erc20AssetHolderArtifact","TokenArtifact","AssetHolderArtifact","test_helpers_1","asset_holder_1","force_move_app_1","isAllocationOutcome","isGuaranteeOutcome","erc20_asset_holder_1","createERC20DepositTransaction","eth_asset_holder_1","Signatures","AssetOutcomeType","decodeGuarantee","encodedGuarantee","decode","decodeAllocation","encodedAllocation","allocationOrGuarantee","isArray","encodeAssetOutcomeFromBytes","assetOutcomeType","encodedAllocationOrGuarantee","decodeOutcomeItem","encodedAssetOutcome","outcomeType","AllocationOutcomeType","GuaranteeOutcomeType","encodeAssetOutcome","encodedData","encodedAssetOutcomes","outcomeContent","_classCallCheck","binaryOperator","isBigNumber","unaryOperator","mul","div","pow","abs","isNegative","isUint256","match","appPartHash"],"mappings":"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","file":"static/js/main.99dffa80.chunk.js","sourcesContent":["\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation Defines and validates the data types communicated between an app and a wallet\n *\n * @remarks\n * Also exposes functions that can validate messages (Requests, Responses, Notifications and Error Responses), as well as to cast them as the correct Type.\n *\n * Example request:\n * ```json\n * {\n *   \"jsonrpc\": \"2.0\",\n *   \"method\": \"PushMessage\",\n *   \"id\": 1,\n *   \"params\": {\n *     \"recipient\": \"user123\",\n *     \"sender\": \"user456\",\n *     \"data\": \"0x123..\"\n *   }\n * }\n * ```\n *\n * Example response:\n *\n * ```json\n * {\n *   \"jsonrpc\": \"2.0\",\n *   \"id\": 1,\n *   \"result\": {\"success\": true}\n * }\n * ```\n */\n\n__export(require(\"./types\"));\n\n__export(require(\"./jsonrpc-header-types\"));\n\nvar validation_1 = require(\"./validation\");\n\nexports.parseRequest = validation_1.parseRequest;\nexports.parseResponse = validation_1.parseResponse;\nexports.parseNotification = validation_1.parseNotification;\nexports.parseErrorResponse = validation_1.parseErrorResponse;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nfunction getChannelId(channel) {\n  var chainId = channel.chainId,\n      participants = channel.participants,\n      channelNonce = channel.channelNonce;\n  return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode(['uint256', 'address[]', 'uint256'], [chainId, participants, channelNonce]));\n}\n\nexports.getChannelId = getChannelId;","\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar challenge_1 = require(\"./contract/challenge\");\n\nvar channel_1 = require(\"./contract/channel\");\n\nvar state_1 = require(\"./contract/state\");\n\nfunction getStateSignerAddress(signedState) {\n  var stateHash = state_1.hashState(signedState.state);\n  var recoveredAddress = ethers_1.utils.verifyMessage(ethers_1.utils.arrayify(stateHash), signedState.signature);\n  var channel = signedState.state.channel;\n  var participants = channel.participants;\n\n  if (participants.indexOf(recoveredAddress) < 0) {\n    throw new Error(\"Recovered address \" + recoveredAddress + \" is not a participant in channel \" + channel_1.getChannelId(channel));\n  }\n\n  return recoveredAddress;\n}\n\nexports.getStateSignerAddress = getStateSignerAddress;\n\nfunction signState(state, privateKey) {\n  var wallet = new ethers_1.Wallet(privateKey);\n\n  if (state.channel.participants.indexOf(wallet.address) < 0) {\n    throw new Error(\"The state must be signed with a participant's private key\");\n  }\n\n  var hashedState = state_1.hashState(state);\n  var signature = signData(hashedState, privateKey);\n  return {\n    state: state,\n    signature: signature\n  };\n}\n\nexports.signState = signState;\n\nfunction sign(wallet, msgHash) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _b = (_a = ethers_1.utils).splitSignature;\n          return [4, wallet.signMessage(ethers_1.utils.arrayify(msgHash))];\n\n        case 1:\n          return [2, _b.apply(_a, [_c.sent()])];\n      }\n    });\n  });\n}\n\nexports.sign = sign;\n\nfunction signStates(states, wallets, whoSignedWhat) {\n  return __awaiter(this, void 0, void 0, function () {\n    var stateHashes, promises;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      stateHashes = states.map(function (s) {\n        return state_1.hashState(s);\n      });\n      promises = wallets.map(function (w, i) {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4, sign(w, stateHashes[whoSignedWhat[i]])];\n\n              case 1:\n                return [2, _a.sent()];\n            }\n          });\n        });\n      });\n      return [2, Promise.all(promises)];\n    });\n  });\n}\n\nexports.signStates = signStates;\n\nfunction signChallengeMessage(signedStates, privateKey) {\n  if (signedStates.length === 0) {\n    throw new Error('At least one signed state must be provided');\n  }\n\n  var wallet = new ethers_1.Wallet(privateKey);\n\n  if (signedStates[0].state.channel.participants.indexOf(wallet.address) < 0) {\n    throw new Error(\"The state must be signed with a participant's private key\");\n  }\n\n  var challengeState = signedStates[signedStates.length - 1].state;\n  var challengeHash = challenge_1.hashChallengeMessage(challengeState);\n  return signData(challengeHash, privateKey);\n}\n\nexports.signChallengeMessage = signChallengeMessage;\n\nfunction hashMessage(hashedData) {\n  return ethers_1.utils.hashMessage(ethers_1.utils.arrayify(hashedData));\n}\n\nfunction signData(hashedData, privateKey) {\n  var signingKey = new ethers_1.utils.SigningKey(privateKey);\n  return ethers_1.utils.splitSignature(signingKey.signDigest(hashMessage(hashedData)));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nfunction getBool(val) {\n  switch (val) {\n    case undefined:\n    case null:\n    case 'null':\n    case 'false':\n    case 'FALSE':\n    case '0':\n      return false;\n\n    default:\n      return true;\n  }\n}\n\nexports.GIT_VERSION = process.env.GIT_VERSION;\nexports.NODE_ENV = process.env.NODE_ENV;\nexports.CHAIN_NETWORK_ID = process.env.CHAIN_NETWORK_ID || '0';\nexports.INFURA_API_KEY = process.env.INFURA_API_KEY;\nexports.CLEAR_STORAGE_ON_START = getBool(process.env.CLEAR_STORAGE_ON_START);\nexports.ETH_ASSET_HOLDER_ADDRESS = process.env.ETH_ASSET_HOLDER_ADDRESS || constants_1.AddressZero;\nexports.HUB_PARTICIPANT_ID = 'firebase:simple-hub';\nexports.HUB_ADDRESS = process.env.HUB_ADDRESS || '0xaaaa84838319627Fa056fC3FC29ab94d479B8502';\nexports.HUB_DESTINATION = process.env.HUB_DESTINATION;\nexports.LOG_DESTINATION = process.env.LOG_DESTINATION ? process.env.LOG_DESTINATION === 'console' ? 'console' : \"\".concat(process.env.LOG_DESTINATION, \"/wallet.log\") : undefined;\nexports.NITRO_ADJUDICATOR_ADDRESS = process.env.NITRO_ADJUDICATOR_ADDRESS || constants_1.AddressZero;\nexports.TRIVIAL_APP_ADDRESS = process.env.TRIVIAL_APP_ADDRESS || constants_1.AddressZero;\nexports.USE_INDEXED_DB = getBool(process.env.USE_INDEXED_DB);\nexports.CHALLENGE_DURATION = Number(process.env.CHALLENGE_DURATION || 300);\nexports.JEST_WORKER_ID = process.env.JEST_WORKER_ID;\nexports.ADD_LOGS = !!exports.LOG_DESTINATION;\nexports.LOG_LEVEL = exports.ADD_LOGS ? process.env.LOG_LEVEL ? process.env.LOG_LEVEL : 'info' : 'silent';\nexports.HUB = {\n  destination: exports.HUB_DESTINATION,\n  signingAddress: exports.HUB_ADDRESS,\n  participantId: 'firebase:simple-hub'\n};\nexports.TARGET_NETWORK = process.env.TARGET_NETWORK || 'development';\nexports.FAUCET_LINK = exports.TARGET_NETWORK === 'goerli' ? 'https://goerli-faucet.slock.it/' : 'https://faucet.ropsten.be/';","\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(require(\"./types\"));\n\nvar validator_1 = require(\"./validator\");\n\nexports.validateMessage = validator_1.validateMessage;\nexports.validateState = validator_1.validateState;","\"use strict\";\n\nvar _slicedToArray = require(\"/home/caleb/hypernet-protocol/subtrees/statechannels/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar nitro_protocol_1 = require(\"@statechannels/nitro-protocol\");\n\nvar bytes_1 = require(\"@ethersproject/bytes\");\n\nvar _ = require(\"lodash\");\n\nvar ethers_1 = require(\"ethers\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nfunction toNitroState(state) {\n  var channelNonce = state.channelNonce,\n      participants = state.participants,\n      chainId = state.chainId;\n  var channel = {\n    channelNonce: channelNonce,\n    chainId: chainId,\n    participants: participants.map(function (x) {\n      return x.signingAddress;\n    })\n  };\n  return Object.assign(Object.assign({}, _.pick(state, 'appData', 'isFinal', 'challengeDuration', 'appDefinition', 'turnNum')), {\n    outcome: convertToNitroOutcome(state.outcome),\n    channel: channel\n  });\n}\n\nexports.toNitroState = toNitroState;\n\nfunction fromNitroState(state) {\n  var appData = state.appData,\n      isFinal = state.isFinal,\n      outcome = state.outcome,\n      challengeDuration = state.challengeDuration,\n      appDefinition = state.appDefinition,\n      channel = state.channel,\n      turnNum = state.turnNum;\n  return {\n    appDefinition: appDefinition,\n    isFinal: isFinal,\n    appData: appData,\n    outcome: fromNitroOutcome(outcome),\n    turnNum: turnNum,\n    challengeDuration: challengeDuration,\n    channelNonce: Number(channel.channelNonce),\n    chainId: channel.chainId,\n    participants: channel.participants.map(function (x) {\n      return {\n        signingAddress: x,\n        participantId: x,\n        destination: x.padStart(64, '0')\n      };\n    })\n  };\n}\n\nexports.fromNitroState = fromNitroState;\n\nfunction toNitroSignedState(signedState) {\n  var state = toNitroState(signedState);\n  var signatures = signedState.signatures;\n  return signatures.map(function (sig) {\n    return {\n      state: state,\n      signature: bytes_1.splitSignature(sig.signature)\n    };\n  });\n}\n\nexports.toNitroSignedState = toNitroSignedState;\n\nfunction calculateChannelId(channelConstants) {\n  var chainId = channelConstants.chainId,\n      channelNonce = channelConstants.channelNonce,\n      participants = channelConstants.participants;\n  var addresses = participants.map(function (p) {\n    return p.signingAddress;\n  });\n  return nitro_protocol_1.getChannelId({\n    chainId: chainId,\n    channelNonce: channelNonce,\n    participants: addresses\n  });\n}\n\nexports.calculateChannelId = calculateChannelId;\n\nfunction createSignatureEntry(state, privateKey) {\n  var _ethers_1$Wallet = new ethers_1.Wallet(privateKey),\n      address = _ethers_1$Wallet.address;\n\n  var nitroState = toNitroState(state);\n\n  var _nitro_protocol_1$sig = nitro_protocol_1.signState(nitroState, privateKey),\n      signature = _nitro_protocol_1$sig.signature;\n\n  return {\n    signature: bytes_1.joinSignature(signature),\n    signer: address\n  };\n}\n\nexports.createSignatureEntry = createSignatureEntry;\n\nfunction signState(state, privateKey) {\n  var nitroState = toNitroState(state);\n\n  var _nitro_protocol_1$sig2 = nitro_protocol_1.signState(nitroState, privateKey),\n      signature = _nitro_protocol_1$sig2.signature;\n\n  return bytes_1.joinSignature(signature);\n}\n\nexports.signState = signState;\n\nfunction hashState(state) {\n  var nitroState = toNitroState(state);\n  return nitro_protocol_1.hashState(nitroState);\n}\n\nexports.hashState = hashState;\n\nfunction getSignerAddress(state, signature) {\n  var nitroState = toNitroState(state);\n  return nitro_protocol_1.getStateSignerAddress({\n    state: nitroState,\n    signature: bytes_1.splitSignature(signature)\n  });\n}\n\nexports.getSignerAddress = getSignerAddress;\n\nfunction statesEqual(left, right) {\n  return hashState(left) === hashState(right);\n}\n\nexports.statesEqual = statesEqual;\n\nfunction simpleAllocationsEqual(left, right) {\n  return left.assetHolderAddress === right.assetHolderAddress && left.allocationItems.length === right.allocationItems.length && _.every(left.allocationItems, function (value, index) {\n    return value.destination === right.allocationItems[index].destination && bignumber_1.BN.eq(value.amount, right.allocationItems[index].amount);\n  });\n}\n\nfunction outcomesEqual(left, right) {\n  var _a, _b, _c;\n\n  if (left.type === 'SimpleAllocation' && ((_a = right) === null || _a === void 0 ? void 0 : _a.type) === 'SimpleAllocation') {\n    return simpleAllocationsEqual(left, right);\n  }\n\n  if (left.type === 'SimpleGuarantee' && ((_b = right) === null || _b === void 0 ? void 0 : _b.type) === 'SimpleGuarantee') {\n    return _.isEqual(left, right);\n  }\n\n  if (left.type === 'MixedAllocation' && ((_c = right) === null || _c === void 0 ? void 0 : _c.type) === 'MixedAllocation') {\n    return left.simpleAllocations.length === right.simpleAllocations.length && _.every(left.simpleAllocations, function (_, index) {\n      return simpleAllocationsEqual(left.simpleAllocations[index], right.simpleAllocations[index]);\n    });\n  }\n\n  return false;\n}\n\nexports.outcomesEqual = outcomesEqual;\n\nexports.firstState = function (outcome, _ref, appData) {\n  var channelNonce = _ref.channelNonce,\n      chainId = _ref.chainId,\n      challengeDuration = _ref.challengeDuration,\n      appDefinition = _ref.appDefinition,\n      participants = _ref.participants;\n  return {\n    appData: appData || '0x',\n    isFinal: false,\n    turnNum: 0,\n    chainId: chainId || '0x01',\n    channelNonce: channelNonce,\n    challengeDuration: challengeDuration,\n    appDefinition: appDefinition,\n    participants: participants,\n    outcome: outcome\n  };\n};\n\nfunction convertToNitroAllocationItems(allocationItems) {\n  return allocationItems.map(function (a) {\n    return {\n      amount: a.amount,\n      destination: a.destination.length === 42 ? nitro_protocol_1.convertAddressToBytes32(a.destination) : a.destination\n    };\n  });\n}\n\nfunction convertFromNitroAllocationItems(allocationItems) {\n  return allocationItems.map(function (a) {\n    return {\n      amount: bignumber_1.BN.from(a.amount),\n      destination: a.destination.substr(2, 22) === '00000000000000000000' ? nitro_protocol_1.convertBytes32ToAddress(a.destination) : a.destination\n    };\n  });\n}\n\nfunction convertToNitroOutcome(outcome) {\n  switch (outcome.type) {\n    case 'SimpleAllocation':\n      return [{\n        assetHolderAddress: outcome.assetHolderAddress,\n        allocationItems: convertToNitroAllocationItems(outcome.allocationItems)\n      }];\n\n    case 'SimpleGuarantee':\n      return [{\n        assetHolderAddress: outcome.assetHolderAddress,\n        guarantee: {\n          targetChannelId: outcome.targetChannelId,\n          destinations: outcome.destinations\n        }\n      }];\n\n    case 'MixedAllocation':\n      console.warn('NOTE: MixedAllocation is using 0th-indexed allocation only');\n      return outcome.simpleAllocations.map(convertToNitroOutcome)[0];\n  }\n}\n\nexports.convertToNitroOutcome = convertToNitroOutcome;\n\nfunction fromNitroOutcome(outcome) {\n  var _outcome = _slicedToArray(outcome, 1),\n      singleOutcomeItem = _outcome[0];\n\n  if (typeof singleOutcomeItem['allocationItems'] !== 'undefined') {\n    return {\n      type: 'SimpleAllocation',\n      assetHolderAddress: singleOutcomeItem.assetHolderAddress,\n      allocationItems: convertFromNitroAllocationItems(singleOutcomeItem['allocationItems'])\n    };\n  }\n\n  if (typeof singleOutcomeItem['guarantee'] !== 'undefined') {\n    return {\n      type: 'SimpleGuarantee',\n      assetHolderAddress: singleOutcomeItem.assetHolderAddress,\n      targetChannelId: singleOutcomeItem['guarantee'].targetChannelId,\n      destinations: singleOutcomeItem['guarantee'].destinations\n    };\n  }\n\n  return {\n    type: 'MixedAllocation',\n    simpleAllocations: []\n  };\n}\n\nexports.fromNitroOutcome = fromNitroOutcome;\n\nfunction nextState(state, outcome) {\n  if (state.outcome.type !== outcome.type) {\n    throw new Error('Attempting to change outcome type');\n  }\n\n  return Object.assign(Object.assign({}, state), {\n    turnNum: state.turnNum + 1,\n    outcome: outcome\n  });\n}\n\nexports.nextState = nextState;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bytes_1 = require(\"@ethersproject/bytes\");\n\nvar bignumber_1 = require(\"../bignumber\");\n\nfunction unreachable(x) {\n  return x;\n}\n\nexports.unreachable = unreachable;\n\nexports.exists = function (t) {\n  return !!t;\n};\n\nvar throwError = function throwError(fn, t) {\n  throw new Error(\"not valid, \".concat(fn.name, \" failed on \").concat(t));\n};\n\nfunction checkThat(t, isTypeT) {\n  if (!isTypeT(t)) {\n    throwError(isTypeT, t);\n    throw 'Unreachable';\n  }\n\n  return t;\n}\n\nexports.checkThat = checkThat;\n\nfunction createDestination(address) {\n  return bytes_1.hexZeroPad(address, 32);\n}\n\nexports.createDestination = createDestination;\n\nfunction formatAmount(amount) {\n  return bytes_1.hexZeroPad(bignumber_1.BN.from(amount), 32);\n}\n\nexports.formatAmount = formatAmount;\n\nfunction arrayToRecord(array, idProperty) {\n  return array.reduce(function (obj, item) {\n    obj[item[idProperty]] = item;\n    return obj;\n  }, {});\n}\n\nexports.arrayToRecord = arrayToRecord;\n\nfunction recordToArray(record) {\n  return Object.keys(record).map(function (k) {\n    return record[k];\n  }).filter(function (e) {\n    return e !== undefined;\n  });\n}\n\nexports.recordToArray = recordToArray;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isAllocation(outcome) {\n  return outcome.type !== 'SimpleGuarantee';\n}\n\nexports.isAllocation = isAllocation;\n\nvar guard = function guard(name) {\n  return function (o) {\n    return o.type === name;\n  };\n};\n\nexports.isOpenChannel = guard('OpenChannel');\nexports.isVirtuallyFund = guard('VirtuallyFund');\nexports.isFundGuarantor = guard('FundGuarantor');\nexports.isFundLedger = guard('FundLedger');\nexports.isCloseLedger = guard('CloseLedger');\n\nfunction isIndirectFunding(funding) {\n  var _a;\n\n  return ((_a = funding) === null || _a === void 0 ? void 0 : _a.type) === 'Indirect';\n}\n\nexports.isIndirectFunding = isIndirectFunding;\n\nfunction isVirtualFunding(funding) {\n  var _a;\n\n  return ((_a = funding) === null || _a === void 0 ? void 0 : _a.type) === 'Virtual';\n}\n\nexports.isVirtualFunding = isVirtualFunding;\n\nfunction isGuarantee(funding) {\n  var _a;\n\n  return ((_a = funding) === null || _a === void 0 ? void 0 : _a.type) === 'Guarantee';\n}\n\nexports.isGuarantee = isGuarantee;\n\nfunction isGuarantees(funding) {\n  var _a;\n\n  return ((_a = funding) === null || _a === void 0 ? void 0 : _a.type) === 'Guarantees';\n}\n\nexports.isGuarantees = isGuarantees;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar outcome_1 = require(\"./outcome\");\n\nvar state_1 = require(\"./state\");\n\nvar CHANNEL_DATA_TYPE = \"tuple(\\n  uint256 turnNumRecord,\\n  uint256 finalizesAt,\\n  bytes32 stateHash,\\n  address challengerAddress,\\n  bytes32 outcomeHash\\n)\";\nvar CHANNEL_DATA_LITE_TYPE = \"tuple(\\n  uint256 finalizesAt,\\n  bytes32 stateHash,\\n  address challengerAddress,\\n  bytes32 outcomeHash\\n)\";\n\nfunction channelDataToChannelStorageHash(channelData) {\n  var turnNumRecord = channelData.turnNumRecord,\n      finalizesAt = channelData.finalizesAt;\n  var hash = ethers_1.utils.keccak256(encodeChannelData(channelData));\n  var fingerprint = ethers_1.utils.hexDataSlice(hash, 12);\n  var storage = '0x' + ethers_1.utils.hexZeroPad(ethers_1.utils.hexlify(turnNumRecord), 6).slice(2) + ethers_1.utils.hexZeroPad(ethers_1.utils.hexlify(finalizesAt), 6).slice(2) + fingerprint.slice(2);\n  return storage;\n}\n\nexports.channelDataToChannelStorageHash = channelDataToChannelStorageHash;\n\nfunction parseChannelStorageHash(channelStorageHash) {\n  validateHexString(channelStorageHash);\n  var cursor = 2;\n  var turnNumRecord = '0x' + channelStorageHash.slice(cursor, cursor += 12);\n  var finalizesAt = '0x' + channelStorageHash.slice(cursor, cursor += 12);\n  var fingerprint = '0x' + channelStorageHash.slice(cursor);\n  return {\n    turnNumRecord: asNumber(turnNumRecord),\n    finalizesAt: asNumber(finalizesAt),\n    fingerprint: fingerprint\n  };\n}\n\nexports.parseChannelStorageHash = parseChannelStorageHash;\n\nvar asNumber = function asNumber(s) {\n  return ethers_1.BigNumber.from(s).toNumber();\n};\n\nfunction channelDataStruct(_a) {\n  var finalizesAt = _a.finalizesAt,\n      state = _a.state,\n      challengerAddress = _a.challengerAddress,\n      turnNumRecord = _a.turnNumRecord,\n      outcome = _a.outcome;\n  var isOpen = finalizesAt === 0;\n\n  if (isOpen && (outcome || state || challengerAddress)) {\n    console.warn(\"Invalid open channel storage: \" + JSON.stringify(outcome || state || challengerAddress));\n  }\n\n  var stateHash = isOpen || !state ? ethers_1.constants.HashZero : state_1.hashState(state);\n  var outcomeHash = isOpen || !outcome ? ethers_1.constants.HashZero : outcome_1.hashOutcome(outcome);\n  challengerAddress = challengerAddress || ethers_1.constants.AddressZero;\n  return {\n    turnNumRecord: turnNumRecord,\n    finalizesAt: finalizesAt,\n    stateHash: stateHash,\n    challengerAddress: challengerAddress,\n    outcomeHash: outcomeHash\n  };\n}\n\nexports.channelDataStruct = channelDataStruct;\n\nfunction encodeChannelData(data) {\n  return ethers_1.utils.defaultAbiCoder.encode([CHANNEL_DATA_TYPE], [channelDataStruct(data)]);\n}\n\nexports.encodeChannelData = encodeChannelData;\n\nfunction channelDataLiteStruct(_a) {\n  var finalizesAt = _a.finalizesAt,\n      challengerAddress = _a.challengerAddress,\n      state = _a.state,\n      outcome = _a.outcome;\n  return {\n    finalizesAt: finalizesAt,\n    challengerAddress: challengerAddress,\n    stateHash: state ? state_1.hashState(state) : ethers_1.constants.HashZero,\n    outcomeHash: outcome ? outcome_1.hashOutcome(outcome) : ethers_1.constants.HashZero\n  };\n}\n\nexports.channelDataLiteStruct = channelDataLiteStruct;\n\nfunction encodeChannelStorageLite(channelDataLite) {\n  return ethers_1.utils.defaultAbiCoder.encode([CHANNEL_DATA_LITE_TYPE], [channelDataLiteStruct(channelDataLite)]);\n}\n\nexports.encodeChannelStorageLite = encodeChannelStorageLite;\n\nfunction validateHexString(hexString) {\n  if (!ethers_1.utils.isHexString(hexString)) {\n    throw new Error(\"Not a hex string: \" + hexString);\n  }\n\n  if (hexString.length !== 66) {\n    throw new Error(\"Incorrect length: \" + hexString.length);\n  }\n}","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar Interface = ethers_1.utils.Interface,\n    keccak256 = ethers_1.utils.keccak256,\n    defaultAbiCoder = ethers_1.utils.defaultAbiCoder;\n\nvar NitroAdjudicator_json_1 = __importDefault(require(\"../../build/contracts/NitroAdjudicator.json\"));\n\nvar outcome_1 = require(\"./outcome\");\n\nvar state_1 = require(\"./state\");\n\nfunction hashChallengeMessage(challengeState) {\n  return keccak256(defaultAbiCoder.encode(['bytes32', 'string'], [state_1.hashState(challengeState), 'forceMove']));\n}\n\nexports.hashChallengeMessage = hashChallengeMessage;\n\nfunction getChallengeRegisteredEvent(eventResult) {\n  var _a = eventResult.slice(-1)[0].args,\n      turnNumRecord = _a.turnNumRecord,\n      finalizesAt = _a.finalizesAt,\n      challenger = _a.challenger,\n      isFinal = _a.isFinal,\n      fixedPart = _a.fixedPart,\n      variablePartsUnstructured = _a.variableParts,\n      sigs = _a.sigs,\n      whoSignedWhat = _a.whoSignedWhat;\n  var chainId = ethers_1.BigNumber.from(fixedPart[0]).toHexString();\n  var participants = fixedPart[1].map(function (p) {\n    return ethers_1.BigNumber.from(p).toHexString();\n  });\n  var channelNonce = fixedPart[2];\n  var appDefinition = fixedPart[3];\n  var challengeDuration = ethers_1.BigNumber.from(fixedPart[4]).toNumber();\n  var variableParts = variablePartsUnstructured.map(function (v) {\n    var outcome = v[0];\n    var appData = v[1];\n    return {\n      outcome: outcome,\n      appData: appData\n    };\n  });\n  var channel = {\n    chainId: chainId,\n    channelNonce: channelNonce,\n    participants: participants\n  };\n  var challengeStates = variableParts.map(function (v, i) {\n    var turnNum = turnNumRecord - (variableParts.length - i - 1);\n    var signature = sigs[i];\n    var state = {\n      turnNum: turnNum,\n      channel: channel,\n      outcome: outcome_1.decodeOutcome(v.outcome),\n      appData: v.appData,\n      challengeDuration: challengeDuration,\n      appDefinition: appDefinition,\n      isFinal: isFinal\n    };\n    return {\n      state: state,\n      signature: signature\n    };\n  });\n  return {\n    challengeStates: challengeStates,\n    finalizesAt: finalizesAt,\n    challengerAddress: challenger\n  };\n}\n\nexports.getChallengeRegisteredEvent = getChallengeRegisteredEvent;\n\nfunction getChallengeClearedEvent(tx, eventResult) {\n  var newTurnNumRecord = eventResult.slice(-1)[0].args.newTurnNumRecord;\n  var decodedTransaction = new Interface(NitroAdjudicator_json_1.default.abi).parseTransaction(tx);\n\n  if (decodedTransaction.name === 'respond') {\n    var args = decodedTransaction.args;\n    var _a = args[2],\n        chainId = _a[0],\n        participants = _a[1],\n        channelNonce = _a[2],\n        appDefinition = _a[3],\n        challengeDuration = _a[4];\n    var isFinal = args[1][1];\n    var outcome = outcome_1.decodeOutcome(args[3][1][0]);\n    var appData = args[3][1][1];\n    var signature = {\n      v: args[4][0],\n      r: args[4][1],\n      s: args[4][2],\n      _vs: args[4][3],\n      recoveryParam: args[4][4]\n    };\n    var signedState = {\n      signature: signature,\n      state: {\n        challengeDuration: challengeDuration,\n        appDefinition: appDefinition,\n        isFinal: isFinal,\n        outcome: outcome,\n        appData: appData,\n        channel: {\n          chainId: ethers_1.BigNumber.from(chainId).toHexString(),\n          channelNonce: channelNonce,\n          participants: participants\n        },\n        turnNum: ethers_1.BigNumber.from(newTurnNumRecord).toNumber()\n      }\n    };\n    return {\n      kind: 'respond',\n      newStates: [signedState]\n    };\n  } else if (decodedTransaction.name === 'checkpoint') {\n    throw new Error('UnimplementedError');\n  } else {\n    throw new Error('Unexpected call to getChallengeClearedEvent with invalid or unrelated transaction data');\n  }\n}\n\nexports.getChallengeClearedEvent = getChallengeClearedEvent;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar outcome_1 = require(\"../outcome\");\n\nfunction createTransferAllTransaction(assetHolderContractInterface, channelId, allocation) {\n  var data = assetHolderContractInterface.encodeFunctionData('transferAll', [channelId, outcome_1.encodeAllocation(allocation)]);\n  return {\n    data: data\n  };\n}\n\nexports.createTransferAllTransaction = createTransferAllTransaction;\n\nfunction claimAllArgs(channelId, guarantee, allocation) {\n  return [channelId, outcome_1.encodeGuarantee(guarantee), outcome_1.encodeAllocation(allocation)];\n}\n\nexports.claimAllArgs = claimAllArgs;\n\nfunction createClaimAllTransaction(assetHolderContractInterface, channelId, guarantee, allocation) {\n  var data = assetHolderContractInterface.encodeFunctionData('claimAll', claimAllArgs(channelId, guarantee, allocation));\n  return {\n    data: data\n  };\n}\n\nexports.createClaimAllTransaction = createClaimAllTransaction;\n\nfunction createSetOutcomeTransaction(assetHolderContractInterface, channelId, outcome) {\n  var data = assetHolderContractInterface.encodeFunctionData('setOutcome', [channelId, outcome_1.hashOutcome(outcome)]);\n  return {\n    data: data\n  };\n}\n\nexports.createSetOutcomeTransaction = createSetOutcomeTransaction;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isStateChannelsResponse(message) {\n  return message && typeof message == 'object' && 'id' in message && 'result' in message;\n}\n\nexports.isStateChannelsResponse = isStateChannelsResponse;\n\nfunction isStateChannelsNotification(message) {\n  return message && typeof message == 'object' && !('id' in message);\n}\n\nexports.isStateChannelsNotification = isStateChannelsNotification;\n\nfunction isStateChannelsRequest(message) {\n  return message && message && typeof message == 'object' && 'id' in message && 'params' in message;\n}\n\nexports.isStateChannelsRequest = isStateChannelsRequest;\n\nfunction isStateChannelsErrorResponse(message) {\n  return message && typeof message == 'object' && 'id' in message && 'message' in message && 'error' in message;\n}\n\nexports.isStateChannelsErrorResponse = isStateChannelsErrorResponse;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isJsonRpc(message) {\n  return typeof message === 'object' && message !== null && 'jsonrpc' in message;\n}\n/**\n * Type guard for {@link JsonRpcRequest | JsonRpcRequest}\n *\n * @returns true if the message is a JSON-RPC request, false otherwise\n * @beta\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isJsonRpcRequest(message) {\n  return isJsonRpc(message) && 'id' in message && 'params' in message && 'method' in message && 'jsonrpc' in message && message['jsonrpc'] === '2.0';\n}\n\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Type guard for {@link JsonRpcNotification | JsonRpcNotification}\n *\n * @returns true if the message is a JSON-RPC notification, false otherwise\n * @beta\n */\n\nfunction isJsonRpcNotification(message) {\n  return isJsonRpc(message) && 'method' in message && !('id' in message);\n}\n\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Type guard for {@link JsonRpcResponse| JsonRpcResponse}\n *\n * @returns true if the message is a JSON-RPC response, false otherwis\n * @beta\n */\n\nfunction isJsonRpcResponse(message) {\n  return isJsonRpc(message) && 'result' in message;\n}\n\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Type guard for {@link JsonRpcErrorResponse | JsonRpcErrorResponse}\n *\n * @returns true if the message is a JSON-RPC error response, false otherwise\n * @beta\n */\n\nfunction isJsonRpcErrorResponse(message) {\n  return isJsonRpc(message) && 'id' in message && 'error' in message;\n}\n\nexports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // need to use this syntax, because ajv uses export= style exports\n// otherwise we force all consumers of the package to set esModuleInterop to true\n\nvar Ajv = require(\"ajv\"); // You need to pass `jsonPointers: true`\n\n\nvar ajv = new Ajv({\n  jsonPointers: true,\n  verbose: true\n}); // eslint-disable-next-line\n\nvar apiSchema = require('./generated-schema.json'); // because https://github.com/TypeStrong/ts-loader/issues/905\n\n\najv.addSchema(apiSchema, 'api.json');\nexports.validateRequest = ajv.compile({\n  $ref: 'api.json#/definitions/StateChannelsRequest'\n});\nexports.validateResponse = ajv.compile({\n  $ref: 'api.json#/definitions/StateChannelsResponse'\n});\nexports.validateErrorResponse = ajv.compile({\n  $ref: 'api.json#/definitions/StateChannelsErrorResponse'\n});\nexports.validateNotification = ajv.compile({\n  $ref: 'api.json#/definitions/StateChannelsNotification'\n});\n\nfunction prettyPrintError(e) {\n  switch (e.keyword) {\n    case 'additionalProperties':\n      {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var unexpected = e.params.additionalProperty;\n        return \"Unexpected property '\".concat(unexpected, \"' found at root\").concat(e.dataPath, \" \");\n      }\n\n    case 'required':\n      {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var missing = e.params.missingProperty;\n        return \"Missing required property '\".concat(missing, \"' at root\").concat(e.dataPath);\n      }\n\n    case 'type':\n    case 'pattern':\n      {\n        return \"Property at root\".concat(e.dataPath, \" \").concat(e.message);\n      }\n  }\n\n  return JSON.stringify(e);\n}\n/**\n * Validates a request against the API schema & returns the input cast to the correctly narrowed type.\n *\n * @param jsonBlob - A javascript object that might be a valid {@link StateChannelsRequest}\n * @returns The input, but with the correct type, if it is valid.\n */\n\n\nfunction parseRequest(jsonBlob) {\n  var _a;\n\n  var valid = exports.validateRequest(jsonBlob);\n\n  if (!valid) {\n    throw new Error(\"Validation Error: \".concat((_a = exports.validateRequest.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join(\";\\n\")));\n  }\n\n  return jsonBlob;\n}\n\nexports.parseRequest = parseRequest;\n/**\n * Validates a response against the API schema & returns the input cast to the correctly narrowed type.\n *\n * @param jsonBlob - A javascript object that might be a valid {@link StateChannelsResponse}\n * @returns The input, but with the correct type, if it is valid.\n */\n\nfunction parseResponse(jsonBlob) {\n  var _a;\n\n  var valid = exports.validateResponse(jsonBlob);\n\n  if (!valid) {\n    throw new Error(\"\\n      Validation Error:\\n        input: \".concat(JSON.stringify(jsonBlob), \";\\n\\n        \").concat((_a = exports.validateResponse.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join(\";\\n\"), \"\\n      \"));\n  }\n\n  return jsonBlob;\n}\n\nexports.parseResponse = parseResponse;\n/**\n * Validates a notification against the API schema & returns the input cast to the correctly narrowed type.\n *\n * @param jsonBlob - A javascript object that might be a valid {@link StateChannelsNotification}\n * @returns The input, but with the correct type, if it is valid.\n */\n\nfunction parseNotification(jsonBlob) {\n  var _a;\n\n  var valid = exports.validateNotification(jsonBlob);\n\n  if (!valid) {\n    throw new Error(\"\\n      Validation Error:\\n        input: \".concat(JSON.stringify(jsonBlob), \";\\n\\n        \").concat((_a = exports.validateNotification.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join(\";\\n\"), \"\\n      \"));\n  }\n\n  return jsonBlob;\n}\n\nexports.parseNotification = parseNotification;\n/**\n * Validates an error response against the API schema & returns the input cast to the correctly narrowed type.\n *\n * @param jsonBlob - A javascript object that might be a valid {@link StateChannelsErrorResponse}\n * @returns The input, but with the correct type, if it is valid.\n */\n\nfunction parseErrorResponse(jsonBlob) {\n  var _a;\n\n  var valid = exports.validateErrorResponse(jsonBlob);\n\n  if (!valid) {\n    throw new Error(\"\\n      Validation Error:\\n        input: \".concat(JSON.stringify(jsonBlob), \";\\n\\n        \").concat((_a = exports.validateNotification.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join(\";\\n\"), \"\\n      \"));\n  }\n\n  return jsonBlob;\n}\n\nexports.parseErrorResponse = parseErrorResponse;","\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs_1 = __importDefault(require(\"fs\"));\n\nvar ethers_1 = require(\"ethers\");\n\nvar channel_storage_1 = require(\"../src/contract/channel-storage\");\n\nvar outcome_1 = require(\"../src/contract/outcome\");\n\nexports.getTestProvider = function () {\n  if (!process.env.GANACHE_PORT) {\n    throw new Error('Missing environment variable GANACHE_PORT required');\n  }\n\n  return new ethers_1.ethers.providers.JsonRpcProvider(\"http://localhost:\" + process.env.GANACHE_PORT);\n};\n\nfunction setupContracts(provider, artifact, address) {\n  return __awaiter(this, void 0, void 0, function () {\n    var signer, contract;\n    return __generator(this, function (_a) {\n      signer = provider.getSigner(0);\n      contract = new ethers_1.ethers.Contract(address, artifact.abi, signer);\n      return [2, contract];\n    });\n  });\n}\n\nexports.setupContracts = setupContracts;\n\nfunction getPlaceHolderContractAddress() {\n  return process.env.COUNTING_APP_ADDRESS;\n}\n\nexports.getPlaceHolderContractAddress = getPlaceHolderContractAddress;\nexports.nonParticipant = ethers_1.ethers.Wallet.createRandom();\n\nexports.clearedChallengeHash = function (turnNumRecord) {\n  if (turnNumRecord === void 0) {\n    turnNumRecord = 5;\n  }\n\n  return channel_storage_1.channelDataToChannelStorageHash({\n    turnNumRecord: turnNumRecord,\n    finalizesAt: 0\n  });\n};\n\nexports.ongoingChallengeHash = function (turnNumRecord) {\n  if (turnNumRecord === void 0) {\n    turnNumRecord = 5;\n  }\n\n  return channel_storage_1.channelDataToChannelStorageHash({\n    turnNumRecord: turnNumRecord,\n    finalizesAt: 1e12,\n    challengerAddress: ethers_1.constants.AddressZero,\n    outcome: []\n  });\n};\n\nexports.finalizedOutcomeHash = function (turnNumRecord, finalizesAt, outcome, state, challengerAddress) {\n  if (turnNumRecord === void 0) {\n    turnNumRecord = 5;\n  }\n\n  if (finalizesAt === void 0) {\n    finalizesAt = 1;\n  }\n\n  if (outcome === void 0) {\n    outcome = [];\n  }\n\n  if (state === void 0) {\n    state = undefined;\n  }\n\n  if (challengerAddress === void 0) {\n    challengerAddress = undefined;\n  }\n\n  return channel_storage_1.channelDataToChannelStorageHash({\n    turnNumRecord: turnNumRecord,\n    finalizesAt: finalizesAt,\n    outcome: outcome,\n    state: state,\n    challengerAddress: challengerAddress\n  });\n};\n\nexports.newChallengeRegisteredEvent = function (contract, channelId) {\n  var filter = contract.filters.ChallengeRegistered(channelId);\n  return new Promise(function (resolve, reject) {\n    contract.on(filter, function (eventChannelIdArg, eventTurnNumRecordArg, eventFinalizesAtArg, eventChallengerArg, eventIsFinalArg, eventFixedPartArg, eventChallengeVariablePartArg, event) {\n      contract.removeAllListeners(filter);\n      resolve([eventChannelIdArg, eventTurnNumRecordArg, eventFinalizesAtArg, eventChallengerArg, eventIsFinalArg, eventFixedPartArg, eventChallengeVariablePartArg]);\n    });\n  });\n};\n\nexports.newChallengeClearedEvent = function (contract, channelId) {\n  var filter = contract.filters.ChallengeCleared(channelId);\n  return new Promise(function (resolve, reject) {\n    contract.on(filter, function (eventChannelId, eventTurnNumRecord, event) {\n      contract.removeAllListeners(filter);\n      resolve([eventChannelId, eventTurnNumRecord]);\n    });\n  });\n};\n\nexports.newConcludedEvent = function (contract, channelId) {\n  var filter = contract.filters.Concluded(channelId);\n  return new Promise(function (resolve, reject) {\n    contract.on(filter, function (eventChannelId, event) {\n      contract.removeAllListeners(filter);\n      resolve([channelId]);\n    });\n  });\n};\n\nexports.newDepositedEvent = function (contract, destination) {\n  var filter = contract.filters.Deposited(destination);\n  return new Promise(function (resolve, reject) {\n    contract.on(filter, function (eventDestination, amountDeposited, amountHeld, event) {\n      contract.removeAllListeners(filter);\n      resolve([eventDestination, amountDeposited, amountHeld]);\n    });\n  });\n};\n\nexports.newTransferEvent = function (contract, to) {\n  var filter = contract.filters.Transfer(null, to);\n  return new Promise(function (resolve, reject) {\n    contract.on(filter, function (eventFrom, eventTo, amountTransferred, event) {\n      contract.removeAllListeners(filter);\n      resolve(amountTransferred);\n    });\n  });\n};\n\nexports.newAssetTransferredEvent = function (destination, payout) {\n  return {\n    destination: destination.toLowerCase(),\n    amount: payout\n  };\n};\n\nfunction randomChannelId(channelNonce) {\n  if (channelNonce === void 0) {\n    channelNonce = 0;\n  }\n\n  var participants = [];\n\n  for (var i = 0; i < 3; i++) {\n    participants[i] = ethers_1.ethers.Wallet.createRandom().address;\n  }\n\n  var channelId = ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode(['uint256', 'address[]', 'uint256'], [1234, participants, channelNonce]));\n  return channelId;\n}\n\nexports.randomChannelId = randomChannelId;\n\nexports.randomExternalDestination = function () {\n  return '0x' + ethers_1.ethers.Wallet.createRandom().address.slice(2, 42).padStart(64, '0').toLowerCase();\n};\n\nfunction sendTransaction(provider, contractAddress, transaction) {\n  return __awaiter(this, void 0, void 0, function () {\n    var signer, response;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          signer = provider.getSigner();\n          return [4, signer.sendTransaction(__assign({\n            to: contractAddress\n          }, transaction))];\n\n        case 1:\n          response = _a.sent();\n          return [4, response.wait()];\n\n        case 2:\n          return [2, _a.sent()];\n      }\n    });\n  });\n}\n\nexports.sendTransaction = sendTransaction;\n\nfunction allocationToParams(allocation) {\n  var allocationBytes = outcome_1.encodeAllocation(allocation);\n  var assetOutcomeHash;\n\n  if (allocation.length === 0) {\n    assetOutcomeHash = ethers_1.constants.HashZero;\n  } else {\n    assetOutcomeHash = outcome_1.hashAssetOutcome(allocation);\n  }\n\n  return [allocationBytes, assetOutcomeHash];\n}\n\nexports.allocationToParams = allocationToParams;\n\nfunction guaranteeToParams(guarantee) {\n  var guaranteeBytes = outcome_1.encodeGuarantee(guarantee);\n  var assetOutcomeHash = outcome_1.hashAssetOutcome(guarantee);\n  return [guaranteeBytes, assetOutcomeHash];\n}\n\nexports.guaranteeToParams = guaranteeToParams;\n\nfunction replaceAddressesAndBigNumberify(object, addresses) {\n  var newObject = {};\n  Object.keys(object).forEach(function (key) {\n    if (typeof object[key] === 'object') {\n      newObject[addresses[key]] = replaceAddressesAndBigNumberify(object[key], addresses);\n    }\n\n    if (typeof object[key] === 'number') {\n      newObject[addresses[key]] = ethers_1.BigNumber.from(object[key]);\n    }\n  });\n  return newObject;\n}\n\nexports.replaceAddressesAndBigNumberify = replaceAddressesAndBigNumberify;\n\nfunction resetMultipleHoldings(multipleHoldings, contractsArray) {\n  var _this = this;\n\n  Object.keys(multipleHoldings).forEach(function (assetHolder) {\n    var holdings = multipleHoldings[assetHolder];\n    Object.keys(holdings).forEach(function (destination) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var amount;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          amount = holdings[destination];\n          contractsArray.forEach(function (contract) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    if (!(contract.address === assetHolder)) return [3, 4];\n                    return [4, contract.setHoldings(destination, amount)];\n\n                  case 1:\n                    return [4, _b.sent().wait()];\n\n                  case 2:\n                    _b.sent();\n\n                    _a = expect;\n                    return [4, contract.holdings(destination)];\n\n                  case 3:\n                    _a.apply(void 0, [_b.sent().eq(amount)]).toBe(true);\n\n                    _b.label = 4;\n\n                  case 4:\n                    return [2];\n                }\n              });\n            });\n          });\n          return [2];\n        });\n      });\n    });\n  });\n}\n\nexports.resetMultipleHoldings = resetMultipleHoldings;\n\nfunction checkMultipleHoldings(multipleHoldings, contractsArray) {\n  var _this = this;\n\n  Object.keys(multipleHoldings).forEach(function (assetHolder) {\n    var holdings = multipleHoldings[assetHolder];\n    Object.keys(holdings).forEach(function (destination) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var amount;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          amount = holdings[destination];\n          contractsArray.forEach(function (contract) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    if (!(contract.address === assetHolder)) return [3, 2];\n                    _a = expect;\n                    return [4, contract.holdings(destination)];\n\n                  case 1:\n                    _a.apply(void 0, [_b.sent().eq(amount)]).toBe(true);\n\n                    _b.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          });\n          return [2];\n        });\n      });\n    });\n  });\n}\n\nexports.checkMultipleHoldings = checkMultipleHoldings;\n\nfunction checkMultipleAssetOutcomeHashes(channelId, outcome, contractsArray) {\n  var _this = this;\n\n  Object.keys(outcome).forEach(function (assetHolder) {\n    var assetOutcome = outcome[assetHolder];\n    var allocationAfter = [];\n    Object.keys(assetOutcome).forEach(function (destination) {\n      var amount = assetOutcome[destination];\n      allocationAfter.push({\n        destination: destination,\n        amount: amount\n      });\n    });\n\n    var _a = allocationToParams(allocationAfter),\n        expectedNewAssetOutcomeHash = _a[1];\n\n    contractsArray.forEach(function (contract) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!(contract.address === assetHolder)) return [3, 2];\n              _a = expect;\n              return [4, contract.assetOutcomeHashes(channelId)];\n\n            case 1:\n              _a.apply(void 0, [_b.sent()]).toEqual(expectedNewAssetOutcomeHash);\n\n              _b.label = 2;\n\n            case 2:\n              return [2];\n          }\n        });\n      });\n    });\n  });\n}\n\nexports.checkMultipleAssetOutcomeHashes = checkMultipleAssetOutcomeHashes;\n\nfunction computeOutcome(outcomeShortHand) {\n  var outcome = [];\n  Object.keys(outcomeShortHand).forEach(function (assetHolder) {\n    var allocation = [];\n    Object.keys(outcomeShortHand[assetHolder]).forEach(function (destination) {\n      return allocation.push({\n        destination: destination,\n        amount: ethers_1.BigNumber.from(outcomeShortHand[assetHolder][destination]).toHexString()\n      });\n    });\n    var assetOutcome = {\n      assetHolderAddress: assetHolder,\n      allocationItems: allocation\n    };\n    outcome.push(assetOutcome);\n  });\n  return outcome;\n}\n\nexports.computeOutcome = computeOutcome;\n\nfunction assetTransferredEventsFromPayouts(channelId, singleAssetPayouts, assetHolder) {\n  var assetTransferredEvents = [];\n  Object.keys(singleAssetPayouts).forEach(function (destination) {\n    if (singleAssetPayouts[destination] && ethers_1.BigNumber.from(singleAssetPayouts[destination]).gt(0)) {\n      assetTransferredEvents.push({\n        contract: assetHolder,\n        name: 'AssetTransferred',\n        args: {\n          channelId: channelId,\n          destination: destination,\n          amount: singleAssetPayouts[destination]\n        }\n      });\n    }\n  });\n  return assetTransferredEvents;\n}\n\nexports.assetTransferredEventsFromPayouts = assetTransferredEventsFromPayouts;\n\nfunction compileEventsFromLogs(logs, contractsArray) {\n  var events = [];\n  logs.forEach(function (log) {\n    contractsArray.forEach(function (contract) {\n      if (log.address === contract.address) {\n        events.push(__assign(__assign({}, contract.interface.parseLog(log)), {\n          contract: log.address\n        }));\n      }\n    });\n  });\n  return events;\n}\n\nexports.compileEventsFromLogs = compileEventsFromLogs;\n\nfunction writeGasConsumption(filename, description, gas) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, fs_1.default.appendFile(filename, description + ':\\n' + gas.toString() + ' gas\\n\\n', function (err) {\n            if (err) throw err;\n          })];\n\n        case 1:\n          _a.sent();\n\n          return [2];\n      }\n    });\n  });\n}\n\nexports.writeGasConsumption = writeGasConsumption;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar ethers_utils_1 = require(\"../ethers-utils\");\n\nfunction getDepositedEvent(eventResult) {\n  var _a = ethers_utils_1.parseEventResult(eventResult),\n      destination = _a.destination,\n      amountDeposited = _a.amountDeposited,\n      destinationHoldings = _a.destinationHoldings;\n\n  return {\n    destination: destination,\n    amountDeposited: ethers_1.BigNumber.from(amountDeposited),\n    destinationHoldings: ethers_1.BigNumber.from(destinationHoldings)\n  };\n}\n\nexports.getDepositedEvent = getDepositedEvent;\n\nfunction getAssetTransferredEvent(eventResult) {\n  var _a = ethers_utils_1.parseEventResult(eventResult),\n      channelId = _a.channelId,\n      destination = _a.destination,\n      amount = _a.amount;\n\n  return {\n    channelId: channelId,\n    destination: destination,\n    amount: ethers_1.BigNumber.from(amount)\n  };\n}\n\nexports.getAssetTransferredEvent = getAssetTransferredEvent;\n\nfunction convertBytes32ToAddress(bytes32) {\n  var normalized = ethers_1.BigNumber.from(bytes32).toHexString();\n  return ethers_1.utils.getAddress(\"0x\" + normalized.slice(-40));\n}\n\nexports.convertBytes32ToAddress = convertBytes32ToAddress;\n\nfunction convertAddressToBytes32(address) {\n  var normalizedAddress = ethers_1.BigNumber.from(address).toHexString();\n\n  if (normalizedAddress.length !== 42) {\n    throw new Error(\"Address value is not right length. Expected length of 42 received length \" + normalizedAddress.length + \" instead.\");\n  }\n\n  return ethers_1.utils.hexZeroPad(normalizedAddress, 32);\n}\n\nexports.convertAddressToBytes32 = convertAddressToBytes32;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction parseEventResult(result) {\n  return result.slice(-1)[0].args;\n}\n\nexports.parseEventResult = parseEventResult;","\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar ForceMoveApp_json_1 = __importDefault(require(\"../../build/contracts/ForceMoveApp.json\"));\n\nvar state_1 = require(\"../contract/state\");\n\nexports.ForceMoveAppContractInterface = new ethers_1.utils.Interface(ForceMoveApp_json_1.default.abi);\n\nfunction validTransition(fromState, toState, appContract) {\n  return __awaiter(this, void 0, void 0, function () {\n    var numberOfParticipants, fromVariablePart, toVariablePart, turnNumB;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          numberOfParticipants = toState.channel.participants.length;\n          fromVariablePart = state_1.getVariablePart(fromState);\n          toVariablePart = state_1.getVariablePart(toState);\n          turnNumB = toState.turnNum;\n          return [4, appContract.validTransition(fromVariablePart, toVariablePart, turnNumB, numberOfParticipants)];\n\n        case 1:\n          return [2, _a.sent()];\n      }\n    });\n  });\n}\n\nexports.validTransition = validTransition;\n\nfunction createValidTransitionTransaction(fromState, toState) {\n  var numberOfParticipants = toState.channel.participants.length;\n  var fromVariablePart = state_1.getVariablePart(fromState);\n  var toVariablePart = state_1.getVariablePart(toState);\n  var turnNumB = toState.turnNum;\n  var data = exports.ForceMoveAppContractInterface.encodeFunctionData('validTransition', [fromVariablePart, toVariablePart, turnNumB, numberOfParticipants]);\n  return {\n    data: data\n  };\n}\n\nexports.createValidTransitionTransaction = createValidTransitionTransaction;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar ERC20AssetHolder_json_1 = __importDefault(require(\"../../../build/contracts/ERC20AssetHolder.json\"));\n\nvar assetHolderTransactionCreator = __importStar(require(\"./asset-holder\"));\n\nvar Erc20AssetHolderContractInterface = new ethers_1.ethers.utils.Interface(ERC20AssetHolder_json_1.default.abi);\n\nfunction createTransferAllTransaction(channelId, allocation) {\n  return assetHolderTransactionCreator.createTransferAllTransaction(Erc20AssetHolderContractInterface, channelId, allocation);\n}\n\nexports.createTransferAllTransaction = createTransferAllTransaction;\n\nfunction createClaimAllTransaction(channelId, guarantee, allocation) {\n  return assetHolderTransactionCreator.createClaimAllTransaction(Erc20AssetHolderContractInterface, channelId, guarantee, allocation);\n}\n\nexports.createClaimAllTransaction = createClaimAllTransaction;\n\nfunction createSetOutcomeTransaction(channelId, outcome) {\n  return assetHolderTransactionCreator.createSetOutcomeTransaction(Erc20AssetHolderContractInterface, channelId, outcome);\n}\n\nexports.createSetOutcomeTransaction = createSetOutcomeTransaction;\n\nfunction createDepositTransaction(destination, expectedHeld, amount) {\n  var data = Erc20AssetHolderContractInterface.functions.deposit.encode([destination, expectedHeld, amount]);\n  return {\n    data: data\n  };\n}\n\nexports.createDepositTransaction = createDepositTransaction;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar ETHAssetHolder_json_1 = __importDefault(require(\"../../../build/contracts/ETHAssetHolder.json\"));\n\nvar assetHolderTransactionCreator = __importStar(require(\"./asset-holder\"));\n\nvar EthAssetHolderContractInterface = new ethers_1.ethers.utils.Interface(ETHAssetHolder_json_1.default.abi);\n\nfunction createTransferAllTransaction(channelId, allocation) {\n  return assetHolderTransactionCreator.createTransferAllTransaction(EthAssetHolderContractInterface, channelId, allocation);\n}\n\nexports.createTransferAllTransaction = createTransferAllTransaction;\n\nfunction createClaimAllTransaction(channelId, guarantee, allocation) {\n  return assetHolderTransactionCreator.createClaimAllTransaction(EthAssetHolderContractInterface, channelId, guarantee, allocation);\n}\n\nexports.createClaimAllTransaction = createClaimAllTransaction;\n\nfunction createSetOutcomeTransaction(channelId, outcome) {\n  return assetHolderTransactionCreator.createSetOutcomeTransaction(EthAssetHolderContractInterface, channelId, outcome);\n}\n\nexports.createSetOutcomeTransaction = createSetOutcomeTransaction;\n\nfunction createDepositTransaction(destination, expectedHeld, amount) {\n  var data = EthAssetHolderContractInterface.functions.deposit.encode([destination, expectedHeld, amount]);\n  return {\n    data: data\n  };\n}\n\nexports.createDepositTransaction = createDepositTransaction;","\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar forceMoveTrans = __importStar(require(\"./contract/transaction-creators/force-move\"));\n\nvar nitroAdjudicatorTrans = __importStar(require(\"./contract/transaction-creators/nitro-adjudicator\"));\n\nvar signatures_1 = require(\"./signatures\");\n\nfunction getChannelStorage(provider, contractAddress, channelId) {\n  return __awaiter(this, void 0, void 0, function () {\n    var forceMove;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          forceMove = new ethers_1.Contract(contractAddress, forceMoveTrans.ForceMoveContractInterface, provider);\n          return [4, forceMove.getChannelStorage(channelId)];\n\n        case 1:\n          return [2, _a.sent()];\n      }\n    });\n  });\n}\n\nexports.getChannelStorage = getChannelStorage;\n\nfunction createForceMoveTransaction(signedStates, challengePrivateKey) {\n  var _a = createSignatureArguments(signedStates),\n      states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n\n  return forceMoveTrans.createForceMoveTransaction(states, signatures, whoSignedWhat, challengePrivateKey);\n}\n\nexports.createForceMoveTransaction = createForceMoveTransaction;\n\nfunction createRespondTransaction(challengeState, response) {\n  if (!challengeState) {\n    throw new Error('No active challenge in challenge state');\n  }\n\n  return forceMoveTrans.createRespondTransaction({\n    challengeState: challengeState,\n    responseState: response.state,\n    responseSignature: response.signature\n  });\n}\n\nexports.createRespondTransaction = createRespondTransaction;\n\nfunction createCheckpointTransaction(signedStates) {\n  var _a = createSignatureArguments(signedStates),\n      states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n\n  return forceMoveTrans.createCheckpointTransaction({\n    states: states,\n    signatures: signatures,\n    whoSignedWhat: whoSignedWhat\n  });\n}\n\nexports.createCheckpointTransaction = createCheckpointTransaction;\n\nfunction createConcludePushOutcomeAndTransferAllTransaction(signedStates) {\n  var _a = createSignatureArguments(signedStates),\n      states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n\n  return nitroAdjudicatorTrans.createConcludePushOutcomeAndTransferAllTransaction(states, signatures, whoSignedWhat);\n}\n\nexports.createConcludePushOutcomeAndTransferAllTransaction = createConcludePushOutcomeAndTransferAllTransaction;\n\nfunction createConcludeTransaction(conclusionProof) {\n  var _a = createSignatureArguments(conclusionProof),\n      states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n\n  return forceMoveTrans.createConcludeTransaction(states, signatures, whoSignedWhat);\n}\n\nexports.createConcludeTransaction = createConcludeTransaction;\n\nfunction createSignatureArguments(signedStates) {\n  var participants = signedStates[0].state.channel.participants;\n  var states = [];\n  var whoSignedWhat = new Array(participants.length);\n  var uniqueSignedStates = signedStates.filter(function (s, i, a) {\n    return a.indexOf(s) === i;\n  });\n  var uniqueStates = uniqueSignedStates.map(function (s) {\n    return s.state;\n  }).filter(function (s, i, a) {\n    return a.indexOf(s) === i;\n  });\n  var signatures = new Array(uniqueStates.length);\n\n  var _loop_1 = function _loop_1(i) {\n    states.push(uniqueStates[i]);\n    var signedStatesForUniqueState = uniqueSignedStates.filter(function (s) {\n      return s.state === uniqueStates[i];\n    });\n\n    for (var _i = 0, signedStatesForUniqueState_1 = signedStatesForUniqueState; _i < signedStatesForUniqueState_1.length; _i++) {\n      var ss = signedStatesForUniqueState_1[_i];\n      var participantIndex = participants.indexOf(signatures_1.getStateSignerAddress(ss));\n      signatures[participantIndex] = ss.signature;\n      whoSignedWhat[participantIndex] = i;\n    }\n  };\n\n  for (var i = 0; i < uniqueStates.length; i++) {\n    _loop_1(i);\n  }\n\n  return {\n    states: states,\n    signatures: signatures,\n    whoSignedWhat: whoSignedWhat\n  };\n}\n\nexports.createSignatureArguments = createSignatureArguments;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar ForceMove_json_1 = __importDefault(require(\"../../../build/contracts/ForceMove.json\"));\n\nvar signatures_1 = require(\"../../signatures\");\n\nvar outcome_1 = require(\"../outcome\");\n\nvar state_1 = require(\"../state\");\n\nexports.ForceMoveContractInterface = new ethers_1.ethers.utils.Interface(ForceMove_json_1.default.abi);\n\nfunction createForceMoveTransaction(states, signatures, whoSignedWhat, challengerPrivateKey) {\n  if (states.length === 0) {\n    throw new Error('No states provided');\n  }\n\n  var participants = states[0].channel.participants;\n\n  if (participants.length !== signatures.length) {\n    throw new Error(\"Participants (length:\" + participants.length + \") and signatures (length:\" + signatures.length + \") need to be the same length\");\n  }\n\n  var variableParts = states.map(function (s) {\n    return state_1.getVariablePart(s);\n  });\n  var fixedPart = state_1.getFixedPart(states[0]);\n  var largestTurnNum = Math.max.apply(Math, states.map(function (s) {\n    return s.turnNum;\n  }));\n  var isFinalCount = states.filter(function (s) {\n    return s.isFinal === true;\n  }).length;\n  var signedStates = states.map(function (s) {\n    return {\n      state: s,\n      signature: {\n        v: 0,\n        r: '',\n        s: '',\n        _vs: '',\n        recoveryParam: 0\n      }\n    };\n  });\n  var challengerSignature = signatures_1.signChallengeMessage(signedStates, challengerPrivateKey);\n  var data = exports.ForceMoveContractInterface.encodeFunctionData('forceMove', [fixedPart, largestTurnNum, variableParts, isFinalCount, signatures, whoSignedWhat, challengerSignature]);\n  return {\n    data: data\n  };\n}\n\nexports.createForceMoveTransaction = createForceMoveTransaction;\n\nfunction respondArgs(_a) {\n  var challengeState = _a.challengeState,\n      responseState = _a.responseState,\n      responseSignature = _a.responseSignature;\n  var participants = challengeState.channel.participants;\n  var challengerAddress = participants[challengeState.turnNum % participants.length];\n  var isFinalAB = [challengeState.isFinal, responseState.isFinal];\n  var fixedPart = state_1.getFixedPart(responseState);\n  var variablePartAB = [state_1.getVariablePart(challengeState), state_1.getVariablePart(responseState)];\n  return [challengerAddress, isFinalAB, fixedPart, variablePartAB, responseSignature];\n}\n\nexports.respondArgs = respondArgs;\n\nfunction createRespondTransaction(args) {\n  var data = exports.ForceMoveContractInterface.encodeFunctionData('respond', respondArgs(args));\n  return {\n    data: data\n  };\n}\n\nexports.createRespondTransaction = createRespondTransaction;\n\nfunction createCheckpointTransaction(_a) {\n  var states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n  var data = exports.ForceMoveContractInterface.encodeFunctionData('checkpoint', checkpointArgs({\n    states: states,\n    signatures: signatures,\n    whoSignedWhat: whoSignedWhat\n  }));\n  return {\n    data: data\n  };\n}\n\nexports.createCheckpointTransaction = createCheckpointTransaction;\n\nfunction checkpointArgs(_a) {\n  var states = _a.states,\n      signatures = _a.signatures,\n      whoSignedWhat = _a.whoSignedWhat;\n  var largestTurnNum = Math.max.apply(Math, states.map(function (s) {\n    return s.turnNum;\n  }));\n  var fixedPart = state_1.getFixedPart(states[0]);\n  var variableParts = states.map(function (s) {\n    return state_1.getVariablePart(s);\n  });\n  var isFinalCount = states.filter(function (s) {\n    return s.isFinal;\n  }).length;\n  return [fixedPart, largestTurnNum, variableParts, isFinalCount, signatures, whoSignedWhat];\n}\n\nexports.checkpointArgs = checkpointArgs;\n\nfunction createConcludeTransaction(states, signatures, whoSignedWhat) {\n  var data = exports.ForceMoveContractInterface.encodeFunctionData('conclude', concludeArgs(states, signatures, whoSignedWhat));\n  return {\n    data: data\n  };\n}\n\nexports.createConcludeTransaction = createConcludeTransaction;\n\nfunction concludeArgs(states, signatures, whoSignedWhat) {\n  if (states.length === 0) {\n    throw new Error('No states provided');\n  }\n\n  var participants = states[0].channel.participants;\n\n  if (participants.length !== signatures.length) {\n    throw new Error(\"Participants (length:\" + participants.length + \") and signatures (length:\" + signatures.length + \") need to be the same length\");\n  }\n\n  var lastState = states.reduce(function (s1, s2) {\n    return s1.turnNum >= s2.turnNum ? s1 : s2;\n  }, states[0]);\n  var largestTurnNum = lastState.turnNum;\n  var fixedPart = state_1.getFixedPart(lastState);\n  var appPartHash = state_1.hashAppPart(lastState);\n  var outcomeHash = outcome_1.hashOutcome(lastState.outcome);\n  var numStates = states.length;\n  return [largestTurnNum, fixedPart, appPartHash, outcomeHash, numStates, whoSignedWhat, signatures];\n}\n\nexports.concludeArgs = concludeArgs;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar NitroAdjudicator_json_1 = __importDefault(require(\"../../../build/contracts/NitroAdjudicator.json\"));\n\nvar channel_1 = require(\"../channel\");\n\nvar outcome_1 = require(\"../outcome\");\n\nvar state_1 = require(\"../state\");\n\nvar NitroAdjudicatorContractInterface = new ethers_1.utils.Interface(NitroAdjudicator_json_1.default.abi);\n\nfunction createPushOutcomeTransaction(turnNumRecord, finalizesAt, state, outcome) {\n  var channelId = channel_1.getChannelId(state.channel);\n  var stateHash = state_1.hashState(state);\n  var participants = state.channel.participants;\n  var challengerAddress = participants[state.turnNum % participants.length];\n  var encodedOutcome = outcome_1.encodeOutcome(outcome);\n  var data = NitroAdjudicatorContractInterface.encodeFunctionData('pushOutcome', [channelId, turnNumRecord, finalizesAt, stateHash, challengerAddress, encodedOutcome]);\n  return {\n    data: data\n  };\n}\n\nexports.createPushOutcomeTransaction = createPushOutcomeTransaction;\n\nfunction concludePushOutcomeAndTransferAllArgs(states, signatures, whoSignedWhat) {\n  if (states.length === 0) {\n    throw new Error('No states provided');\n  }\n\n  var participants = states[0].channel.participants;\n\n  if (participants.length !== signatures.length) {\n    throw new Error(\"Participants (length:\" + participants.length + \") and signatures (length:\" + signatures.length + \") need to be the same length\");\n  }\n\n  var lastState = states.reduce(function (s1, s2) {\n    return s1.turnNum >= s2.turnNum ? s1 : s2;\n  }, states[0]);\n  var largestTurnNum = lastState.turnNum;\n  var fixedPart = state_1.getFixedPart(lastState);\n  var appPartHash = state_1.hashAppPart(lastState);\n  var outcomeBytes = outcome_1.encodeOutcome(lastState.outcome);\n  var numStates = states.length;\n  return [largestTurnNum, fixedPart, appPartHash, outcomeBytes, numStates, whoSignedWhat, signatures];\n}\n\nexports.concludePushOutcomeAndTransferAllArgs = concludePushOutcomeAndTransferAllArgs;\n\nfunction createConcludePushOutcomeAndTransferAllTransaction(states, signatures, whoSignedWhat) {\n  return {\n    data: NitroAdjudicatorContractInterface.encodeFunctionData('concludePushOutcomeAndTransferAll', concludePushOutcomeAndTransferAllArgs(states, signatures, whoSignedWhat))\n  };\n}\n\nexports.createConcludePushOutcomeAndTransferAllTransaction = createConcludePushOutcomeAndTransferAllTransaction;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nvar ethers_1 = require(\"ethers\");\n\nvar config_1 = require(\"../config\");\n\nvar bignumber_1 = require(\"../bignumber\");\n\nvar helpers_1 = require(\"./helpers\");\n\nfunction isSimpleAllocation(outcome) {\n  return outcome.type === 'SimpleAllocation';\n}\n\nexports.isSimpleAllocation = isSimpleAllocation;\n\nfunction isSimpleEthAllocation(outcome) {\n  return outcome.type === 'SimpleAllocation' && outcome.assetHolderAddress === config_1.ETH_ASSET_HOLDER_ADDRESS;\n}\n\nexports.isSimpleEthAllocation = isSimpleEthAllocation;\n\nfunction assertSimpleEthAllocation(outcome) {\n  return helpers_1.checkThat(outcome, isSimpleEthAllocation);\n}\n\nexports.assertSimpleEthAllocation = assertSimpleEthAllocation;\n\nexports.simpleEthAllocation = function (allocationItems) {\n  return {\n    type: 'SimpleAllocation',\n    assetHolderAddress: config_1.ETH_ASSET_HOLDER_ADDRESS,\n    allocationItems: allocationItems\n  };\n};\n\nexports.simpleEthGuarantee = function (targetChannelId) {\n  for (var _len = arguments.length, destinations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    destinations[_key - 1] = arguments[_key];\n  }\n\n  return {\n    type: 'SimpleGuarantee',\n    destinations: destinations,\n    targetChannelId: targetChannelId,\n    assetHolderAddress: config_1.ETH_ASSET_HOLDER_ADDRESS\n  };\n};\n\nexports.simpleTokenAllocation = function (assetHolderAddress, allocationItems) {\n  return {\n    type: 'SimpleAllocation',\n    assetHolderAddress: assetHolderAddress,\n    allocationItems: allocationItems\n  };\n};\n\nvar Errors;\n\n(function (Errors) {\n  Errors[\"DestinationMissing\"] = \"Destination missing from ledger channel\";\n  Errors[\"InsufficientFunds\"] = \"Insufficient funds in ledger channel\";\n  Errors[\"InvalidOutcomeType\"] = \"Invalid outcome type\";\n})(Errors = exports.Errors || (exports.Errors = {}));\n\nfunction allocateToTarget(currentOutcome, deductions, targetChannelId) {\n  if (currentOutcome.type !== 'SimpleAllocation') {\n    throw new Error(Errors.InvalidOutcomeType);\n  }\n\n  currentOutcome = _.cloneDeep(currentOutcome);\n  var total = bignumber_1.Zero;\n  var currentItems = currentOutcome.allocationItems;\n  deductions.forEach(function (targetItem) {\n    var ledgerItem = currentItems.find(function (i) {\n      return i.destination === targetItem.destination;\n    });\n\n    if (!ledgerItem) {\n      throw new Error(Errors.DestinationMissing);\n    }\n\n    total = bignumber_1.BN.add(total, targetItem.amount);\n    ledgerItem.amount = bignumber_1.BN.sub(ledgerItem.amount, targetItem.amount);\n    if (bignumber_1.BN.lt(ledgerItem.amount, 0)) throw new Error(Errors.InsufficientFunds);\n  });\n  currentItems.push({\n    destination: makeDestination(targetChannelId),\n    amount: total\n  });\n  currentItems = currentItems.filter(function (i) {\n    return bignumber_1.BN.gt(i.amount, 0);\n  });\n  currentOutcome.allocationItems = currentItems;\n  return currentOutcome;\n}\n\nexports.allocateToTarget = allocateToTarget;\n\nfunction makeDestination(addressOrDestination) {\n  if (addressOrDestination.length === 42) {\n    return ethers_1.ethers.utils.hexZeroPad(ethers_1.ethers.utils.getAddress(addressOrDestination), 32);\n  } else if (addressOrDestination.length === 66) {\n    return addressOrDestination;\n  } else {\n    throw new Error('Invalid input');\n  }\n}\n\nexports.makeDestination = makeDestination;","\"use strict\";\n\nvar _defineProperty = require(\"/home/caleb/hypernet-protocol/subtrees/statechannels/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar _ = require(\"lodash\");\n\nvar config_1 = require(\"../config\");\n\nvar helpers_1 = require(\"./helpers\");\n\nfunction ethBudget(domain, opts) {\n  return {\n    domain: domain,\n    hubAddress: config_1.HUB_ADDRESS,\n    forAsset: _defineProperty({}, config_1.ETH_ASSET_HOLDER_ADDRESS, _.assign({\n      assetHolderAddress: config_1.ETH_ASSET_HOLDER_ADDRESS,\n      availableReceiveCapacity: constants_1.Zero,\n      availableSendCapacity: constants_1.Zero,\n      channels: {}\n    }, opts))\n  };\n}\n\nexports.ethBudget = ethBudget;\n\nfunction forEthAsset(budget) {\n  var ethPart = budget.forAsset[config_1.ETH_ASSET_HOLDER_ADDRESS];\n  if (!ethPart) throw 'No eth part!';\n  return ethPart;\n}\n\nexports.forEthAsset = forEthAsset;\n\nfunction extractEthAssetBudget(budget) {\n  if (Object.keys(budget.forAsset).length !== 1) {\n    throw new Error('Cannot handle mixed budget');\n  }\n\n  return helpers_1.checkThat(budget.forAsset[config_1.ETH_ASSET_HOLDER_ADDRESS], helpers_1.exists);\n}\n\nexports.extractEthAssetBudget = extractEthAssetBudget;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar config_1 = require(\"../config\");\n\nvar constants_1 = require(\"../constants\");\n\nvar bignumber_1 = require(\"../bignumber\");\n\nfunction assetHolderAddress(tokenAddress) {\n  if (bignumber_1.BN.isZero(tokenAddress)) return config_1.ETH_ASSET_HOLDER_ADDRESS;else if (tokenAddress === constants_1.MOCK_TOKEN) return constants_1.MOCK_ASSET_HOLDER_ADDRESS;\n  throw 'AssetHolderAddress not found';\n}\n\nexports.assetHolderAddress = assetHolderAddress;\n\nfunction tokenAddress(assetHolderAddress) {\n  if (assetHolderAddress === config_1.ETH_ASSET_HOLDER_ADDRESS) return constants_1.ETH_TOKEN;else if (assetHolderAddress === constants_1.MOCK_ASSET_HOLDER_ADDRESS) return constants_1.MOCK_TOKEN;\n  throw 'TokenAddress not found';\n}\n\nexports.tokenAddress = tokenAddress;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ETH_TOKEN = '0x0000000000000000000000000000000000000000';\nexports.MOCK_TOKEN = '0x1000000000000000000000000000000000000001';\nexports.MOCK_ASSET_HOLDER_ADDRESS = '0x1111111111111111111111111111111111111111';\nexports.CONCLUDE_TIMEOUT = 30000;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _1 = require(\".\");\n\nfunction convertToParticipant(participant) {\n  return Object.assign(Object.assign({}, participant), {\n    destination: _1.makeDestination(participant.destination)\n  });\n}\n\nexports.convertToParticipant = convertToParticipant;","\"use strict\";\n\nvar _defineProperty = require(\"/home/caleb/hypernet-protocol/subtrees/statechannels/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar config_1 = require(\"../../config\");\n\nvar bignumber_1 = require(\"../../bignumber\");\n\nvar utils_1 = require(\"../../utils\");\n\nfunction deserializeBudgetRequest(budgetRequest, domain) {\n  var assetBudget = {\n    assetHolderAddress: config_1.ETH_ASSET_HOLDER_ADDRESS,\n    availableSendCapacity: bignumber_1.BN.from(budgetRequest.requestedSendCapacity),\n    availableReceiveCapacity: bignumber_1.BN.from(budgetRequest.requestedReceiveCapacity),\n    channels: {}\n  };\n  return {\n    domain: domain,\n    hubAddress: budgetRequest.hub.signingAddress,\n    forAsset: _defineProperty({}, config_1.ETH_ASSET_HOLDER_ADDRESS, assetBudget)\n  };\n}\n\nexports.deserializeBudgetRequest = deserializeBudgetRequest;\n\nfunction deserializeDomainBudget(DomainBudget) {\n  var assetBudgets = DomainBudget.budgets.map(function (b) {\n    return {\n      assetHolderAddress: utils_1.assetHolderAddress(b.token) || constants_1.AddressZero,\n      availableReceiveCapacity: bignumber_1.BN.from(b.availableReceiveCapacity),\n      availableSendCapacity: bignumber_1.BN.from(b.availableSendCapacity),\n      channels: b.channels.reduce(function (record, item) {\n        record[item.channelId] = {\n          amount: bignumber_1.BN.from(item.amount)\n        };\n        return record;\n      }, {})\n    };\n  });\n  var budgets = assetBudgets.reduce(function (record, a) {\n    record[a.assetHolderAddress] = a;\n    return record;\n  }, {});\n  return {\n    domain: DomainBudget.domain,\n    hubAddress: DomainBudget.hubAddress,\n    forAsset: budgets\n  };\n}\n\nexports.deserializeDomainBudget = deserializeDomainBudget;\n\nfunction deserializeAllocations(allocations) {\n  switch (allocations.length) {\n    case 0:\n      throw new Error('Allocations is empty');\n\n    case 1:\n      return deserializeAllocation(allocations[0]);\n\n    default:\n      return {\n        type: 'MixedAllocation',\n        simpleAllocations: allocations.map(deserializeAllocation)\n      };\n  }\n}\n\nexports.deserializeAllocations = deserializeAllocations;\n\nfunction deserializeAllocation(allocation) {\n  var assetHolder = utils_1.assetHolderAddress(allocation.token);\n\n  if (!assetHolder) {\n    throw new Error(\"Can't find asset holder for token \".concat(allocation.token));\n  }\n\n  return {\n    type: 'SimpleAllocation',\n    allocationItems: allocation.allocationItems.map(deserializeAllocationItem),\n    assetHolderAddress: assetHolder\n  };\n}\n\nfunction deserializeAllocationItem(allocationItem) {\n  return {\n    destination: utils_1.makeDestination(allocationItem.destination),\n    amount: bignumber_1.BN.from(allocationItem.amount)\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar types_1 = require(\"../../types\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar bignumber_1 = require(\"../../bignumber\");\n\nfunction serializeDomainBudget(budget) {\n  var budgets = Object.keys(budget.forAsset).map(function (assetHolderAddress) {\n    var assetBudget = utils_1.checkThat(budget.forAsset[assetHolderAddress], utils_1.exists);\n    var channels = Object.keys(assetBudget.channels).map(function (channelId) {\n      return {\n        channelId: channelId,\n        amount: utils_1.formatAmount(bignumber_1.BN.from(assetBudget.channels[channelId].amount))\n      };\n    });\n    return {\n      token: utils_1.tokenAddress(assetHolderAddress) || constants_1.AddressZero,\n      availableReceiveCapacity: utils_1.formatAmount(assetBudget.availableReceiveCapacity),\n      availableSendCapacity: utils_1.formatAmount(assetBudget.availableSendCapacity),\n      channels: channels\n    };\n  });\n  return {\n    domain: budget.domain,\n    hubAddress: budget.hubAddress,\n    budgets: budgets\n  };\n}\n\nexports.serializeDomainBudget = serializeDomainBudget;\n\nfunction serializeAllocation(allocation) {\n  switch (allocation.type) {\n    case 'SimpleAllocation':\n      return [serializeSimpleAllocation(allocation)];\n\n    case 'MixedAllocation':\n      return allocation.simpleAllocations.map(serializeSimpleAllocation);\n  }\n}\n\nexports.serializeAllocation = serializeAllocation;\n\nfunction serializeSimpleAllocation(allocation) {\n  var token = utils_1.tokenAddress(allocation.assetHolderAddress);\n\n  if (!token) {\n    throw new Error(\"Can't find token address for asset holder \".concat(allocation.assetHolderAddress));\n  }\n\n  return {\n    allocationItems: allocation.allocationItems.map(serializeAllocationItem),\n    token: token\n  };\n}\n\nfunction serializeAllocationItem(allocationItem) {\n  return {\n    destination: allocationItem.destination,\n    amount: utils_1.formatAmount(allocationItem.amount)\n  };\n}\n\nfunction serializeChannelEntry(channelEntry) {\n  var _channelEntry$latest = channelEntry.latest,\n      appData = _channelEntry$latest.appData,\n      turnNum = _channelEntry$latest.turnNum,\n      outcome = _channelEntry$latest.outcome,\n      _channelEntry$channel = channelEntry.channelConstants,\n      participants = _channelEntry$channel.participants,\n      appDefinition = _channelEntry$channel.appDefinition,\n      channelId = channelEntry.channelId;\n\n  if (!types_1.isAllocation(outcome)) {\n    throw new Error('Can only send allocations to the app');\n  }\n\n  var status = 'running';\n\n  if (turnNum == 0) {\n    status = 'proposed';\n  } else if (turnNum < 2 * participants.length - 1) {\n    status = 'opening';\n  } else if (channelEntry.hasConclusionProof) {\n    status = 'closed';\n  } else if (channelEntry.isSupported && channelEntry.supported.isFinal) {\n    status = 'closing';\n  }\n\n  return {\n    participants: participants,\n    allocations: serializeAllocation(outcome),\n    appDefinition: appDefinition,\n    appData: appData,\n    status: status,\n    turnNum: turnNum,\n    channelId: channelId\n  };\n}\n\nexports.serializeChannelEntry = serializeChannelEntry;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar wire_format_1 = require(\"@statechannels/wire-format\");\n\nvar bignumber_1 = require(\"../../bignumber\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar state_utils_1 = require(\"../../state-utils\");\n\nfunction convertToInternalParticipant(participant) {\n  return Object.assign(Object.assign({}, participant), {\n    destination: utils_1.makeDestination(participant.destination)\n  });\n}\n\nexports.convertToInternalParticipant = convertToInternalParticipant;\n\nfunction deserializeMessage(message) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var signedStates = (_c = (_b = (_a = message) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.signedStates) === null || _c === void 0 ? void 0 : _c.map(function (ss) {\n    return deserializeState(ss);\n  });\n  var objectives = (_f = (_e = (_d = message) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.objectives) === null || _f === void 0 ? void 0 : _f.map(function (objective) {\n    return deserializeObjective(objective);\n  });\n  return {\n    signedStates: signedStates,\n    objectives: objectives\n  };\n}\n\nexports.deserializeMessage = deserializeMessage;\n\nfunction deserializeState(state) {\n  var stateWithoutChannelId = Object.assign({}, state);\n  delete stateWithoutChannelId.channelId;\n  var deserializedState = Object.assign(Object.assign({}, stateWithoutChannelId), {\n    outcome: deserializeOutcome(state.outcome),\n    participants: stateWithoutChannelId.participants.map(convertToInternalParticipant)\n  });\n  return Object.assign(Object.assign({}, deserializedState), {\n    signatures: state.signatures.map(function (sig) {\n      return {\n        signature: sig,\n        signer: state_utils_1.getSignerAddress(deserializedState, sig)\n      };\n    })\n  });\n}\n\nexports.deserializeState = deserializeState;\n\nfunction deserializeObjective(objective) {\n  return Object.assign(Object.assign({}, objective), {\n    participants: objective.participants.map(function (p) {\n      return Object.assign(Object.assign({}, p), {\n        destination: utils_1.makeDestination(p.destination)\n      });\n    })\n  });\n}\n\nexports.deserializeObjective = deserializeObjective;\n\nfunction deserializeOutcome(outcome) {\n  if (wire_format_1.isAllocations(outcome)) {\n    switch (outcome.length) {\n      case 0:\n        throw new Error('Empty allocation');\n\n      case 1:\n        return deserializeAllocation(outcome[0]);\n\n      default:\n        return {\n          type: 'MixedAllocation',\n          simpleAllocations: outcome.map(deserializeAllocation)\n        };\n    }\n  } else {\n    if (outcome.length !== 1) {\n      throw new Error('Currently only supporting guarantees of length 1.');\n    } else {\n      return Object.assign({\n        type: 'SimpleGuarantee'\n      }, outcome[0]);\n    }\n  }\n}\n\nfunction deserializeAllocation(allocation) {\n  var assetHolderAddress = allocation.assetHolderAddress,\n      allocationItems = allocation.allocationItems;\n  return {\n    type: 'SimpleAllocation',\n    assetHolderAddress: assetHolderAddress,\n    allocationItems: allocationItems.map(deserializeAllocationItem)\n  };\n}\n\nfunction deserializeAllocationItem(allocationItem) {\n  var amount = allocationItem.amount,\n      destination = allocationItem.destination;\n  return {\n    destination: utils_1.makeDestination(destination),\n    amount: bignumber_1.BN.from(amount)\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isAllocations(outcome) {\n  if (outcome.length === 0) {\n    return true;\n  } else {\n    var first = outcome[0];\n    return 'allocationItems' in first;\n  }\n}\n\nexports.isAllocations = isAllocations;\n\nvar guard = function guard(name) {\n  return function (o) {\n    return o.type === name;\n  };\n};\n\nexports.isOpenChannel = guard('OpenChannel');\nexports.isVirtuallyFund = guard('VirtuallyFund');\nexports.isFundGuarantor = guard('FundGuarantor');","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Ajv = require(\"ajv\");\n\nvar apiSchema = require('./generated-schema.json');\n\nvar ajv = new Ajv();\najv.addSchema(apiSchema, 'api.json');\n\nfunction prettyPrintError(e) {\n  switch (e.keyword) {\n    case 'additionalProperties':\n      {\n        var unexpected = e.params.additionalProperty;\n        return \"Unexpected property '\".concat(unexpected, \"' found at root\").concat(e.dataPath, \" \");\n      }\n\n    case 'required':\n      {\n        var missing = e.params.missingProperty;\n        return \"Missing required property '\".concat(missing, \"' at root\").concat(e.dataPath);\n      }\n\n    case 'type':\n    case 'pattern':\n      {\n        return \"Property at root\".concat(e.dataPath, \" \").concat(e.message);\n      }\n  }\n\n  return JSON.stringify(e);\n}\n\nexports.messageIsValid = ajv.compile({\n  $ref: 'api.json#/definitions/Message'\n});\n\nfunction validateMessage(jsonBlob) {\n  var _a;\n\n  var valid = exports.messageIsValid(jsonBlob);\n\n  if (!valid) {\n    var errorMessages = (_a = exports.messageIsValid.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join('; ');\n    throw new Error(\"Validation Error: \".concat(errorMessages));\n  }\n\n  return jsonBlob;\n}\n\nexports.validateMessage = validateMessage;\nexports.stateIsValid = ajv.compile({\n  $ref: 'api.json#/definitions/SignedState'\n});\n\nfunction validateState(jsonBlob) {\n  var _a;\n\n  var valid = exports.stateIsValid(jsonBlob);\n\n  if (!valid) {\n    var errorMessages = (_a = exports.stateIsValid.errors) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return prettyPrintError(e);\n    }).join('; ');\n    throw new Error(\"Validation Error: \".concat(errorMessages));\n  }\n\n  return jsonBlob;\n}\n\nexports.validateState = validateState;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar state_utils_1 = require(\"../../state-utils\");\n\nvar utils_1 = require(\"../../utils\");\n\nfunction serializeMessage(message, recipient, sender) {\n  var signedStates = (message.signedStates || []).map(function (ss) {\n    return serializeState(ss);\n  });\n  var objectives = message.objectives;\n  return {\n    recipient: recipient,\n    sender: sender,\n    data: {\n      signedStates: signedStates,\n      objectives: objectives\n    }\n  };\n}\n\nexports.serializeMessage = serializeMessage;\n\nfunction serializeState(state) {\n  var chainId = state.chainId,\n      participants = state.participants,\n      channelNonce = state.channelNonce,\n      appDefinition = state.appDefinition,\n      challengeDuration = state.challengeDuration,\n      turnNum = state.turnNum,\n      appData = state.appData,\n      isFinal = state.isFinal;\n  return {\n    chainId: chainId,\n    participants: participants,\n    channelNonce: channelNonce,\n    appDefinition: appDefinition,\n    challengeDuration: challengeDuration,\n    turnNum: turnNum,\n    appData: appData,\n    isFinal: isFinal,\n    outcome: serializeOutcome(state.outcome),\n    channelId: state_utils_1.calculateChannelId(state),\n    signatures: state.signatures.map(function (s) {\n      return s.signature;\n    })\n  };\n}\n\nexports.serializeState = serializeState;\n\nfunction serializeOutcome(outcome) {\n  switch (outcome.type) {\n    case 'SimpleAllocation':\n      return [serializeSimpleAllocation(outcome)];\n\n    case 'MixedAllocation':\n      return outcome.simpleAllocations.map(serializeSimpleAllocation);\n\n    case 'SimpleGuarantee':\n      return [serializeSimpleGuarantee(outcome)];\n  }\n}\n\nfunction serializeSimpleAllocation(allocation) {\n  return {\n    assetHolderAddress: allocation.assetHolderAddress,\n    allocationItems: allocation.allocationItems.map(serializeAllocationItem)\n  };\n}\n\nfunction serializeSimpleGuarantee(guarantee) {\n  return {\n    assetHolderAddress: guarantee.assetHolderAddress,\n    targetChannelId: guarantee.targetChannelId,\n    destinations: guarantee.destinations\n  };\n}\n\nfunction serializeAllocationItem(allocationItem) {\n  var destination = allocationItem.destination,\n      amount = allocationItem.amount;\n  return {\n    destination: destination,\n    amount: utils_1.formatAmount(amount)\n  };\n}","import {StateNodeConfig, DoneInvokeEvent, TransitionConfig} from 'xstate';\nexport function unreachable(x: never) {\n  return x;\n}\n\nexport const exists = <T>(t: T | undefined): t is T => !!t;\n\nconst throwError = (fn: (t1: any) => boolean, t) => {\n  throw new Error(`not valid, ${fn.name} failed on ${t}`);\n};\ntype TypeGuard<T, S> = (t1: T | S) => t1 is T;\nexport function checkThat<T, S = undefined>(t: T | S, isTypeT: TypeGuard<T, S>): T {\n  if (!isTypeT(t)) {\n    throwError(isTypeT, t);\n    // Typescrypt doesn't know that throwError throws an error.\n    throw 'Unreachable';\n  }\n  return t;\n}\n\ntype Opts<T> = {\n  onDone?: string | TransitionConfig<T, any>;\n  id?: string;\n  onError?: string | TransitionConfig<T, any>;\n  entry?: string;\n  exit?: string;\n};\nexport function getDataAndInvoke<T, Services extends string = string>(\n  data: {src: Services; opts?: Opts<T>},\n  service: {src: Services; opts?: Opts<T>},\n  onDone?: string | TransitionConfig<T, any> | TransitionConfig<T, any>[]\n): StateNodeConfig<T, any, DoneInvokeEvent<T>> {\n  return {\n    initial: data.src,\n    states: {\n      [data.src]: {invoke: {src: data.src, onDone: service.src, onError: data.opts?.onError}},\n      [service.src]: {\n        invoke: {\n          id: service?.opts?.id,\n          src: service.src,\n          data: (_, {data}: DoneInvokeEvent<T>) => data,\n          onDone: 'done',\n          onError: service.opts?.onError\n        },\n        entry: service.opts?.entry\n      },\n      done: {type: 'final'}\n    },\n    onDone\n  };\n}\n\nexport function arrayToRecord<T, K extends keyof T>(\n  array: Array<T>,\n  idProperty: K\n): Record<string | number, T> {\n  return array.reduce((obj, item) => {\n    obj[item[idProperty]] = item;\n    return obj;\n  }, {} as any);\n}\n\nexport function recordToArray<T>(record: Record<string | number, T | undefined>): Array<T> {\n  return Object.keys(record)\n    .map(k => record[k])\n    .filter(e => e !== undefined) as Array<T>;\n}\n","import {AddressZero} from '@ethersproject/constants';\nimport {Destination} from '@statechannels/wallet-core';\n\n// TODO: Use getEnvBool from devtools once working\nfunction getBool(val: string | undefined): boolean {\n  switch (val) {\n    case undefined:\n    case null:\n    case 'null':\n    case 'false':\n    case 'FALSE':\n    case '0':\n      return false;\n    default:\n      return true;\n  }\n}\n\nexport const GIT_VERSION = process.env.GIT_VERSION;\n\nexport const NODE_ENV: string = process.env.NODE_ENV as string;\n\nexport const CHAIN_NETWORK_ID: string = process.env.CHAIN_NETWORK_ID || '0';\n\nexport const INFURA_API_KEY: string | undefined = process.env.INFURA_API_KEY;\n\nexport const CLEAR_STORAGE_ON_START = getBool(process.env.CLEAR_STORAGE_ON_START);\n\nexport const ETH_ASSET_HOLDER_ADDRESS: string = process.env.ETH_ASSET_HOLDER_ADDRESS || AddressZero;\n\nexport const HUB_PARTICIPANT_ID = 'firebase:simple-hub';\n\nexport const HUB_ADDRESS: string =\n  process.env.HUB_ADDRESS || '0xaaaa84838319627Fa056fC3FC29ab94d479B8502';\n\nif (!process.env.HUB_DESTINATION) {\n  throw new Error('HUB_DESTINATION environment variable must be defined');\n}\nexport const HUB_DESTINATION = process.env.HUB_DESTINATION as Destination;\n\nexport const LOG_DESTINATION: string | undefined = process.env.LOG_DESTINATION\n  ? process.env.LOG_DESTINATION === 'console'\n    ? 'console'\n    : `${process.env.LOG_DESTINATION}/wallet.log`\n  : undefined;\n\nexport const NITRO_ADJUDICATOR_ADDRESS: string =\n  process.env.NITRO_ADJUDICATOR_ADDRESS || AddressZero;\n\nexport const TRIVIAL_APP_ADDRESS: string = process.env.TRIVIAL_APP_ADDRESS || AddressZero;\n\nexport const USE_INDEXED_DB = getBool(process.env.USE_INDEXED_DB);\n\nexport const CHALLENGE_DURATION = Number(process.env.CHALLENGE_DURATION || 300);\n\nexport const JEST_WORKER_ID: string | undefined = process.env.JEST_WORKER_ID;\n\nexport const ADD_LOGS = !!LOG_DESTINATION;\nexport const LOG_LEVEL = ADD_LOGS\n  ? process.env.LOG_LEVEL\n    ? process.env.LOG_LEVEL\n    : 'info'\n  : 'silent';\n\nexport const HUB = {\n  destination: HUB_DESTINATION,\n  signingAddress: HUB_ADDRESS,\n  participantId: 'firebase:simple-hub'\n};\n\nexport const TARGET_NETWORK = process.env.TARGET_NETWORK || 'development';\nexport const FAUCET_LINK =\n  TARGET_NETWORK === 'goerli' ? 'https://goerli-faucet.slock.it/' : 'https://faucet.ropsten.be/';\n","import {Contract} from 'ethers';\nimport {ContractArtifacts} from '@statechannels/nitro-protocol';\n\nimport {ETH_ASSET_HOLDER_ADDRESS, INFURA_API_KEY, TARGET_NETWORK} from '../config';\nimport {providers} from 'ethers';\n\nlet provider: providers.Web3Provider | providers.JsonRpcProvider;\n\nexport function getProvider(): providers.Web3Provider | providers.JsonRpcProvider {\n  if (provider) return provider;\n\n  if (window.ethereum) {\n    if (window.ethereum.mockingInfuraProvider) {\n      provider = new providers.InfuraProvider(TARGET_NETWORK, INFURA_API_KEY);\n    } else {\n      // https://github.com/ethers-io/ethers.js/issues/861#issuecomment-638031278\n      provider = new providers.Web3Provider(window.ethereum, 'any');\n      provider.on('network', (_, oldNetwork) => {\n        // When a Provider makes its initial connection, it emits a \"network\"\n        // event with a null oldNetwork along with the newNetwork. So, if the\n        // oldNetwork exists, it represents a changing network\n        if (oldNetwork) {\n          window.location.reload();\n        }\n      });\n    }\n  } else {\n    provider = new providers.JsonRpcProvider(`http://localhost:${process.env.GANACHE_PORT}`);\n  }\n\n  return provider;\n}\n\nexport function getEthAssetHolderContract() {\n  const provider = getProvider();\n  return new Contract(\n    ETH_ASSET_HOLDER_ADDRESS || '0x00',\n    ContractArtifacts.EthAssetHolderArtifact['abi'],\n    provider\n  );\n}\n","/* eslint-disable no-console */\nimport pino from 'pino';\nimport _ from 'lodash';\n\nimport {LOG_DESTINATION, ADD_LOGS, JEST_WORKER_ID, LOG_LEVEL} from './config';\n\nconst IS_BROWSER_CONTEXT = JEST_WORKER_ID === undefined;\n\nconst LOG_TO_CONSOLE = LOG_DESTINATION === 'console';\nconst LOG_TO_FILE = ADD_LOGS && !LOG_TO_CONSOLE;\n\nconst name = 'xstate-wallet';\n\nconst destination =\n  LOG_TO_FILE && !IS_BROWSER_CONTEXT ? pino.destination(LOG_DESTINATION) : undefined;\n\nconst postMessageAndCallConsoleFn = (consoleFn: {\n  (message?: any, ...optionalParams: any[]): void;\n}) => (o: any) => {\n  const withName = JSON.stringify({...o, name});\n\n  // The simplest way to give users/developers easy access to the logs in a single place is to\n  // make the application aware of all the pino logs via postMessage\n  // Then, the application can package up all the logs into a single file\n  window.parent.postMessage({type: 'PINO_LOG', logEvent: JSON.parse(withName)}, '*');\n  if (LOG_TO_FILE) consoleFn(withName);\n  else consoleFn(o.msg, _.omit(o, 'msg'));\n};\n\nconst browser: any = IS_BROWSER_CONTEXT\n  ? {\n      write: {\n        error: postMessageAndCallConsoleFn(console.error),\n        warn: postMessageAndCallConsoleFn(console.warn),\n        info: postMessageAndCallConsoleFn(console.info),\n        debug: postMessageAndCallConsoleFn(console.debug),\n        // Firefox & chrome automatically expand trace calls, which is pretty annoying.\n        // So, we direct trace calls to console.debug instead.\n        trace: postMessageAndCallConsoleFn(console.debug)\n      }\n    }\n  : undefined;\n\nconst prettyPrint = LOG_TO_CONSOLE ? {translateTime: true} : false;\n\nconst level = window.localStorage.LOG_LEVEL ?? LOG_LEVEL;\nconst opts = {name, prettyPrint, browser, level};\nconst logger = destination ? pino(opts, destination) : pino(opts);\nlogger.on('level-change', (lvl, val, prevLvl, prevVal) => {\n  console.log('wallet: %s (%d) was changed to %s (%d)', lvl, val, prevLvl, prevVal);\n});\n\nwindow.addEventListener('message', event => {\n  const key = 'LOG_LEVEL';\n\n  if (event.data.type === 'SET_LOG_LEVEL') {\n    const {level} = event.data;\n    console.log(`wallet: level CHANGED from ${logger.level} to ${level}`);\n    window.localStorage.setItem(key, level);\n    logger.level = level;\n  } else if (event.data.type === 'CLEAR_LOG_LEVEL') {\n    console.log(`wallet: level CLEARED from ${logger.level} to ${LOG_LEVEL}`);\n    window.localStorage.removeItem(key);\n    logger.level = LOG_LEVEL;\n  }\n});\n\nexport {logger};\n","import {\n  ContractArtifacts,\n  createETHDepositTransaction,\n  Transactions,\n  getChallengeRegisteredEvent,\n  ChallengeRegisteredEvent,\n  SignedState as NitroSignedState\n} from '@statechannels/nitro-protocol';\nimport {\n  BN,\n  State,\n  SignedState,\n  fromNitroState,\n  toNitroSignedState,\n  calculateChannelId,\n  Zero,\n  Uint256\n} from '@statechannels/wallet-core';\nimport {Contract, Wallet, utils, providers} from 'ethers';\nimport {Observable, fromEvent, from, merge, interval} from 'rxjs';\nimport {filter, map, flatMap, distinctUntilChanged} from 'rxjs/operators';\nimport {hexZeroPad} from '@ethersproject/bytes';\nimport EventEmitter from 'eventemitter3';\n\nimport {getProvider} from './utils/contract-utils';\nimport {ETH_ASSET_HOLDER_ADDRESS, NITRO_ADJUDICATOR_ADDRESS} from './config';\nimport {logger} from './logger';\n\nexport interface ChannelChainInfo {\n  readonly amount: Uint256;\n  readonly channelStorage: {\n    turnNumRecord: number;\n    finalizesAt: number;\n    /* fingerprint: string */\n  };\n  readonly finalized: boolean; // this is a check on 0 < finalizesAt <= now\n  readonly blockNum: number; // blockNum that the information is from\n}\n\nexport interface Chain {\n  // Properties\n  ethereumIsEnabled: boolean;\n  selectedAddress: string | null;\n\n  // Feeds\n  chainUpdatedFeed: (channelId: string) => Observable<ChannelChainInfo>;\n  challengeRegisteredFeed: (channelId: string) => Observable<ChallengeRegistered>;\n\n  // Setup / Web3 Specific\n  ethereumEnable: () => Promise<string>;\n  initialize(): Promise<void>;\n\n  // Chain Methods\n  getBlockNumber: () => Promise<number>;\n  deposit: (channelId: string, expectedHeld: string, amount: string) => Promise<string | undefined>;\n  challenge: (support: SignedState[], privateKey: string) => Promise<string | undefined>;\n  finalizeAndWithdraw: (finalizationProof: SignedState[]) => Promise<string | undefined>;\n  getChainInfo: (channelId: string) => Promise<ChannelChainInfo>;\n  balanceUpdatedFeed(address: string): Observable<Uint256>;\n}\n\ntype Updated = ChannelChainInfo & {channelId: string};\n\ntype ChallengeRegistered = {channelId: string; challengeState: State; challengeExpiry: number};\n// type ChallengeCleared = {channelId: string};\n// type Concluded = {channelId: string};\n\nexport class FakeChain implements Chain {\n  private blockNumber = 1;\n  private channelStatus: Record<string, ChannelChainInfo> = {};\n  private eventEmitter: EventEmitter<{\n    updated: [Updated];\n    // TODO: Add AssetHolder events\n    challengeRegistered: [ChallengeRegistered];\n    // [CHALLENGE_CLEARED]: [ChallengeCleared];\n    // [CONCLUDED]: [Concluded];\n  }> = new EventEmitter();\n\n  private fakeSelectedAddress: string;\n\n  public async initialize() {\n    /* NOOP */\n  }\n\n  public async getBlockNumber() {\n    return this.blockNumber;\n  }\n\n  public setBlockNumber(blockNumber: number) {\n    this.blockNumber = blockNumber;\n\n    for (const channelId in this.channelStatus) {\n      const {\n        channelStorage: {finalizesAt}\n      } = this.channelStatus[channelId];\n      // FIXME: shouldn't this be block timestamp?\n      if (finalizesAt > 0 && finalizesAt <= blockNumber) {\n        this.channelStatus[channelId] = {...this.channelStatus[channelId], finalized: true};\n        this.eventEmitter.emit('updated', {channelId, ...this.channelStatus[channelId]});\n      }\n    }\n  }\n\n  public async deposit(channelId: string, expectedHeld: string, amount: string) {\n    this.depositSync(channelId, expectedHeld, amount);\n    return 'fake-transaction-id';\n  }\n\n  public async challenge(support: SignedState[]): Promise<string> {\n    const channelId = calculateChannelId(support[0]);\n\n    const {turnNum, challengeDuration} = support[support.length - 1];\n\n    this.channelStatus[channelId] = {\n      ...(this.channelStatus[channelId] || {}),\n      channelStorage: {\n        turnNumRecord: turnNum,\n        finalizesAt: this.blockNumber + challengeDuration\n      },\n      finalized: challengeDuration === 0\n    };\n\n    this.eventEmitter.emit('updated', {channelId, ...this.channelStatus[channelId]});\n\n    this.eventEmitter.emit('challengeRegistered', {\n      channelId,\n      challengeState: support[support.length - 1],\n      challengeExpiry: this.blockNumber + challengeDuration\n    });\n\n    return 'fake-transaction-id';\n  }\n\n  public async finalizeAndWithdraw(finalizationProof: SignedState[]): Promise<string | undefined> {\n    const channelId = calculateChannelId(finalizationProof[0]);\n    this.finalizeSync(channelId);\n\n    this.channelStatus[channelId] = {\n      ...this.channelStatus[channelId],\n      amount: Zero,\n      blockNum: this.blockNumber\n    };\n\n    this.eventEmitter.emit('updated', {\n      ...this.channelStatus[channelId],\n      channelId,\n      blockNum: this.blockNumber\n    });\n    return;\n  }\n\n  public finalizeSync(channelId: string, turnNum = 0) {\n    this.channelStatus[channelId] = {\n      ...(this.channelStatus[channelId] || {}),\n      channelStorage: {\n        turnNumRecord: turnNum,\n        finalizesAt: this.blockNumber\n      }\n    };\n  }\n\n  public depositSync(channelId: string, expectedHeld: string, amount: string) {\n    const current = (this.channelStatus[channelId] || {}).amount || Zero;\n\n    if (BN.gte(current, expectedHeld)) {\n      this.channelStatus[channelId] = {\n        ...this.channelStatus[channelId],\n        amount: BN.add(current, amount)\n      };\n      this.eventEmitter.emit('updated', {\n        ...this.channelStatus[channelId],\n        channelId\n      });\n    }\n  }\n\n  public async getChainInfo(channelId: string): Promise<ChannelChainInfo> {\n    const {amount, channelStorage} = this.channelStatus[channelId] || {};\n    return {\n      channelStorage: channelStorage || {\n        turnNumRecord: 0,\n        finalizesAt: 0\n      },\n      finalized:\n        channelStorage &&\n        channelStorage.finalizesAt > 0 &&\n        channelStorage.finalizesAt <= this.blockNumber,\n      blockNum: this.blockNumber,\n      amount: amount || Zero\n    };\n  }\n\n  public chainUpdatedFeed(channelId: string): Observable<ChannelChainInfo> {\n    const first = from(this.getChainInfo(channelId));\n\n    const updates = fromEvent(this.eventEmitter, 'updated').pipe(\n      filter((event: Updated) => event.channelId === channelId),\n      map(({amount, channelStorage, finalized, blockNum: blockNum}) => ({\n        amount,\n        channelStorage,\n        finalized,\n        blockNum\n      }))\n    );\n\n    return merge(first, updates);\n  }\n  public balanceUpdatedFeed(): Observable<Uint256> {\n    // You're rich!\n    return from([BN.from('0x999999999999')]);\n  }\n  public challengeRegisteredFeed(channelId: string): Observable<ChallengeRegistered> {\n    const updates = fromEvent(this.eventEmitter, 'challengeRegistered').pipe(\n      filter((event: ChallengeRegistered) => event.channelId === channelId),\n      map(({challengeState, challengeExpiry}) => ({\n        channelId,\n        challengeState,\n        challengeExpiry\n      }))\n    );\n\n    return merge(\n      /* first */ // TODO: It is not possible to get the \"first\" event because we have no \"replay\" functionality\n      updates\n    );\n  }\n\n  public ethereumEnable() {\n    this.fakeSelectedAddress = hexZeroPad('0x123', 32);\n    return Promise.resolve(this.selectedAddress);\n  }\n\n  public get ethereumIsEnabled() {\n    return true;\n  }\n\n  public get selectedAddress() {\n    return this.fakeSelectedAddress;\n  }\n}\n\nconst chainLogger = logger.child({module: 'chain'});\n// Sets a default of gas price 15 Gwei which is more than enough to get picked up in goerli\n// This prevents issues with metamask incorrectly estimating 0 gas\nconst GAS_PRICE = utils.parseUnits('15', 'gwei');\nexport class ChainWatcher implements Chain {\n  private _adjudicator?: Contract;\n  private _assetHolders: Contract[];\n  private mySelectedAddress: string | null = window.ethereum?.selectedAddress ?? null;\n  private provider: ReturnType<typeof getProvider>;\n  private get signer() {\n    if (!this.ethereumIsEnabled) throw new Error('Ethereum not enabled');\n\n    if (window.ethereum.mockingInfuraProvider) {\n      return new Wallet(\n        '0xccb052837ccafb700e34c0e0cc0f3e5fbee8f078f3fe6b4e5950c7c8acaa7bce',\n        this.provider\n      );\n    }\n\n    return this.provider.getSigner(this.selectedAddress as string);\n  }\n\n  public async initialize() {\n    this.provider = getProvider();\n\n    this.provider.on('block', blockNumber => chainLogger.trace({blockNumber}, 'New Block'));\n\n    this.configureContracts();\n  }\n\n  private configureContracts() {\n    if (!this.ethereumIsEnabled) return;\n\n    this._assetHolders = [\n      new Contract(\n        ETH_ASSET_HOLDER_ADDRESS,\n        ContractArtifacts.EthAssetHolderArtifact.abi,\n        this.signer\n      )\n    ];\n\n    // Log all contract events (for now)\n    this._assetHolders[0].on('*', event => chainLogger.trace({event}, 'assetHolder[0] event'));\n\n    this._adjudicator = new Contract(\n      NITRO_ADJUDICATOR_ADDRESS,\n      ContractArtifacts.NitroAdjudicatorArtifact.abi,\n      this.signer\n    );\n\n    chainLogger.info(\n      {\n        ETH_ASSET_HOLDER_ADDRESS,\n        NITRO_ADJUDICATOR_ADDRESS,\n        numAssetHolders: this._assetHolders.length\n      },\n      'Contracts configured'\n    );\n  }\n\n  public async getBlockNumber() {\n    return this.provider.getBlockNumber();\n  }\n\n  public async ethereumEnable(): Promise<string> {\n    if (window.ethereum) {\n      try {\n        this.mySelectedAddress = (await window.ethereum.enable())[0];\n        if (this.ethereumIsEnabled) {\n          this.configureContracts();\n          return this.selectedAddress as string;\n        } else {\n          const error = 'Ethereum enabled but no selected address is defined';\n          chainLogger.error(error);\n          return Promise.reject(error);\n        }\n      } catch (error) {\n        // TODO: Handle error. Likely the user rejected the login\n        chainLogger.error(error);\n        return Promise.reject('user rejected in metamask');\n      }\n    } else {\n      return Promise.reject('window.ethereum not found');\n    }\n  }\n\n  public get selectedAddress(): string | null {\n    if (this.mySelectedAddress === null && window && window.ethereum) {\n      this.mySelectedAddress = window.ethereum.selectedAddress ?? null;\n    }\n    return this.mySelectedAddress;\n  }\n\n  public get ethereumIsEnabled(): boolean {\n    return typeof this.selectedAddress === 'string';\n  }\n\n  public async finalizeAndWithdraw(finalizationProof: SignedState[]): Promise<string | undefined> {\n    const transactionRequest = {\n      ...Transactions.createConcludePushOutcomeAndTransferAllTransaction(\n        finalizationProof.flatMap(toNitroSignedState)\n      ),\n      to: NITRO_ADJUDICATOR_ADDRESS\n    };\n\n    const response = await this.signer.sendTransaction({\n      ...convertNitroTransactionRequest(transactionRequest),\n      gasPrice: GAS_PRICE\n    });\n    return response.hash;\n  }\n\n  public async challenge(support: SignedState[], privateKey: string): Promise<string | undefined> {\n    const convertedSignedStates = support\n      .reduce(\n        (previous, current) => previous.concat(toNitroSignedState(current)),\n        new Array<NitroSignedState>()\n      )\n      .sort((s1, s2) => s1.state.turnNum - s2.state.turnNum);\n    const transactionRequest = {\n      ...Transactions.createForceMoveTransaction(\n        convertedSignedStates,\n        // createForceMoveTransaction requires this to sign a \"challenge message\"\n        privateKey\n      ),\n      to: NITRO_ADJUDICATOR_ADDRESS\n    };\n    const response = await this.signer.sendTransaction({\n      ...convertNitroTransactionRequest(transactionRequest),\n      gasPrice: GAS_PRICE\n    });\n    const tx = await response.wait();\n    return tx.transactionHash;\n  }\n\n  public async deposit(\n    channelId: string,\n    expectedHeld: string,\n    amount: string\n  ): Promise<string | undefined> {\n    const transactionRequest = {\n      ...createETHDepositTransaction(channelId, expectedHeld, amount),\n      to: ETH_ASSET_HOLDER_ADDRESS,\n      value: amount\n    };\n    const response = await this.signer.sendTransaction({\n      ...convertNitroTransactionRequest(transactionRequest),\n      gasPrice: GAS_PRICE\n    });\n\n    chainLogger.trace({response}, 'Deposit successful from %s', response.from);\n    return response.hash;\n  }\n\n  public async getChainInfo(channelId: string): Promise<ChannelChainInfo> {\n    if (!this._assetHolders || !this._assetHolders[0] || !this._adjudicator) {\n      throw new Error('Not connected to contracts');\n    }\n    const ethAssetHolder = this._assetHolders[0];\n\n    const amount: Uint256 = BN.from(await ethAssetHolder.holdings(channelId));\n\n    const [turnNumRecord, finalizesAt]: [\n      number,\n      number\n    ] = await this._adjudicator.getChannelStorage(channelId);\n\n    const blockNum = await this.provider.getBlockNumber();\n    chainLogger.trace(\n      {\n        amount,\n        channelStorage: {\n          turnNumRecord,\n          finalizesAt\n        },\n        finalized: BN.gt(finalizesAt, 0) && BN.lte(finalizesAt, blockNum),\n        blockNum\n      },\n      'Chain query result'\n    );\n    // TODO: Fetch other info\n    return {\n      amount,\n      channelStorage: {\n        turnNumRecord,\n        finalizesAt\n      },\n      finalized: BN.gt(finalizesAt, 0) && BN.lte(finalizesAt, blockNum),\n      blockNum\n    };\n  }\n\n  public balanceUpdatedFeed(address: string): Observable<Uint256> {\n    const first = from(this.provider.getBalance(address).then(BN.from));\n    const updates = fromEvent<Uint256>(this.provider, 'block').pipe(\n      flatMap(() => this.provider.getBalance(address))\n    );\n\n    return merge(first, updates).pipe(distinctUntilChanged<Uint256>(BN.eq));\n  }\n\n  public chainUpdatedFeed(channelId: string): Observable<ChannelChainInfo> {\n    if (!this._assetHolders || !this._assetHolders[0] || !this._adjudicator) {\n      throw new Error('Not connected to contracts');\n    }\n\n    const polledData = interval(5000).pipe(flatMap(() => this.getChainInfo(channelId)));\n\n    const depositEvents = fromEvent(this._assetHolders[0], 'Deposited').pipe(\n      // TODO: Type event correctly, use ethers-utils.js\n      filter((event: Array<any>) => BN.eq(event[0], channelId)),\n      // TODO: Currently it seems that getChainInfo can return stale information\n      // so as a workaround we use the amount from the event\n      // see https://github.com/statechannels/monorepo/issues/1995\n      flatMap(async event => ({\n        ...(await this.getChainInfo(channelId)),\n        amount: BN.from(event.slice(-1)[0].args.destinationHoldings)\n      }))\n    );\n\n    const assetTransferEvents = fromEvent(this._assetHolders[0], 'AssetTransferred').pipe(\n      // TODO: Type event correctly, use ethers-utils.js\n      filter((event: Array<string | Uint256>) => BN.eq(event[0], channelId)),\n      // Actually ignores the event data and just polls the chain\n      flatMap(async () => this.getChainInfo(channelId))\n    );\n\n    return merge(polledData, depositEvents, assetTransferEvents);\n  }\n\n  public challengeRegisteredFeed(channelId: string): Observable<ChallengeRegistered> {\n    if (!this._adjudicator) {\n      throw new Error('Not connected to contracts');\n    }\n\n    const updates = fromEvent(this._adjudicator, 'ChallengeRegistered').pipe(\n      filter((event: any) => event[0] === channelId), // index 0 of ChallengeRegistered event is channelId\n      map(getChallengeRegisteredEvent),\n      map(({challengeStates, finalizesAt}: ChallengeRegisteredEvent) => ({\n        channelId,\n        challengeState: fromNitroState(challengeStates[challengeStates.length - 1].state),\n        challengeExpiry: finalizesAt\n      }))\n    );\n\n    return merge(\n      /* first */ // TODO: We cannot have a first because we can't \"replay\" events yet\n      updates\n    );\n  }\n}\n\n// Since nitro-protocol is still using v4 of ethers we need to convert any bignumbers the v5 version from ethers\n// TODO: Remove this when nitro protocol is using v5 ethers\nfunction convertNitroTransactionRequest(nitroTransactionRequest): providers.TransactionRequest {\n  return {\n    ...nitroTransactionRequest,\n    gasLimit: nitroTransactionRequest.gasLimit\n      ? BN.from(nitroTransactionRequest.gasLimit)\n      : undefined,\n    gasPrice: nitroTransactionRequest.gasPrice\n      ? BN.from(nitroTransactionRequest.gasPrice)\n      : undefined,\n    nonce: nitroTransactionRequest.nonce ? BN.from(nitroTransactionRequest.nonce) : undefined,\n    value: nitroTransactionRequest.value ? BN.from(nitroTransactionRequest.value) : undefined\n  };\n}\n","// TODO: Why do we need these things in src?\nexport const ETH_TOKEN = '0x0000000000000000000000000000000000000000';\nexport const MOCK_TOKEN = '0x1000000000000000000000000000000000000001'; // Use in serde test\nexport const MOCK_ASSET_HOLDER_ADDRESS = '0x1111111111111111111111111111111111111111';\n\nexport const CONCLUDE_TIMEOUT = 30_000;\n\nexport const DB_NAME = 'xstatewallet';\n","import {\n  Objective,\n  ChannelStoredData,\n  DomainBudget,\n  StateVariables\n} from '@statechannels/wallet-core';\nimport {filter, map} from 'rxjs/operators';\n\nimport {Store} from './store';\nimport {ChannelStoreEntry} from './channel-store-entry';\n\nexport {Store} from './store';\n\n// TODO: Move to somewhere better?\nexport function supportedStateFeed(store: Store, channelId: string) {\n  return store.channelUpdatedFeed(channelId).pipe(\n    filter(e => !!e.supported),\n    map(e => ({state: {...e.channelConstants, ...(e.supported as StateVariables)}}))\n  );\n}\n\nexport enum Errors {\n  duplicateTurnNums = 'multiple states with same turn number',\n  notSorted = 'states not sorted',\n  multipleSignedStates = 'Store signed multiple states for a single turn',\n  staleState = 'Attempting to sign a stale state',\n  channelMissing = 'No channel found with id.',\n  channelFunded = 'Channel already funded.',\n  channelLocked = 'Channel is locked',\n  noBudget = 'No budget exists for domain. ',\n  noAssetBudget = \"This domain's budget does contain this asset\",\n  channelNotInBudget = \"This domain's budget does not reference this channel\",\n  noDomainForChannel = 'No domain defined for channel',\n  domainExistsOnChannel = 'Channel already has a domain.',\n  budgetAlreadyExists = 'There already exists a budget for this domain',\n  budgetInsufficient = 'Budget insufficient to reserve funds',\n  amountUnauthorized = 'Amount unauthorized in current budget',\n  cannotFindDestination = 'Cannot find destination for participant',\n  cannotFindPrivateKey = 'Private key missing for your address',\n  notInChannel = 'Attempting to initialize  channel as a non-participant',\n  noLedger = 'No ledger exists with peer',\n  amountNotFound = 'Cannot find allocation entry with destination',\n  invalidNonce = 'Invalid nonce',\n  invalidTransition = 'Invalid transition',\n  invalidAppData = 'Invalid app data',\n  emittingDuringTransaction = 'Attempting to emit event during transaction',\n  notMyTurn = \"Cannot update channel unless it's your turn\"\n}\n\nexport interface DBBackend {\n  initialize(cleanSlate: boolean, name: string): Promise<any>;\n\n  // TODO: Perhaps the backend API should look more like this?\n  // privateKeys(): Promise<Array<{signingAddress: string; privateKey: string}>>;\n  privateKeys(): Promise<Record<string, string | undefined>>;\n  ledgers(): Promise<Record<string, string | undefined>>;\n  nonces(): Promise<Record<string, number | undefined>>;\n  objectives(): Promise<Objective[]>;\n  channels(): Promise<Record<string, ChannelStoreEntry | undefined>>;\n\n  setDestinationAddress(destinationAddress: string): Promise<string>;\n  getDestinationAddress(): Promise<string | undefined>;\n\n  setPrivateKey(key: string, value: string): Promise<string>;\n  getPrivateKey(key: string): Promise<string | undefined>;\n\n  setChannel(key: string, value: ChannelStoredData): Promise<ChannelStoredData>;\n  getChannel(key: string): Promise<ChannelStoreEntry | undefined>;\n\n  getBudget(key: string): Promise<DomainBudget | undefined>;\n  setBudget(key: string, budget: DomainBudget): Promise<DomainBudget>;\n  deleteBudget(key: string): Promise<void>;\n\n  setLedger(key: string, value: string): Promise<string>;\n  getLedger(key: string): Promise<string | undefined>;\n\n  setNonce(key: string, value: number): Promise<number>;\n  getNonce(key: string): Promise<number | undefined>;\n\n  setObjective(key: number, value: Objective): Promise<Objective>;\n  getObjective(key: number): Promise<Objective | undefined>;\n\n  /**\n   * Starts an async database transaction.\n   *\n   * When mode is 'readwrite', acquires a lock on each store listed in stores param.\n   *\n   * dexie backend rejects with 'NotFoundError: TableX not part of transaction', if cb\n   * attempts to use table not listed by stores param.\n   *\n   * Rejects if tx.abort() is called.\n   *\n   * @param mode\n   * @param stores array of ObjectStore names usd in cb\n   * @param cb callback to execute within transaction scope\n   * @returns promise resolving to return value of cb\n   */\n  transaction<T, S extends ObjectStores>(\n    mode: TXMode,\n    stores: S[],\n    cb: (tx: Transaction) => Promise<T>\n  ): Promise<T>;\n  transactionOngoing: boolean;\n}\n\nexport type Transaction = {\n  abort(): void;\n  // TODO: We could expose a store function on the transaction and\n  // potentially do away with the individual getters on the backend interface\n  // EG:\n  // store<S extends Stores>(s: S): ObjectStore<S>;\n  // Or, we could just expose direct properties, like\n  // channels(): Table<ChannelRecord>\n};\n\nexport type TXMode = 'readonly' | 'readwrite';\n\nexport const enum ObjectStores {\n  channels = 'channels',\n  objectives = 'objectives',\n  nonces = 'nonces',\n  privateKeys = 'privateKeys',\n  destinationAddress = 'destinationAddress',\n  ledgers = 'ledgers',\n  budgets = 'budgets'\n}\n\ndeclare global {\n  interface Window {\n    channelProvider: import('@statechannels/iframe-channel-provider').ChannelProviderInterface;\n    ethereum: any;\n  }\n}\n","import * as _ from 'lodash';\nimport {Objective, DomainBudget, ChannelStoredData} from '@statechannels/wallet-core';\n\nimport {ChannelStoreEntry} from './channel-store-entry';\n\nimport {DBBackend, ObjectStores, TXMode} from '.';\n\nexport class MemoryBackend implements DBBackend {\n  private _channels: Record<string, ChannelStoredData | undefined> = {};\n  private _objectives: Objective[] = [];\n  private _nonces: Record<string, number | undefined> = {};\n  private _destinationAddress: string | undefined;\n  private _privateKeys: Record<string, string | undefined> = {};\n  private _ledgers: Record<string, string | undefined> = {};\n  private _budgets: Record<string, DomainBudget | undefined> = {};\n\n  public async initialize(cleanSlate = false) {\n    if (cleanSlate) {\n      this._channels = {};\n      this._objectives = [];\n      this._nonces = {};\n      this._privateKeys = {};\n      this._ledgers = {};\n      this._budgets = {};\n    }\n  }\n  // Generic Getters\n\n  public async privateKeys() {\n    return _.cloneDeep(this._privateKeys);\n  }\n  public async ledgers() {\n    return _.cloneDeep(this._ledgers);\n  }\n  public async objectives() {\n    return _.cloneDeep(this._objectives);\n  }\n  public async channels() {\n    const channelsData: Record<string, ChannelStoredData | undefined> = _.cloneDeep(this._channels);\n    const channels = {};\n    for (const channelId of Object.keys(channelsData)) {\n      channels[channelId] = new ChannelStoreEntry(channelsData[channelId] as ChannelStoredData);\n    }\n\n    return channels as Record<string, ChannelStoreEntry | undefined>;\n  }\n  public async nonces() {\n    const nonces: Record<string, number | undefined> = this._nonces;\n    for (const key in nonces) {\n      if (!this._nonces[key]) {\n        nonces[key] = -1;\n      }\n    }\n    return nonces;\n  }\n\n  // Individual Getters/setters\n  public async getBudget(key: string) {\n    return this._budgets[key];\n  }\n\n  public async setBudget(key: string, value: DomainBudget) {\n    this._budgets[key] = value;\n    return value;\n  }\n  public async deleteBudget(key: string) {\n    delete this._budgets[key];\n  }\n\n  public async setDestinationAddress(address: string) {\n    this._destinationAddress = address;\n    return address;\n  }\n\n  public async getDestinationAddress() {\n    return this._destinationAddress;\n  }\n\n  public async setPrivateKey(key: string, value: string) {\n    this._privateKeys[key] = value;\n    return value;\n  }\n\n  public async getPrivateKey(key: string) {\n    return this._privateKeys[key];\n  }\n\n  public async setChannel(key: string, value: ChannelStoredData) {\n    this._channels[key] = value;\n    return value;\n  }\n\n  public async getChannel(key: string) {\n    const data = this._channels[key];\n    if (!data) return;\n    else return new ChannelStoreEntry(data);\n  }\n\n  public async setLedger(key: string, value: string) {\n    this._ledgers[key] = value;\n    return value;\n  }\n\n  public async getLedger(key: string) {\n    return this._ledgers[key];\n  }\n\n  public async setNonce(key: string, value: number) {\n    return (this._nonces[key] = value);\n  }\n\n  public async getNonce(key: string) {\n    return this._nonces[key] ?? -1;\n  }\n\n  public async setObjective(key: number, value: Objective) {\n    this._objectives[key] = value;\n    return value;\n  }\n\n  public async getObjective(key: number) {\n    return this._objectives[key];\n  }\n\n  public async transaction<T>(_mode: TXMode, _stores: ObjectStores[], cb: (tx: any) => Promise<T>) {\n    return cb({abort: () => null});\n  }\n\n  public transactionOngoing = false;\n}\n","import {AddressZero} from '@ethersproject/constants';\nimport {EventEmitter} from 'eventemitter3';\nimport {filter, map, concatAll} from 'rxjs/operators';\nimport {Observable, fromEvent, merge, from, of} from 'rxjs';\nimport {Wallet} from 'ethers';\nimport * as _ from 'lodash';\nimport AsyncLock from 'async-lock';\nimport {\n  isSimpleEthAllocation,\n  calculateChannelId,\n  hashState,\n  Outcome,\n  ChannelStoredData,\n  Message,\n  Objective,\n  Participant,\n  SignedState,\n  DomainBudget,\n  State,\n  StateVariables,\n  SimpleAllocation,\n  Funding,\n  BN,\n  Uint256\n} from '@statechannels/wallet-core';\n\nimport {Chain, FakeChain} from '../chain';\nimport {CHAIN_NETWORK_ID, HUB} from '../config';\nimport {checkThat, recordToArray} from '../utils';\nimport {logger} from '../logger';\nimport {DB_NAME} from '../constants';\n\nimport {ChannelStoreEntry} from './channel-store-entry';\nimport {MemoryBackend} from './memory-backend';\n\nimport {Errors, DBBackend, ObjectStores} from '.';\n\ninterface InternalEvents {\n  channelUpdated: [ChannelStoreEntry];\n  newObjective: [Objective];\n  addToOutbox: [Message];\n  lockUpdated: [ChannelLock];\n}\nexport type ChannelLock = {\n  channelId: string;\n  release: () => void;\n};\n\n//FIXME\nconst track = _.noop;\nconst identify = _.noop;\n\nexport class Store {\n  protected backend: DBBackend = new MemoryBackend();\n  readonly chain: Chain;\n  private _eventEmitter = new EventEmitter<InternalEvents>();\n  private objectives: Objective[] = [];\n\n  constructor(chain?: Chain, backend?: DBBackend) {\n    // TODO: We shouldn't default to a fake chain\n    // but I didn't feel like updating all the constructor calls\n    this.chain = chain || new FakeChain();\n    this.chain.initialize();\n    if (backend) {\n      this.backend = backend;\n    }\n  }\n\n  public initialize = async (privateKeys?: string[], cleanSlate = false, dbName = DB_NAME) => {\n    await this.backend.initialize(cleanSlate, dbName);\n\n    await this.backend.transaction('readwrite', [ObjectStores.privateKeys], async () => {\n      const currentAddress = await this.getAddress();\n      let segmentId = currentAddress;\n\n      if (!privateKeys?.length && !currentAddress) {\n        // generate the first private key\n        const {privateKey} = Wallet.createRandom();\n        privateKeys = [privateKey];\n      }\n\n      await Promise.all(\n        privateKeys?.map(pk => this.backend.setPrivateKey(new Wallet(pk).address, pk)) || []\n      );\n\n      if (!segmentId) {\n        segmentId = await this.getAddress();\n        identify(segmentId);\n        track('created a wallet', {address: segmentId});\n      } else {\n        identify(segmentId);\n      }\n\n      track('initialized a wallet', {address: segmentId});\n    });\n  };\n\n  public getDestinationAddress = () => this.backend.getDestinationAddress();\n  public setDestinationAddress = (destinationAddress: string) => {\n    if (!destinationAddress) {\n      logger.error('destinationAddress being set to falsy value', destinationAddress);\n    }\n    return this.backend.setDestinationAddress(destinationAddress);\n  };\n\n  public async getBudget(domain: string): Promise<DomainBudget | undefined> {\n    return this.backend.getBudget(domain);\n  }\n\n  public channelUpdatedFeed(channelId: string): Observable<ChannelStoreEntry> {\n    // TODO: The following line is not actually type safe.\n    // fromEvent<'foo'>(this._eventEmitter, 'channelUpdated') would happily return\n    // Observable<'foo'>\n    const newEntries = fromEvent<ChannelStoreEntry>(this._eventEmitter, 'channelUpdated').pipe(\n      filter(cs => cs.channelId === channelId)\n    );\n\n    const currentEntry = from(this.backend.getChannel(channelId)).pipe(\n      filter<ChannelStoreEntry>(c => !!c)\n    );\n\n    return merge(currentEntry, newEntries);\n  }\n\n  get objectiveFeed(): Observable<Objective> {\n    const newObjectives = fromEvent<Objective>(this._eventEmitter, 'newObjective');\n    const currentObjectives = of(this.objectives).pipe(concatAll());\n\n    return merge(newObjectives, currentObjectives);\n  }\n\n  get outboxFeed(): Observable<Message> {\n    return fromEvent(this._eventEmitter, 'addToOutbox');\n  }\n\n  private initializeChannel = (\n    state: State,\n    applicationDomain?: string\n  ): Promise<ChannelStoreEntry> =>\n    this.backend.transaction(\n      'readwrite',\n      [ObjectStores.privateKeys, ObjectStores.nonces, ObjectStores.channels],\n      async () => {\n        const addresses = state.participants.map(x => x.signingAddress);\n        const privateKeys = await this.backend.privateKeys();\n        const myIndex = addresses.findIndex(address => !!privateKeys[address]);\n        if (myIndex === -1) throw Error(Errors.notInChannel);\n\n        await this.setNonce(addresses, state.channelNonce);\n\n        const data: ChannelStoredData = {\n          channelConstants: state,\n          stateVariables: [{...state, stateHash: hashState(state), signatures: []}],\n          myIndex,\n          funding: undefined,\n          applicationDomain\n        };\n\n        await this.backend.setChannel(calculateChannelId(state), data);\n        return new ChannelStoreEntry(data);\n      }\n    );\n\n  public setFunding = (channelId: string, funding: Funding) =>\n    this.backend.transaction('readwrite', [ObjectStores.channels], async () => {\n      const channelEntry = await this.getEntry(channelId);\n\n      if (channelEntry.funding) {\n        logger.error({funding: channelEntry.funding}, 'Channel %s already funded', channelId);\n        throw Error(Errors.channelFunded);\n      }\n      channelEntry.setFunding(funding);\n\n      await this.backend.setChannel(channelEntry.channelId, channelEntry.data());\n    });\n\n  private ledgerLock = new AsyncLock();\n  public async acquireChannelLock(channelId: string): Promise<ChannelLock> {\n    return new Promise(resolve =>\n      // TODO: Does this need a timeout?\n      this.ledgerLock.acquire(channelId, release => resolve({release, channelId}))\n    );\n  }\n\n  public getLedger = async (peerId: string) =>\n    this.backend.transaction(\n      'readonly',\n      [ObjectStores.ledgers, ObjectStores.channels],\n      async () => {\n        const ledgerId = await this.backend.getLedger(peerId);\n        if (!ledgerId) throw Error(Errors.noLedger + `: ${peerId}`);\n\n        return await this.getEntry(ledgerId);\n      }\n    );\n\n  public setapplicationDomain = (channelId: string, applicationDomain: string) =>\n    this.backend.transaction('readwrite', [ObjectStores.channels], async () => {\n      const entry = await this.getEntry(channelId);\n\n      if (typeof entry.applicationDomain === 'string') throw Error(Errors.domainExistsOnChannel);\n\n      await this.backend.setChannel(channelId, {...entry.data(), applicationDomain});\n    });\n\n  public setLedger = (ledgerId: string) =>\n    this.backend.transaction(\n      'readwrite',\n      [ObjectStores.ledgers, ObjectStores.channels, ObjectStores.privateKeys],\n      async () => {\n        const entry = await this.getEntry(ledgerId);\n\n        // This is not on the Store interface itself -- it is useful to set up a test store\n        await this.backend.setChannel(entry.channelId, entry.data());\n        const address = await this.getAddress();\n        const hub = entry.participants.find(p => p.signingAddress !== address) as Participant;\n        await this.backend.setLedger(hub.participantId, entry.channelId);\n      }\n    );\n\n  public getApplicationChannels = (applicationDomain: string, includeClosed = false) =>\n    this.backend.transaction('readonly', [ObjectStores.channels], async () =>\n      recordToArray(await this.backend.channels()).filter(\n        channel =>\n          !!channel &&\n          channel.applicationDomain === applicationDomain &&\n          (!channel.hasConclusionProof || includeClosed) &&\n          !BN.isZero(channel.channelConstants.appDefinition)\n      )\n    );\n\n  public createChannel = (\n    participants: Participant[],\n    challengeDuration: number,\n    stateVars: StateVariables,\n    appDefinition = AddressZero,\n    applicationDomain?: string\n  ) =>\n    this.backend\n      .transaction(\n        'readwrite',\n        [ObjectStores.privateKeys, ObjectStores.nonces, ObjectStores.channels],\n        async () => {\n          stateVars = _.pick(stateVars, 'outcome', 'turnNum', 'appData', 'isFinal');\n          const addresses = participants.map(x => x.signingAddress);\n          const privateKeys = await this.backend.privateKeys();\n          const myIndex = addresses.findIndex(address => !!privateKeys[address]);\n          if (myIndex === -1) {\n            throw Error(Errors.notInChannel);\n          }\n\n          const channelNonce = (await this.getNonce(addresses)) + 1;\n          const chainId = CHAIN_NETWORK_ID;\n\n          const entry = await this.initializeChannel(\n            {\n              chainId,\n              challengeDuration,\n              channelNonce,\n              participants,\n              appDefinition,\n              ...stateVars\n            },\n            applicationDomain\n          );\n          return this.signAndAddStateWithinTx(entry.channelId, stateVars);\n        }\n      )\n      .then(({entry, signedState}) => this.emitChannelUpdatedEventAfterTX(entry, signedState));\n\n  private async getNonce(addresses: string[]): Promise<number> {\n    return (await this.backend.getNonce(this.nonceKeyFromAddresses(addresses))) ?? -1;\n  }\n\n  private async setNonce(addresses: string[], value: number) {\n    if (value <= (await this.getNonce(addresses))) throw Error(Errors.invalidNonce);\n\n    await this.backend.setNonce(this.nonceKeyFromAddresses(addresses), value);\n  }\n\n  private nonceKeyFromAddresses = (addresses: string[]): string => addresses.join('::');\n\n  public async getPrivateKey(signingAddress: string): Promise<string> {\n    const ret = await this.backend.getPrivateKey(signingAddress);\n    if (!ret) throw Error(Errors.cannotFindPrivateKey);\n    return ret;\n  }\n\n  public updateChannel = (\n    channelId: string,\n    updateData: Partial<{outcome: SimpleAllocation; appData: string; isFinal: boolean}>\n  ) =>\n    this.backend\n      .transaction('readwrite', [ObjectStores.channels, ObjectStores.privateKeys], async () => {\n        const {supported: existingState, myTurn} = await this.getEntry(channelId);\n        if (!myTurn) {\n          logger.error({channelId, updateData, existingState}, 'Updating channel when not my turn');\n          throw Error(Errors.notMyTurn);\n        }\n\n        const newState = _.merge(existingState, {\n          turnNum: existingState.turnNum + 1,\n          ...updateData\n        });\n\n        return this.signAndAddStateWithinTx(channelId, newState);\n      })\n      .then(({entry, signedState}) => this.emitChannelUpdatedEventAfterTX(entry, signedState));\n\n  public signFinalState = (channelId: string) =>\n    this.backend\n      .transaction('readwrite', [ObjectStores.channels, ObjectStores.privateKeys], async () => {\n        const {supported, latestSignedByMe} = await this.getEntry(channelId);\n        if (!supported.isFinal) throw new Error('Supported state not final');\n        if (latestSignedByMe.turnNum === supported.turnNum) return; // already signed\n        return await this.signAndAddStateWithinTx(channelId, supported);\n      })\n      .then(result => {\n        if (result) this.emitChannelUpdatedEventAfterTX(result.entry, result.signedState);\n      });\n\n  private emitChannelUpdatedEventAfterTX(entry: ChannelStoreEntry, signedState?: SignedState) {\n    // These events trigger callbacks that should not run within the transaction scope\n    // See https://github.com/dfahlander/Dexie.js/issues/1029\n\n    if (this.backend.transactionOngoing) throw Error(Errors.emittingDuringTransaction);\n\n    this._eventEmitter.emit('channelUpdated', entry);\n    if (signedState) this._eventEmitter.emit('addToOutbox', {signedStates: [signedState]});\n\n    return entry;\n  }\n\n  public signAndAddState = (channelId: string, stateVars: StateVariables) =>\n    this.signAndAddStateWithinTx(channelId, stateVars).then(({entry, signedState}) =>\n      this.emitChannelUpdatedEventAfterTX(entry, signedState)\n    );\n\n  public supportState = (state: State) =>\n    this.backend\n      .transaction('readwrite', [ObjectStores.channels, ObjectStores.privateKeys], async () => {\n        const stateHash = hashState(state);\n        const channelId = calculateChannelId(state);\n        const entry = await this.getEntry(channelId);\n        const {isSupportedByMe} = entry;\n\n        // We only sign the state if we haven't signed it already\n        if (!isSupportedByMe || entry.latestSignedByMe.stateHash !== stateHash) {\n          return await this.signAndAddStateWithinTx(channelId, state);\n        } else {\n          // The support state machine was started with a state that we already support\n          // That's fine but we output a warning in case that's unexpected\n          logger.warn({state}, 'The state is already supported');\n          return;\n        }\n      })\n      .then(args => {\n        if (!args) return;\n        this.emitChannelUpdatedEventAfterTX(args.entry, args.signedState);\n      });\n\n  private signAndAddStateWithinTx = (channelId: string, stateVars: StateVariables) =>\n    this.backend.transaction(\n      'readwrite',\n      [ObjectStores.channels, ObjectStores.privateKeys],\n      async () => {\n        const entry = await this.getEntry(channelId);\n\n        const signedState = entry.signAndAdd(\n          _.pick(stateVars, 'outcome', 'turnNum', 'appData', 'isFinal'),\n          await this.getPrivateKey(entry.myAddress)\n        );\n        await this.backend.setChannel(channelId, entry.data());\n        return {entry, signedState};\n      }\n    );\n\n  async addObjective(objective: Objective, addToOutbox = true) {\n    const objectives = this.objectives;\n    if (!_.find(objectives, o => _.isEqual(o, objective))) {\n      this.objectives.push(objective);\n      addToOutbox && this._eventEmitter.emit('addToOutbox', {objectives: [objective]});\n      this._eventEmitter.emit('newObjective', objective);\n    }\n  }\n\n  public addState = (state: SignedState) =>\n    this.backend\n      .transaction(\n        'readwrite',\n        [ObjectStores.channels, ObjectStores.nonces, ObjectStores.privateKeys],\n        async () => {\n          const channelId = calculateChannelId(state);\n          const memoryChannelStorage =\n            (await this.backend.getChannel(channelId)) || (await this.initializeChannel(state));\n          // TODO: This is kind of awkward\n          state.signatures.forEach(sig => memoryChannelStorage.addState(state, sig));\n          await this.backend.setChannel(channelId, memoryChannelStorage.data());\n          return memoryChannelStorage;\n        }\n      )\n      .then(entry => this.emitChannelUpdatedEventAfterTX(entry));\n\n  public async getAddress(): Promise<string> {\n    const privateKeys = await this.backend.privateKeys();\n    return Object.keys(privateKeys)[0];\n  }\n\n  async pushMessage(message: Message) {\n    await Promise.all(message.signedStates?.map(signedState => this.addState(signedState)) || []);\n    message.objectives?.map(o => this.addObjective(o, false));\n  }\n\n  public async getEntry(channelId: string): Promise<ChannelStoreEntry> {\n    const entry = await this.backend.getChannel(channelId);\n    if (!entry) {\n      logger.error('Channel %s not found', channelId);\n      throw Error(Errors.channelMissing);\n    }\n\n    return entry;\n  }\n\n  public createBudget = (budget: DomainBudget) =>\n    this.backend.transaction('readwrite', [ObjectStores.budgets], async tx => {\n      const existingBudget = await this.backend.getBudget(budget.domain);\n      if (existingBudget) {\n        logger.error(Errors.budgetAlreadyExists);\n        tx.abort();\n      }\n\n      await this.backend.setBudget(budget.domain, budget);\n    });\n\n  public clearBudget = domain =>\n    this.backend.transaction('readwrite', [ObjectStores.budgets], () =>\n      this.backend.deleteBudget(domain)\n    );\n\n  public releaseFunds = (\n    assetHolderAddress: string,\n    ledgerChannelId: string,\n    targetChannelId: string\n  ) =>\n    this.backend.transaction(\n      'readwrite',\n      [ObjectStores.budgets, ObjectStores.channels, ObjectStores.privateKeys],\n      async () => {\n        const {applicationDomain, supported, participants} = await this.getEntry(ledgerChannelId);\n        const {outcome} = supported;\n        if (typeof applicationDomain !== 'string') throw Error(Errors.noDomainForChannel);\n\n        const currentBudget = await this.getBudget(applicationDomain);\n\n        const assetBudget = currentBudget?.forAsset[assetHolderAddress];\n\n        if (!currentBudget || !assetBudget) throw Error(Errors.noBudget);\n\n        const channelBudget = assetBudget.channels[targetChannelId];\n        if (!channelBudget) throw Error(Errors.channelNotInBudget);\n        const playerAddress = await this.getAddress();\n\n        const playerDestination = participants.find(p => p.signingAddress === playerAddress)\n          ?.destination;\n        if (!playerDestination) {\n          throw Error(Errors.cannotFindDestination);\n        }\n        // Simply set the budget to the current ledger outcome\n        assetBudget.availableSendCapacity = getAllocationAmount(outcome, playerDestination);\n        assetBudget.availableReceiveCapacity = getAllocationAmount(outcome, HUB.destination);\n\n        // Delete the funds assigned to the channel\n        delete assetBudget.channels[targetChannelId];\n\n        await this.backend.setBudget(applicationDomain, currentBudget);\n        return currentBudget;\n      }\n    );\n\n  public reserveFunds = (\n    assetHolderAddress: string,\n    channelId: string,\n    amount: {send: Uint256; receive: Uint256}\n  ) =>\n    this.backend.transaction(\n      'readwrite',\n      [ObjectStores.budgets, ObjectStores.channels],\n      async () => {\n        const entry = await this.getEntry(channelId);\n        const domain = entry.applicationDomain;\n        if (typeof domain !== 'string') throw Error(Errors.noDomainForChannel + ' ' + channelId);\n        const currentBudget = await this.backend.getBudget(domain);\n\n        // TODO?: Create a new budget if one doesn't exist\n        if (!currentBudget) throw Error(Errors.noBudget + domain);\n\n        const assetBudget = currentBudget?.forAsset[assetHolderAddress];\n        if (!assetBudget) throw Error(Errors.noAssetBudget);\n\n        if (\n          BN.lt(assetBudget.availableSendCapacity, amount.send) ||\n          BN.lt(assetBudget.availableReceiveCapacity, amount.receive)\n        ) {\n          throw Error(Errors.budgetInsufficient);\n        }\n\n        currentBudget.forAsset[assetHolderAddress] = {\n          ...assetBudget,\n          availableSendCapacity: BN.sub(assetBudget.availableSendCapacity, amount.send),\n          availableReceiveCapacity: BN.sub(assetBudget.availableReceiveCapacity, amount.receive),\n          channels: {\n            ...assetBudget.channels,\n            [channelId]: {amount: BN.add(amount.send, amount.receive)}\n          }\n        };\n        this.backend.setBudget(currentBudget.domain, currentBudget);\n\n        return currentBudget;\n      }\n    );\n}\n\nexport function supportedStateFeed(store: Store, channelId: string) {\n  return store.channelUpdatedFeed(channelId).pipe(\n    filter(e => e.isSupported),\n    map(({supported}) => ({state: supported}))\n  );\n}\n\nfunction getAllocationAmount(outcome: Outcome, destination: string) {\n  const {allocationItems} = checkThat(outcome, isSimpleEthAllocation);\n  const amount = allocationItems.find(a => a.destination === destination)?.amount;\n  if (!amount) throw Error(Errors.amountNotFound + ` ${destination}`);\n\n  return amount;\n}\n","import _ from 'lodash';\nimport {\n  ChannelConstants,\n  StateVariables,\n  SignedState,\n  Participant,\n  ChannelStoredData,\n  SignedStateWithHash,\n  SignedStateVarsWithHash,\n  StateVariablesWithHash,\n  Funding,\n  SignatureEntry,\n  hashState,\n  calculateChannelId,\n  createSignatureEntry,\n  outcomesEqual\n} from '@statechannels/wallet-core';\n\nimport {logger} from '../logger';\n\nimport {Errors} from '.';\nexport type SignedStateVariables = StateVariables & {signatures: SignatureEntry[]};\n\nexport class ChannelStoreEntry {\n  private stateVariables: Array<SignedStateVarsWithHash> = [];\n\n  public funding: Funding | undefined = undefined;\n\n  public readonly myIndex: number;\n  public readonly channelConstants: ChannelConstants;\n  public readonly applicationDomain?: string;\n\n  constructor(channelData: ChannelStoredData) {\n    const {myIndex, stateVariables, funding, applicationDomain, channelConstants} = channelData;\n\n    this.myIndex = myIndex;\n    this.stateVariables = stateVariables;\n    this.funding = funding;\n    this.applicationDomain = applicationDomain;\n\n    this.myIndex = channelData.myIndex;\n\n    this.channelConstants = channelConstants;\n\n    this.stateVariables = channelData.stateVariables;\n  }\n\n  public setFunding(funding: Funding) {\n    this.funding = funding;\n  }\n\n  public get sortedStates() {\n    return this.signedStates.map(s => ({...this.channelConstants, ...s}));\n  }\n\n  private mySignature(stateVars: StateVariables, signatures: SignatureEntry[]): boolean {\n    return signatures.some(sig => sig.signer === this.myAddress);\n  }\n\n  public get myAddress(): string {\n    return this.participants[this.myIndex].signingAddress;\n  }\n\n  public get myTurn(): boolean {\n    return (this.supported.turnNum + 1) % this.participants.length === this.myIndex;\n  }\n\n  private get signedStates(): Array<SignedStateWithHash> {\n    return this.stateVariables.map(s => ({\n      ...this.channelConstants,\n      ...s\n    }));\n  }\n\n  get isSupported() {\n    return !!this._supported;\n  }\n\n  get hasConclusionProof() {\n    return this.isSupported && this.support.every(s => s.isFinal);\n  }\n\n  get isChallenging() {\n    // TODO: Check chain\n    return false;\n  }\n\n  private get _supported() {\n    const latestSupport = this._support;\n    return latestSupport.length === 0 ? undefined : latestSupport[0];\n  }\n\n  public get support(): Array<SignedState> {\n    return this._support.map(s => ({...this.channelConstants, ...s}));\n  }\n\n  // This is a simple check based on _requireValidTransition from NitroProtocol\n  // We will eventually want to perform a proper validTransition check\n  // but we will have to be careful where we do that to prevent eating up a ton of cpu\n  private validChain(firstState: SignedState, secondState: SignedState): boolean {\n    if (firstState.turnNum + 1 !== secondState.turnNum) {\n      return false;\n    }\n    if (secondState.isFinal) {\n      return outcomesEqual(firstState.outcome, secondState.outcome);\n    }\n    if (secondState.turnNum < 2 * this.nParticipants()) {\n      return (\n        outcomesEqual(firstState.outcome, secondState.outcome) &&\n        firstState.appData === secondState.appData\n      );\n    }\n    return true;\n  }\n\n  private get _support(): Array<SignedStateWithHash> {\n    let support: Array<SignedStateWithHash> = [];\n\n    let participantsWhoHaveNotSigned = new Set(this.participants.map(p => p.signingAddress));\n    let previousState;\n\n    for (const signedState of this.signedStates) {\n      // If there is not a valid transition we know there cannot be a valid support\n      // so we clear out what we have and start at the current signed state\n      if (previousState && !this.validChain(signedState, previousState)) {\n        support = [];\n        participantsWhoHaveNotSigned = new Set(this.participants.map(p => p.signingAddress));\n      }\n      const moverIndex = signedState.turnNum % this.nParticipants();\n      const moverForThisTurn = this.participants[moverIndex].signingAddress;\n\n      // If the mover hasn't signed the state then we know it cannot be part of the support\n      if (signedState.signatures.some(s => s.signer === moverForThisTurn)) {\n        support.push(signedState);\n\n        for (const signature of signedState.signatures) {\n          participantsWhoHaveNotSigned.delete(signature.signer);\n          if (participantsWhoHaveNotSigned.size === 0) {\n            return support;\n          }\n        }\n      }\n      previousState = signedState;\n    }\n    return [];\n  }\n\n  get supported() {\n    const vars = this._supported;\n    if (!vars) throw new Error('No supported state found');\n    return {...this.channelConstants, ...vars};\n  }\n\n  get isSupportedByMe() {\n    return !!this._latestSupportedByMe;\n  }\n\n  private get _signedByMe() {\n    return this.signedStates.filter(s => this.mySignature(s, s.signatures));\n  }\n\n  private get _latestSupportedByMe() {\n    return this._signedByMe.find(() => true);\n  }\n\n  get latestSignedByMe() {\n    const vars = this._latestSupportedByMe;\n    if (!vars) throw new Error('No state supported by me');\n    return {...this.channelConstants, ...vars};\n  }\n\n  get latest() {\n    return {...this.channelConstants, ...this.signedStates[0]};\n  }\n\n  get latestState() {\n    return {...this.channelConstants, ...this.latest};\n  }\n\n  get channelId(): string {\n    return calculateChannelId(this.channelConstants);\n  }\n\n  get participants(): Participant[] {\n    return this.channelConstants.participants;\n  }\n\n  signAndAdd(stateVars: StateVariables, privateKey: string): SignedState {\n    if (this.isSupportedByMe && this.latestSignedByMe.turnNum >= stateVars.turnNum) {\n      logger.error({entry: this.data(), stateVars}, Errors.staleState);\n      throw Error(Errors.staleState);\n    }\n\n    const state = {...this.channelConstants, ...stateVars};\n\n    const signatureEntry = createSignatureEntry(state, privateKey);\n\n    return this.addState(stateVars, signatureEntry);\n  }\n\n  addState(stateVars: StateVariables, signatureEntry: SignatureEntry): SignedState {\n    const signedStateVars: SignedStateVariables = {\n      ...stateVars,\n      signatures: [signatureEntry]\n    };\n    const withHash: StateVariablesWithHash = {\n      ...stateVars,\n      stateHash: hashState(this.state(signedStateVars))\n    };\n\n    // TODO: This check could be more efficient\n    const {participants} = this.channelConstants;\n\n    // check the signature\n\n    const signerIndex = participants.findIndex(p => p.signingAddress === signatureEntry.signer);\n    let entry = this.stateVariables.find(s => s.stateHash === withHash.stateHash);\n\n    if (!entry) {\n      entry = {...withHash, signatures: []};\n      this.stateVariables.push(entry);\n    }\n\n    if (signerIndex === -1) {\n      throw new Error('State not signed by a participant of this channel');\n    }\n\n    entry.signatures = _.uniqWith(_.concat(entry.signatures, signatureEntry), _.isEqual);\n\n    this.clearOldStates();\n\n    this.checkInvariants();\n\n    return this.state(entry);\n  }\n\n  private checkInvariants() {\n    const groupedByTurnNum = _.groupBy(this._signedByMe, s => s.turnNum.toString());\n    const multipleSignedByMe = _.map(groupedByTurnNum, s => s.length)?.find(num => num > 1);\n\n    if (multipleSignedByMe) {\n      logger.error({entry: this.data()}, Errors.multipleSignedStates);\n\n      throw Error(Errors.multipleSignedStates);\n    }\n\n    const {signedStates} = this;\n    const turnNums = _.map(signedStates, s => s.turnNum);\n\n    const duplicateTurnNums = turnNums.some((t, i) => turnNums.indexOf(t) != i);\n    if (duplicateTurnNums) {\n      logger.error({signedStates}, Errors.duplicateTurnNums);\n      throw Error(Errors.duplicateTurnNums);\n    }\n    if (!isReverseSorted(turnNums)) {\n      logger.error({signedStates: _.map(signedStates, s => s.turnNum)});\n      throw Error(Errors.notSorted);\n    }\n  }\n\n  private state(stateVars: SignedStateVariables): SignedState {\n    return {...this.channelConstants, ...stateVars};\n  }\n\n  private clearOldStates() {\n    this.stateVariables = _.reverse(_.sortBy(this.stateVariables, s => s.turnNum));\n    // If we don't have a supported state we don't clean anything out\n    if (this.isSupported) {\n      // The support is returned in descending turn number so we need to grab the last element to find the earliest state\n      const {stateHash: firstSupportStateHash} = this._support[this._support.length - 1];\n\n      // Find where the first support state is in our current state array\n      const supportIndex = this.stateVariables.findIndex(\n        sv => sv.stateHash === firstSupportStateHash\n      );\n      // Take everything before that\n      this.stateVariables = this.stateVariables.slice(0, supportIndex + 1);\n    }\n  }\n\n  private nParticipants(): number {\n    return this.channelConstants.participants.length;\n  }\n\n  public data(): ChannelStoredData {\n    const channelConstants = {\n      ...this.channelConstants,\n      challengeDuration: this.channelConstants.challengeDuration,\n      channelNonce: this.channelConstants.channelNonce\n    };\n\n    const stateVariables = _.cloneDeep(this.stateVariables);\n\n    return {\n      stateVariables,\n      channelConstants,\n      funding: this.funding,\n      myIndex: this.myIndex,\n      applicationDomain: this.applicationDomain\n    };\n  }\n\n  static fromJson(data): ChannelStoreEntry {\n    if (!data) {\n      logger.error(\"Data is undefined or null, Memory Channel Store Entry can't be created.\");\n      return data;\n    }\n\n    // TODO: Add some sort of data validator here\n\n    const {channelConstants, funding, myIndex, applicationDomain} = data;\n    const stateVariables = data.stateVariables;\n\n    return new ChannelStoreEntry({\n      channelConstants,\n      myIndex,\n      stateVariables,\n      funding,\n      applicationDomain\n    });\n  }\n}\n\nfunction isReverseSorted(arr) {\n  const len = arr.length - 1;\n  for (let i = 0; i < len; ++i) {\n    if (arr[i] < arr[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n","import * as _ from 'lodash';\nimport Dexie, {Transaction, TransactionMode} from 'dexie';\nimport {\n  Objective,\n  DomainBudget,\n  ChannelStoredData,\n  AssetBudget,\n  BN\n} from '@statechannels/wallet-core';\n\nimport {unreachable} from '../utils';\nimport {logger} from '../logger';\n\nimport {ChannelStoreEntry} from './channel-store-entry';\n\nimport {DBBackend, ObjectStores, TXMode} from '.';\n\nconst STORES: ObjectStores[] = [\n  ObjectStores.budgets,\n  ObjectStores.channels,\n  ObjectStores.ledgers,\n  ObjectStores.nonces,\n  ObjectStores.objectives,\n  ObjectStores.privateKeys,\n  ObjectStores.destinationAddress\n];\n\n// A running, functioning example can be seen and played with here: https://codesandbox.io/s/elastic-kare-m1jp8\nexport class Backend implements DBBackend {\n  private _db: Dexie;\n\n  constructor() {\n    if (!indexedDB) {\n      logger.error(\"Your browser doesn't support a stable version of IndexedDB.\");\n    }\n  }\n  /**\n   * Initializes the Database and it's structure.\n   * @param cleanSlate if true, it clears all the object stores of data\n   * @param databaseName (optional) useful maybe for multiple tenants in the same page?\n   */\n  public async initialize(cleanSlate: boolean, databaseName: string) {\n    const createdDB = await this.create(databaseName);\n\n    if (cleanSlate) await Promise.all(STORES.map(this.clear.bind(this)));\n\n    return createdDB;\n  }\n\n  private async create(databaseName: string) {\n    this._db = new Dexie(databaseName, {indexedDB});\n    this._db\n      .version(3)\n      .stores(\n        _.reduce(\n          STORES.map(s => ({[s]: ''})),\n          _.merge\n        )\n      )\n      .upgrade(tx => {\n        const numberify = n => Number(BN.from(n));\n        tx.table(ObjectStores.channels).each(\n          ({key: channelId, value}: {key: string; value: ChannelStoredData}) => {\n            const {challengeDuration, channelNonce} = value.channelConstants;\n\n            value.channelConstants.challengeDuration = numberify(challengeDuration);\n            value.channelConstants.channelNonce = numberify(channelNonce);\n            value.stateVariables.map(s => (s.turnNum = numberify(s.turnNum)));\n\n            this.setChannel(channelId, value);\n          }\n        );\n        tx.table(ObjectStores.nonces).each(({key, value}) => this.setNonce(key, numberify(value)));\n      });\n  }\n\n  public async clear(storeName: ObjectStores): Promise<string> {\n    return this._db[storeName]?.clear();\n  }\n\n  // Generic Getters\n\n  public async channels() {\n    const channelData = (await this.getAll(ObjectStores.channels, true)) as {\n      key: string;\n      value: ChannelStoredData;\n    }[];\n    const channels = {};\n    channelData.forEach(cd => {\n      channels[cd.key] = ChannelStoreEntry.fromJson(cd.value);\n    });\n    return channels;\n  }\n\n  public async objectives() {\n    return this.getAll(ObjectStores.objectives);\n  }\n\n  public async nonces() {\n    const nonces = await this.getAll(ObjectStores.nonces);\n    for (const key in nonces) {\n      nonces[key] = nonces[key] ?? -1;\n    }\n    return nonces;\n  }\n\n  public async privateKeys() {\n    return this.getAll(ObjectStores.privateKeys);\n  }\n\n  public async ledgers() {\n    return this.getAll(ObjectStores.ledgers);\n  }\n\n  // Individual Getters\n  public async getBudget(key: string): Promise<DomainBudget | undefined> {\n    const budget: DomainBudget | undefined = await this.get(ObjectStores.budgets, key);\n    if (!budget) return budget;\n\n    return {\n      ...budget,\n      forAsset: _.mapValues(budget.forAsset, (assetBudget: AssetBudget) => ({\n        assetHolderAddress: assetBudget.assetHolderAddress,\n        availableReceiveCapacity: BN.from(assetBudget.availableReceiveCapacity),\n        availableSendCapacity: BN.from(assetBudget.availableSendCapacity),\n        channels: assetBudget.channels\n      }))\n    };\n  }\n\n  public async setBudget(key: string, value: DomainBudget) {\n    const result = await this.put(ObjectStores.budgets, value, key);\n    return result.value;\n  }\n\n  public async deleteBudget(key: string) {\n    return this.delete(ObjectStores.budgets, key);\n  }\n\n  public async getChannel(key: string) {\n    // TODO: This is typed to return ChannelStoredData, but it actually\n    // returns ChannelStoreEntry.\n    // This happens all over the place.\n    const channel = await this.get(ObjectStores.channels, key);\n    return channel && ChannelStoreEntry.fromJson(channel);\n  }\n  public async getObjective(key: number) {\n    return this.get(ObjectStores.objectives, key);\n  }\n  public async getNonce(key: string) {\n    return (await this.get(ObjectStores.nonces, key)) ?? -1;\n  }\n  public async getPrivateKey(key: string) {\n    return this.get(ObjectStores.privateKeys, key);\n  }\n  public async getLedger(key: string) {\n    return this.get(ObjectStores.ledgers, key);\n  }\n\n  public async getDestinationAddress() {\n    return this.get(ObjectStores.destinationAddress, 0);\n  }\n\n  // Individual Setters\n\n  public async setDestinationAddress(address: string) {\n    return this.put(ObjectStores.destinationAddress, address, 0);\n  }\n\n  public async setPrivateKey(signingAddress: string, privateKey: string) {\n    return this.put(ObjectStores.privateKeys, privateKey, signingAddress);\n  }\n\n  public async setChannel(key: string, value: ChannelStoredData) {\n    return this.put(ObjectStores.channels, value, key);\n  }\n\n  public async setLedger(key: string, value: string) {\n    return this.put(ObjectStores.ledgers, value, key);\n  }\n  public async setNonce(key: string, value: number) {\n    await this.put(ObjectStores.nonces, value, key);\n\n    return await this._db[ObjectStores.nonces].get(key);\n  }\n  public async setObjective(key: number, value: Objective) {\n    return this.put(ObjectStores.objectives, value, Number(key)) as Promise<Objective>;\n  }\n\n  public get transactionOngoing() {\n    return !!Dexie.currentTransaction;\n  }\n\n  public async transaction<T, S extends ObjectStores>(\n    mode: TXMode,\n    stores: S[],\n    callback: (tx: Transaction) => Promise<T>\n  ) {\n    let dexieMode: TransactionMode;\n    switch (mode) {\n      case 'readwrite':\n        dexieMode = 'rw';\n        break;\n      case 'readonly':\n        dexieMode = 'r';\n        break;\n      default:\n        return unreachable(mode);\n    }\n\n    try {\n      return await this._db.transaction(dexieMode, stores, callback);\n    } catch (error) {\n      logger.error(\n        {\n          error: error.message ?? error,\n          store: await this.dump(),\n          callback: callback.toString().slice(0, 200) + '...}'\n        },\n        'Transaction error'\n      );\n      throw error;\n    }\n  }\n\n  // Private Internal Methods\n\n  /**\n   * Gets all elements of a object store.\n   * @param storeName\n   * @param asArray if true, the result object, is transformed to an array\n   */\n  private async getAll(storeName: ObjectStores, asArray = false): Promise<any> {\n    return asArray\n      ? this._db[storeName].toArray()\n      : _.mapValues(_.keyBy(await this._db[storeName].toArray(), 'key'), 'value');\n  }\n\n  /**\n   * Gets an element from a object store\n   * @param storeName\n   * @param key required\n   */\n  private async get(storeName: ObjectStores, key: string | number): Promise<any> {\n    try {\n      return (await this._db[storeName].get(key))?.value;\n    } catch (e) {\n      if (/NotFoundError:/.test(e.message)) {\n        logger.error('Attempting invalid access to store %s', storeName);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Adds or replaces an element in a object store\n   * @param storeName\n   * @param value\n   * @param key\n   */\n  private async put(storeName: ObjectStores, value: any, key: string | number): Promise<any> {\n    await this._db[storeName].put({key, value}, key);\n\n    return this._db[storeName].get(key);\n  }\n\n  /**\n   * Deletes an element.\n   * Not used, but added to have a complete CRUD, just in case.\n   * @param storeName\n   * @param key\n   * @returns true on success, false on fail.\n   */\n  private async delete(storeName: ObjectStores, key: string | number): Promise<any> {\n    return this._db[storeName].delete(key);\n  }\n\n  private async dump() {\n    return this._db.transaction('r!', STORES, async () =>\n      _.reduce(\n        await Promise.all(\n          STORES.map(async store => ({[store]: await this._db.table(store).toArray()}))\n        ),\n        _.merge\n      )\n    );\n  }\n}\n","import {EventEmitter} from 'eventemitter3';\nimport {\n  parseRequest,\n  CreateChannelRequest,\n  UpdateChannelRequest,\n  CloseChannelRequest,\n  JoinChannelRequest,\n  StateChannelsResponse,\n  ChannelResult,\n  StateChannelsNotification,\n  ChannelClosingNotification,\n  ChannelUpdatedNotification,\n  ApproveBudgetAndFundRequest,\n  ChannelProposedNotification,\n  CloseAndWithdrawRequest,\n  StateChannelsErrorResponse,\n  ChallengeChannelRequest,\n  parseResponse\n} from '@statechannels/client-api-schema';\nimport {fromEvent, Observable} from 'rxjs';\nimport {validateMessage} from '@statechannels/wire-format';\nimport {\n  Message,\n  DomainBudget,\n  Participant,\n  unreachable,\n  isSimpleEthAllocation,\n  makeDestination,\n  serializeDomainBudget,\n  serializeChannelEntry,\n  deserializeMessage,\n  serializeMessage,\n  deserializeAllocations,\n  deserializeBudgetRequest\n} from '@statechannels/wallet-core';\n\nimport {AppRequestEvent} from './event-types';\nimport {\n  CHALLENGE_DURATION,\n  GIT_VERSION,\n  CHAIN_NETWORK_ID,\n  HUB_PARTICIPANT_ID,\n  HUB_ADDRESS,\n  HUB_DESTINATION\n} from './config';\nimport {Store} from './store';\n\ntype ChannelRequest =\n  | ChallengeChannelRequest\n  | CreateChannelRequest\n  | JoinChannelRequest\n  | UpdateChannelRequest\n  | CloseChannelRequest\n  | ApproveBudgetAndFundRequest\n  | CloseAndWithdrawRequest;\n\ninterface InternalEvents {\n  AppRequest: [AppRequestEvent];\n  CreateChannelRequest: [CreateChannelRequest];\n  SendMessage: [StateChannelsResponse | StateChannelsNotification | StateChannelsErrorResponse];\n}\n\nexport const isChannelUpdated = (\n  m: StateChannelsResponse | StateChannelsNotification\n): m is ChannelUpdatedNotification => 'method' in m && m.method === 'ChannelUpdated';\nexport const isChannelProposed = (\n  m: StateChannelsResponse | StateChannelsNotification\n): m is ChannelProposedNotification => 'method' in m && m.method === 'ChannelProposed';\n\nexport interface MessagingServiceInterface {\n  readonly outboxFeed: Observable<\n    StateChannelsResponse | StateChannelsNotification | StateChannelsErrorResponse\n  >;\n  readonly requestFeed: Observable<AppRequestEvent>;\n\n  receiveRequest(jsonRpcMessage: object, fromDomain: string): Promise<void>;\n  sendBudgetNotification(notificationData: DomainBudget): Promise<void>;\n  sendChannelNotification(\n    method: (ChannelClosingNotification | ChannelUpdatedNotification)['method'],\n    notificationData: ChannelResult\n  );\n  sendChannelNotification(\n    method: ChannelProposedNotification['method'],\n    notificationData: ChannelResult\n  );\n  sendMessageNotification(message: Message): Promise<void>;\n  sendDisplayMessage(displayMessage: 'Show' | 'Hide');\n  sendResponse(id: number, result: StateChannelsResponse['result']): Promise<void>;\n  sendError(id: number, error: StateChannelsErrorResponse['error']): Promise<void>;\n}\n\nexport class MessagingService implements MessagingServiceInterface {\n  private eventEmitter = new EventEmitter<InternalEvents>();\n\n  constructor(private store: Store) {\n    this.eventEmitter = new EventEmitter();\n  }\n\n  public get outboxFeed(): Observable<StateChannelsResponse> {\n    return fromEvent(this.eventEmitter, 'SendMessage');\n  }\n\n  get requestFeed(): Observable<AppRequestEvent> {\n    return fromEvent(this.eventEmitter, 'AppRequest');\n  }\n\n  public async sendResponse(id: number, result: StateChannelsResponse['result']) {\n    const response = parseResponse({id, jsonrpc: '2.0', result});\n    this.eventEmitter.emit('SendMessage', response);\n  }\n\n  public async sendError(id: number, error: StateChannelsErrorResponse['error']) {\n    const response = {id, jsonrpc: '2.0', error} as StateChannelsErrorResponse; // typescript can't handle this otherwise\n    this.eventEmitter.emit('SendMessage', response);\n  }\n\n  public async sendBudgetNotification(notificationData: DomainBudget) {\n    const notification: StateChannelsNotification = {\n      jsonrpc: '2.0',\n      method: 'BudgetUpdated',\n      params: serializeDomainBudget(notificationData)\n    };\n    this.eventEmitter.emit('SendMessage', notification);\n  }\n\n  public async sendChannelNotification(\n    method: ChannelClosingNotification['method'] | ChannelUpdatedNotification['method'],\n    notificationData: ChannelResult\n  );\n  // eslint-disable-next-line no-dupe-class-members\n  public async sendChannelNotification(\n    method: ChannelProposedNotification['method'],\n    notificationData: ChannelResult\n  );\n  // eslint-disable-next-line no-dupe-class-members\n  public async sendChannelNotification(method, notificationData) {\n    const notification: StateChannelsNotification = {\n      jsonrpc: '2.0',\n      method,\n      params: notificationData\n    };\n    this.eventEmitter.emit('SendMessage', notification);\n  }\n\n  public async sendMessageNotification(message: Message) {\n    // TODO: It is awkward to have to generate sender/recipient\n    const ourAddress = await this.store.getAddress();\n    const sender = ourAddress;\n    const objectiveRecipients =\n      message.objectives?.map(o => o.participants).reduce((a, b) => a.concat(b)) || [];\n    const stateRecipients =\n      message.signedStates?.map(ss => ss.participants).reduce((a, b) => a.concat(b)) || [];\n\n    const filteredRecipients = [...new Set((objectiveRecipients || []).concat(stateRecipients))]\n      .filter(p => p.signingAddress !== sender)\n      .map(p => p.participantId);\n\n    filteredRecipients.forEach(recipient => {\n      const notification: StateChannelsNotification = {\n        jsonrpc: '2.0',\n        method: 'MessageQueued',\n        params: validateMessage(serializeMessage(message, recipient, sender))\n      };\n      this.eventEmitter.emit('SendMessage', notification);\n    });\n  }\n\n  public sendDisplayMessage(displayMessage: 'Show' | 'Hide') {\n    const showWallet = displayMessage === 'Show';\n    const notification: StateChannelsNotification = {\n      jsonrpc: '2.0',\n      method: 'UIUpdate',\n      params: {showWallet}\n    };\n    this.eventEmitter.emit('SendMessage', notification);\n  }\n\n  public async receiveRequest(jsonRpcRequest: object, fromDomain: string) {\n    const request = parseRequest(jsonRpcRequest); // If this doesn't throw, we narrow the type to Request\n    const {id: requestId} = request;\n\n    switch (request.method) {\n      case 'GetWalletInformation':\n        await this.sendResponse(requestId, {\n          signingAddress: await this.store.getAddress(),\n          destinationAddress: (await this.store.getDestinationAddress()) ?? undefined,\n          walletVersion: GIT_VERSION\n        });\n        break;\n      case 'EnableEthereum':\n        const destinationAddress = await this.store.getDestinationAddress();\n        if (this.store.chain.ethereumIsEnabled && destinationAddress) {\n          await this.sendResponse(requestId, {\n            signingAddress: await this.store.getAddress(),\n            destinationAddress,\n            walletVersion: GIT_VERSION\n          });\n        } else {\n          this.eventEmitter.emit('AppRequest', {type: 'ENABLE_ETHEREUM', requestId});\n        }\n        break;\n      case 'GetChannels':\n        const channelEntries = await this.store.getApplicationChannels(\n          fromDomain,\n          request.params.includeClosed\n        );\n        const serializedChannelEntries = await Promise.all(\n          channelEntries.map(serializeChannelEntry)\n        );\n        await this.sendResponse(requestId, serializedChannelEntries);\n\n        break;\n      case 'ChallengeChannel':\n      case 'CreateChannel':\n      case 'UpdateChannel':\n      case 'CloseChannel':\n      case 'JoinChannel':\n      case 'ApproveBudgetAndFund':\n      case 'CloseAndWithdraw':\n        const appRequest = await convertToInternalEvent(request, this.store, fromDomain);\n        this.eventEmitter.emit('AppRequest', appRequest);\n        break;\n      case 'PushMessage':\n        const message = validateMessage(request.params);\n        if (message.recipient !== (await this.store.getAddress())) {\n          throw new Error(`Received message not addressed to us ${JSON.stringify(message)}`);\n        }\n        await this.store.pushMessage(deserializeMessage(message));\n        await this.sendResponse(requestId, {success: true});\n        break;\n      case 'GetBudget':\n        const DomainBudget = await this.store.getBudget(fromDomain);\n        await this.sendResponse(requestId, DomainBudget ? serializeDomainBudget(DomainBudget) : {});\n        break;\n      case 'GetState':\n        // TODO: handle these requests\n        break;\n\n      default:\n        unreachable(request);\n    }\n  }\n}\n\nexport function convertToInternalParticipant(participant: {\n  destination: string;\n  signingAddress: string;\n  participantId: string;\n}): Participant {\n  return {\n    ...participant,\n    destination: makeDestination(participant.destination)\n  };\n}\n\nasync function convertToInternalEvent(\n  request: ChannelRequest,\n  store: Store,\n  domain: string\n): Promise<AppRequestEvent> {\n  switch (request.method) {\n    case 'ChallengeChannel':\n      return {\n        type: 'PLAYER_REQUEST_CHALLENGE',\n        requestId: request.id,\n        channelId: request.params.channelId\n      };\n    case 'CloseAndWithdraw':\n      const closeAndWithdrawDestination = await store.getDestinationAddress();\n      if (!closeAndWithdrawDestination) {\n        throw new Error('No selected destination');\n      }\n      if (!(request.params.hubParticipantId !== HUB_PARTICIPANT_ID)) {\n        throw new Error(`You may only closeAndWithdraw for hub with id ${HUB_PARTICIPANT_ID}`);\n      }\n      return {\n        type: 'CLOSE_AND_WITHDRAW',\n        requestId: request.id,\n        player: convertToInternalParticipant({\n          participantId: await store.getAddress(),\n          signingAddress: await store.getAddress(),\n          destination: closeAndWithdrawDestination\n        }),\n        hub: convertToInternalParticipant({\n          participantId: request.params.hubParticipantId,\n          signingAddress: HUB_ADDRESS,\n          destination: HUB_DESTINATION\n        }),\n        domain: domain\n      };\n    case 'ApproveBudgetAndFund':\n      const {hub, playerParticipantId} = request.params;\n      const signingAddress = await store.getAddress();\n      const destination = await store.getDestinationAddress();\n      if (!destination) {\n        throw new Error('No selected destination');\n      }\n      return {\n        type: 'APPROVE_BUDGET_AND_FUND',\n        requestId: request.id,\n        budget: deserializeBudgetRequest(request.params, domain),\n        player: convertToInternalParticipant({\n          participantId: playerParticipantId,\n          signingAddress,\n          destination\n        }),\n        hub: convertToInternalParticipant(hub)\n      };\n    case 'CloseChannel':\n      return {\n        type: 'PLAYER_REQUEST_CONCLUDE',\n        requestId: request.id,\n        channelId: request.params.channelId\n      };\n    case 'CreateChannel': {\n      const outcome = deserializeAllocations(request.params.allocations);\n      if (!isSimpleEthAllocation(outcome)) {\n        throw new Error('Currently only a simple ETH allocation is supported');\n      }\n      return {\n        type: 'CREATE_CHANNEL',\n        ...request.params,\n        participants: request.params.participants.map(convertToInternalParticipant),\n        outcome,\n        challengeDuration: CHALLENGE_DURATION,\n        chainId: CHAIN_NETWORK_ID,\n        requestId: request.id,\n        applicationDomain: domain\n      };\n    }\n    case 'JoinChannel':\n      return {\n        type: 'JOIN_CHANNEL',\n        ...request.params,\n        requestId: request.id,\n        applicationDomain: domain\n      };\n    case 'UpdateChannel':\n      const outcome = deserializeAllocations(request.params.allocations);\n\n      if (!isSimpleEthAllocation(outcome)) {\n        throw new Error('Currently only a simple ETH allocation is supported');\n      }\n\n      return {\n        type: 'PLAYER_STATE_UPDATE',\n        requestId: request.id,\n        outcome,\n        channelId: request.params.channelId,\n        appData: request.params.appData\n      };\n  }\n}\n","import {AnyEventObject, AssignAction, MachineConfig, assign, spawn, Machine, Actor} from 'xstate';\nimport {filter, map} from 'rxjs/operators';\nimport {statesEqual, calculateChannelId, State} from '@statechannels/wallet-core';\n\nimport {Store} from '../store';\nconst WORKFLOW = 'support-state';\n\nexport type Init = {state: State; observer?: Actor<any, any>};\ntype HasChannelId = Init & {channelId: string};\n\n/*\nTODO\nWhat happens if sendState fails?\nDo we abort? Or do we try to reach consensus on a later state?\n*/\nexport const config: MachineConfig<HasChannelId, any, AnyEventObject> = {\n  key: WORKFLOW,\n  initial: 'signState',\n  states: {\n    signState: {\n      entry: [\n        assign<HasChannelId>({channelId: ({state}) => calculateChannelId(state)}),\n        'spawnObserver'\n      ],\n      invoke: {src: 'signState'},\n      on: {SUPPORTED: 'success'}\n    },\n    success: {type: 'final'}\n  }\n};\n\ntype Services = {signState(ctx: HasChannelId, event): any};\n\ntype Options = {\n  services: Services;\n  actions: {spawnObserver: AssignAction<HasChannelId, any>};\n};\n\nconst signState = (store: Store) => async ({state}: HasChannelId) => store.supportState(state);\n\nconst notifyWhenSupported = (store: Store, {state, channelId}: HasChannelId) =>\n  store.channelUpdatedFeed(channelId).pipe(\n    filter(({isSupported}) => isSupported),\n    filter(entry => statesEqual(state, entry.supported)),\n    map(() => 'SUPPORTED')\n  );\n\nconst options = (store: Store): Options => ({\n  services: {\n    signState: signState(store)\n  },\n  actions: {\n    spawnObserver: assign<HasChannelId>((ctx: HasChannelId) => ({\n      ...ctx,\n      observer: !ctx.observer ? spawn(notifyWhenSupported(store, ctx)) : ctx.observer\n    }))\n  }\n});\n\nexport const machine = (store: Store) => Machine(config, options(store));\n","import {\n  GuardPredicate,\n  StateMachine,\n  EventObject,\n  MachineConfig,\n  Machine,\n  DoneInvokeEvent,\n  StateNodeConfig,\n  assign,\n  ActionFunction,\n  ActionFunctionMap\n} from 'xstate';\n\nimport {Store} from '../store';\nimport {MessagingServiceInterface} from '../messaging';\n\n// export interface WorkflowStateSchema<T extends {value:any; context:any}> {\n//   meta?: any;\n//   context?: Partial<any>;\n//   states?: {\n//     [key: keyof T]: WorkflowStateSchema<T>;\n//   };\n// }\n\nexport function createMockGuard(guardName: string): GuardPredicate<any, any> {\n  return {\n    name: guardName,\n    predicate: () => true,\n    type: 'xstate.guard'\n  };\n}\n\n// TODO\n// Some machine factories require a context, and some don't\n// Sort this out.\nexport type MachineFactory<I, E extends EventObject> = (\n  store: Store,\n  context?: I\n) => StateMachine<I, any, E>;\n\ntype Options = (store: Store) => any;\ntype Config<T> = MachineConfig<T, any, any>;\nexport const connectToStore: <T>(config: Config<T>, options: Options) => MachineFactory<T, any> = <\n  T\n>(\n  config: Config<T>,\n  options: Options\n) => (store: Store, context?: T | undefined) => Machine(config).withConfig(options(store), context);\n\n/*\nSince machines typically  don't have sync access to a store, we invoke a promise to get the\ndesired outcome; that outcome can then be forwarded to the invoked service.\n*/\nexport function getDataAndInvoke2<T>(\n  data: string,\n  src: string,\n  onDone?: string,\n  id?: string\n): StateNodeConfig<any, any, any> {\n  return {\n    initial: data,\n    states: {\n      [data]: {invoke: {src: data, onDone: src}},\n      [src]: {\n        invoke: {\n          id,\n          src,\n          data: (_, {data}: DoneInvokeEvent<T>) => data,\n          onDone: 'done',\n          autoForward: true\n        }\n      },\n      done: {type: 'final' as 'final'}\n    },\n    onDone\n  };\n}\n\nexport const assignError = assign({\n  error: (_, event: DoneInvokeEvent<Error>) => event.data.message\n});\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const debugAction = (c, e, {state}) => {\n  // eslint-disable-next-line no-debugger\n  debugger;\n};\n\nexport const displayUI = (\n  messagingService: MessagingServiceInterface\n): ActionFunction<any, any> => () => messagingService.sendDisplayMessage('Show');\n\nexport const hideUI = (\n  messagingService: MessagingServiceInterface\n): ActionFunction<any, any> => () => messagingService.sendDisplayMessage('Hide');\n\nexport const sendUserDeclinedResponse = (\n  messageService: MessagingServiceInterface\n): ActionFunction<any, any> => context => {\n  if (!context.requestId) {\n    throw new Error(`No request id in context ${JSON.stringify(context)}`);\n  }\n  messageService.sendError(context.requestId, {\n    code: 200,\n    message: 'User declined'\n  });\n};\n\nexport const sendGenericResponse = (\n  messageService: MessagingServiceInterface\n): ActionFunction<any, any> => context => {\n  if (!context.requestId) {\n    throw new Error(`No request id in context ${JSON.stringify(context)}`);\n  }\n  messageService.sendError(context.requestId, {\n    code: 200,\n    message: 'User declined'\n  });\n};\n\nexport enum CommonActions {\n  sendUserDeclinedErrorResponse = 'sendUserDeclinedErrorResponse',\n  hideUI = 'hideUI',\n  displayUI = 'displayUI'\n}\nexport interface CommonWorkflowActions extends ActionFunctionMap<any, any> {\n  sendUserDeclinedErrorResponse: ActionFunction<{requestId: number}, any>;\n  hideUI: ActionFunction<any, any>;\n  displayUI: ActionFunction<any, any>;\n}\nexport const commonWorkflowActions = (\n  messageService: MessagingServiceInterface\n): CommonWorkflowActions => ({\n  displayUI: displayUI(messageService),\n  hideUI: hideUI(messageService),\n  sendUserDeclinedErrorResponse: sendUserDeclinedResponse(messageService)\n});\n","import {Machine, StateNodeConfig, assign, DoneInvokeEvent} from 'xstate';\nimport {map, first, filter} from 'rxjs/operators';\nimport {BN} from '@statechannels/wallet-core';\n\nimport {ChannelChainInfo} from '../chain';\nimport {Store} from '../store';\nimport {commonWorkflowActions, CommonActions} from '../utils/workflow-utils';\nimport {MessagingServiceInterface} from '../messaging';\nimport {getDataAndInvoke} from '../utils';\n\nimport {ParticipantIdx} from './virtual-funding-as-leaf';\n\nimport {VirtualDefundingAsLeaf, SupportState} from '.';\n\nconst WORKFLOW = 'conclude-channel';\n\nexport type Init = {channelId: string};\n\nconst signFinalState = (store: Store) => async ({channelId}: Init): Promise<void> =>\n  store.signFinalState(channelId);\n\nconst waitForConclusionProof = (store: Store) => async ({channelId}: Init) =>\n  store\n    .channelUpdatedFeed(channelId)\n    .pipe(first(({hasConclusionProof}) => hasConclusionProof))\n    .toPromise();\n\nconst concludeChannel = getDataAndInvoke<Init>(\n  {src: signFinalState.name},\n  {src: waitForConclusionProof.name},\n  'determineFundingType'\n);\n\nconst getFunding = (store: Store) => (ctx: Init) =>\n  store.channelUpdatedFeed(ctx.channelId).pipe(\n    map(({funding}) => {\n      switch (funding?.type) {\n        case 'Direct':\n        case 'Virtual':\n          return funding.type;\n        default:\n          throw new Error(`Unexpected funding type ${funding?.type}`);\n      }\n    })\n  );\n\nconst determineFundingType = {\n  invoke: {src: getFunding.name},\n  on: {\n    Virtual: 'virtualDefunding',\n    Direct: 'withdrawing'\n  }\n};\n\nconst getRole = (store: Store) => (ctx: Init) => async cb => {\n  const {myIndex} = await store.getEntry(ctx.channelId);\n  if (myIndex === ParticipantIdx.Hub) cb('AmHub');\n  else cb('AmLeaf');\n};\nconst getDirectFundingRole = (store: Store) => (ctx: Init) => async cb => {\n  const {myIndex} = await store.getEntry(ctx.channelId);\n  if (myIndex === ParticipantIdx.A) cb('AmA');\n  else cb('AmB');\n};\n\nconst supportState = (store: Store) => SupportState.machine(store);\n\nconst virtualDefunding = {\n  initial: 'gettingRole',\n  states: {\n    gettingRole: {invoke: {src: getRole.name}, on: {AmHub: 'asHub', AmLeaf: 'asLeaf'}},\n    asLeaf: {\n      invoke: {\n        src: 'virtualDefundingAsLeaf',\n        data: (ctx: Init): VirtualDefundingAsLeaf.Init => ({targetChannelId: ctx.channelId}),\n        onDone: 'success'\n      }\n    },\n    asHub: {invoke: {src: 'virtualDefundingAsHub', onDone: 'success'}},\n    success: {type: 'final' as 'final'}\n  },\n  onDone: 'success'\n};\n\nenum Services {\n  submitWithdrawTransaction = 'submitWithdrawTransaction',\n  observeFundsWithdrawal = 'observeFundsWithdrawal'\n}\n\ninterface FundsWithdrawn {\n  type: 'FUNDS_WITHDRAWN';\n}\n\nconst observeFundsWithdrawal = (store: Store) => context =>\n  store.chain.chainUpdatedFeed(context.channelId).pipe(\n    filter(c => BN.eq(c.amount, 0)),\n    map<ChannelChainInfo, FundsWithdrawn>(() => ({type: 'FUNDS_WITHDRAWN'}))\n  );\n\nconst submitWithdrawTransaction = (store: Store) => async context => {\n  const channelEntry = await store.getEntry(context.channelId);\n  if (!channelEntry.hasConclusionProof) {\n    throw new Error(`Channel ${context.channelId} is not finalized`);\n  }\n  await store.chain.finalizeAndWithdraw(channelEntry.support);\n};\n\nconst withdrawing = {\n  initial: 'gettingRole',\n  invoke: {\n    id: 'observeChain',\n    src: Services.observeFundsWithdrawal\n  },\n  on: {\n    FUNDS_WITHDRAWN: 'success'\n  },\n  entry: CommonActions.displayUI,\n  exit: CommonActions.hideUI,\n  states: {\n    gettingRole: {\n      invoke: {src: getDirectFundingRole.name},\n      on: {AmA: 'submitTransaction', AmB: 'waitForWithdrawalToComplete'}\n    },\n    submitTransaction: {\n      invoke: {\n        id: 'submitTransaction',\n        src: Services.submitWithdrawTransaction,\n        onDone: {\n          target: 'waitForWithdrawalToComplete',\n          actions: assign({\n            transactionId: (context, event: DoneInvokeEvent<string>) => event.data\n          })\n        }\n      }\n    },\n    waitForWithdrawalToComplete: {}\n  }\n};\n\nexport const config: StateNodeConfig<Init, any, any> = {\n  key: WORKFLOW,\n  initial: 'concludeChannel',\n  states: {\n    concludeChannel,\n    determineFundingType,\n    virtualDefunding,\n    withdrawing,\n    success: {type: 'final'}\n  }\n};\n\nconst services = (store: Store, messagingService: MessagingServiceInterface) => ({\n  signFinalState: signFinalState(store),\n  waitForConclusionProof: waitForConclusionProof(store),\n  getFunding: getFunding(store),\n  supportState: supportState(store),\n  getRole: getRole(store),\n  getDirectFundingRole: getDirectFundingRole(store),\n  virtualDefundingAsLeaf: VirtualDefundingAsLeaf.machine(store, messagingService),\n  submitWithdrawTransaction: submitWithdrawTransaction(store),\n  observeFundsWithdrawal: observeFundsWithdrawal(store)\n});\n\nconst options = (store: Store, messagingService: MessagingServiceInterface) => ({\n  services: services(store, messagingService),\n  actions: commonWorkflowActions(messagingService)\n});\nexport const machine = (store: Store, messagingService: MessagingServiceInterface) =>\n  Machine(config).withConfig(options(store, messagingService));\n","import {Machine, MachineConfig, assign, spawn} from 'xstate';\nimport {map, filter} from 'rxjs/operators';\nimport {exists, BN, Uint256} from '@statechannels/wallet-core';\n\nimport {ChannelChainInfo} from '../chain';\nimport {Store} from '../store';\nimport {MachineFactory} from '../utils/workflow-utils';\n\nexport type Init = {\n  channelId: string;\n  depositAt: Uint256;\n  totalAfterDeposit: Uint256;\n  fundedAt: Uint256;\n};\n\nexport const config: MachineConfig<Init, any, any> = {\n  id: 'depositing',\n  initial: 'idle',\n  entry: 'assignChainWatcher',\n  on: {FUNDED: 'done'},\n  states: {\n    idle: {on: {SAFE_TO_DEPOSIT: 'submit'}},\n    submit: {invoke: {src: 'submitDepositTransaction', onDone: 'idle', onError: 'failure'}},\n    done: {type: 'final'},\n    failure: {entry: assign<any>({error: () => 'Deposit failed'})}\n  }\n};\ntype SafeToDeposit = {type: 'SAFE_TO_DEPOSIT'; currentHoldings: Uint256};\n\nexport const machine: MachineFactory<Init, any> = (store: Store) => {\n  const subscribeDepositEvent = (ctx: Init) =>\n    store.chain.chainUpdatedFeed(ctx.channelId).pipe(\n      map((chainInfo: ChannelChainInfo): 'FUNDED' | SafeToDeposit | undefined => {\n        if (BN.gte(chainInfo.amount, ctx.fundedAt)) return 'FUNDED';\n        else if (BN.gte(chainInfo.amount, ctx.depositAt))\n          return {type: 'SAFE_TO_DEPOSIT', currentHoldings: chainInfo.amount};\n        else return;\n      }),\n      filter(exists)\n    );\n\n  const submitDepositTransaction = async (ctx: Init, {currentHoldings}: SafeToDeposit) => {\n    const amount = BN.sub(ctx.totalAfterDeposit, currentHoldings);\n    if (BN.lte(amount, 0)) return;\n\n    await store.chain.deposit(ctx.channelId, BN.from(currentHoldings), amount);\n  };\n\n  const services = {submitDepositTransaction};\n  const actions = {\n    assignChainWatcher: assign<Init & {chainWatcher: any}>({\n      chainWatcher: (ctx: Init) => spawn(subscribeDepositEvent(ctx))\n    })\n  } as any;\n  const options = {services, actions};\n  return Machine(config).withConfig(options);\n};\n","import {Machine, MachineConfig} from 'xstate';\nimport _ from 'lodash';\nimport {ethers} from 'ethers';\nimport {\n  isSimpleEthAllocation,\n  simpleEthAllocation,\n  checkThat,\n  Outcome,\n  SimpleAllocation,\n  AllocationItem,\n  Destination,\n  BN,\n  Zero\n} from '@statechannels/wallet-core';\n\nimport {Store} from '../store';\nimport {getDataAndInvoke2, MachineFactory} from '../utils/workflow-utils';\n\nimport * as Depositing from './depositing';\nimport * as SupportState from './support-state';\nconst {add, sub: subtract} = BN;\n\nconst WORKFLOW = 'direct-funding';\n\n/*\nDirect funding currently works like this:\nBEFORE DEPOSITING:\n- We check that the channel is fully-funded\n- We start with a ledger channel with some allocation A1\n- We're given a \"minimal allocation\" A2.\n  - A2 must have exactly one allocation item per participant.\n  - This item may allocate zero to some destination.\n  - Suppose we append A2 to A1. This might over-allocate to certain destinations.\n- We thus iterate through A2 and subtract off the excess, resulting in A2'\n  - It is participants[i]'s responsibility to ensure that A2'[i] is covered.\n- We update the allocation to be A3 = A1.concat(A2)\n\nDEPOSITING:\n- When everything up to A2'[i] is covered on-chain, participant i should deposit A2'[i].\n\nAFTER DEPOSITING:\n- We roll up repeat destinations into a single allocation item.\n  - This is only a safe operation when the channel is fully funded.\n\nWARNING: it is _not_ safe to restart this direct funding protocol. More thought is needed.\n*/\n\nexport interface Init {\n  channelId: string;\n  minimalAllocation: AllocationItem[];\n}\n\nconst checkCurrentLevel = {\n  invoke: {\n    src: 'checkCurrentLevel',\n    onDone: 'updatePrefundOutcome'\n  }\n};\n\nexport const config: MachineConfig<any, any, any> = {\n  key: WORKFLOW,\n  initial: 'checkCurrentLevel',\n  states: {\n    checkCurrentLevel,\n    updatePrefundOutcome: getDataAndInvoke2('getPrefundOutcome', 'supportState', 'funding'),\n    funding: getDataAndInvoke2('getDepositingInfo', 'fundingService', 'updatePostfundOutcome'),\n    updatePostfundOutcome: getDataAndInvoke2('getPostfundOutcome', 'supportState', 'success'),\n    success: {type: 'final'},\n    failure: {type: 'final'}\n  }\n};\n\ntype Services = {\n  checkCurrentLevel(ctx: Init): Promise<void>;\n  getPrefundOutcome(ctx: Init): Promise<SupportState.Init>;\n  getPostfundOutcome(ctx: Init): Promise<SupportState.Init>;\n  getDepositingInfo(ctx: Init): Promise<Depositing.Init>;\n  fundingService: any;\n  supportState: any;\n};\n\ntype Options = {services: Services};\n\nexport const machine: MachineFactory<Init, any> = (store: Store, context: Init) => {\n  async function checkCurrentLevel(ctx: Init) {\n    const {supported: supportedState} = await store.getEntry(ctx.channelId);\n\n    const outcome = checkThat(supportedState.outcome, isSimpleEthAllocation);\n    // TODO This prevents us from funding an app channel\n    const allocated = outcome.allocationItems.map(a => a.amount).reduce(BN.add, Zero);\n    const chainInfo = await store.chain.getChainInfo(ctx.channelId);\n\n    if (BN.gt(allocated, chainInfo.amount))\n      throw new Error('DirectFunding: Channel outcome is already underfunded; aborting');\n  }\n\n  function minimalOutcome(\n    currentOutcome: SimpleAllocation,\n    minimalEthAllocation: AllocationItem[]\n  ): Outcome {\n    const allocationItems = currentOutcome.allocationItems.concat(\n      minimalEthAllocation.map(({destination, amount}) => {\n        const currentlyAllocated = currentOutcome.allocationItems\n          .filter(i => i.destination === destination)\n          .map(i => i.amount)\n          .reduce(add);\n\n        const amountLeft = BN.gt(amount, currentlyAllocated)\n          ? subtract(amount, currentlyAllocated)\n          : Zero;\n        return {destination, amount: amountLeft};\n      })\n    );\n\n    return simpleEthAllocation(allocationItems);\n  }\n\n  function mergeDestinations(outcome: SimpleAllocation): SimpleAllocation {\n    const destinations: Destination[] = _.uniq(outcome.allocationItems.map(i => i.destination));\n\n    const allocationItems = destinations.map(destination => ({\n      destination,\n      amount: outcome.allocationItems\n        .filter(i => i.destination === destination)\n        .map(i => i.amount)\n        .reduce(add)\n    }));\n\n    return simpleEthAllocation(allocationItems);\n  }\n\n  async function getDepositingInfo({minimalAllocation, channelId}: Init): Promise<Depositing.Init> {\n    const {supported: supportedState, myIndex} = await store.getEntry(channelId);\n    const supportedOutcome = supportedState.outcome;\n    if (!isSimpleEthAllocation(supportedOutcome)) {\n      throw new Error('Unsupported outcome');\n    }\n    let totalBeforeDeposit = Zero;\n    for (let i = 0; i < minimalAllocation.length; i++) {\n      const allocation = minimalAllocation[i];\n      if (myIndex === i) {\n        const fundedAt = supportedOutcome.allocationItems.map(a => a.amount).reduce(add);\n\n        return {\n          channelId,\n          depositAt: totalBeforeDeposit,\n          totalAfterDeposit: BN.add(totalBeforeDeposit, allocation.amount),\n          fundedAt\n        };\n      } else {\n        totalBeforeDeposit = BN.add(allocation.amount, totalBeforeDeposit);\n      }\n    }\n\n    throw Error(`Could not find an allocation for participant id ${myIndex}`);\n  }\n\n  async function getPrefundOutcome({\n    channelId,\n    minimalAllocation\n  }: Init): Promise<SupportState.Init> {\n    const entry = await store.getEntry(channelId);\n    const {channelConstants} = entry;\n\n    if (minimalAllocation.length !== channelConstants.participants.length) {\n      throw new Error('Must be exactly one allocation item per participant');\n    }\n\n    // TODO: Safety checks?\n    if (entry.isSupported) {\n      const outcome = minimalOutcome(entry.latest.outcome as SimpleAllocation, minimalAllocation);\n      return {\n        state: {\n          ...entry.latest,\n          ...entry.channelConstants,\n          outcome,\n          turnNum: entry.latest.turnNum + 1\n        }\n      };\n    } else {\n      return {\n        state: {\n          ...entry.channelConstants,\n          challengeDuration: 1,\n          isFinal: false,\n          turnNum: 0,\n          outcome: minimalOutcome(simpleEthAllocation([]), minimalAllocation),\n          appData: ethers.constants.HashZero,\n          appDefinition: ethers.constants.AddressZero\n        }\n      };\n    }\n  }\n\n  async function getPostfundOutcome({channelId}: Init): Promise<SupportState.Init> {\n    const {supported} = await store.getEntry(channelId);\n    return {\n      state: {\n        ...supported,\n        turnNum: supported.turnNum + 1,\n        outcome: mergeDestinations(supported.outcome as SimpleAllocation)\n      }\n    };\n  }\n\n  const services: Services = {\n    checkCurrentLevel,\n    getPrefundOutcome,\n    supportState: SupportState.machine(store),\n    fundingService: Depositing.machine(store),\n    getPostfundOutcome,\n    getDepositingInfo\n  };\n\n  const options: Options = {services};\n  return Machine(config).withConfig(options, context);\n};\n","import {Machine, MachineConfig, ServiceConfig, assign, DoneInvokeEvent} from 'xstate';\nimport {\n  allocateToTarget,\n  isSimpleEthAllocation,\n  checkThat,\n  AllocationItem,\n  Funding,\n  BN\n} from '@statechannels/wallet-core';\n\nimport {ChannelLock} from '../store/store';\nimport {Store} from '../store';\nimport {getDataAndInvoke} from '../utils';\nimport {assignError} from '../utils/workflow-utils';\nimport {escalate} from '../actions';\n\nimport {SupportState} from '.';\n\nconst WORKFLOW = 'ledger-funding';\nconst {add} = BN;\n\nexport interface Init {\n  targetChannelId: string;\n  ledgerChannelId: string;\n  deductions: AllocationItem[];\n}\n\nconst enum Services {\n  getTargetOutcome = 'getTargetOutcome',\n  updateFunding = 'updateFunding',\n  supportState = 'supportState',\n  checkTarget = 'checkTarget',\n  acquireLock = 'acquireLock'\n}\n\nexport const enum Errors {\n  underfunded = 'Ledger channel is underfunded',\n  underallocated = 'Ledger channel is underallocated',\n  finalized = 'Ledger channel is finalized',\n  unSupportedTargetChannel = 'Target channel has no supported state: '\n}\n\nconst FAILURE = `#${WORKFLOW}.failure`;\nconst onError = {target: FAILURE};\n\nconst fundingTarget = getDataAndInvoke(\n  {src: Services.getTargetOutcome, opts: {onError}},\n  {src: Services.supportState, opts: {onError}},\n  'updatingFunding'\n);\n\nconst checkTarget = (store: Store) => async (ctx: Init) => {\n  const {isSupported} = await store.getEntry(ctx.targetChannelId);\n  if (!isSupported) throw Error(Errors.unSupportedTargetChannel + ctx.targetChannelId);\n};\n\nexport const config: MachineConfig<any, any, any> = {\n  id: WORKFLOW,\n  key: WORKFLOW,\n  initial: 'acquiringLock',\n  states: {\n    acquiringLock: {\n      invoke: {src: Services.acquireLock, onDone: 'checkingTarget'},\n      exit: assign<WithLock>({lock: (_, event: DoneInvokeEvent<ChannelLock>) => event.data})\n    },\n    checkingTarget: {\n      invoke: {src: Services.checkTarget, onDone: 'fundingTarget', onError}\n    },\n    fundingTarget,\n    failure: {\n      entry: [assignError, 'escalateError', 'releaseLock']\n    },\n    updatingFunding: {invoke: {src: Services.updateFunding, onDone: 'success'}},\n    success: {type: 'final', entry: 'releaseLock'}\n  }\n};\n\nconst acquireLock = (store: Store) => (ctx: Init): Promise<ChannelLock> =>\n  store.acquireChannelLock(ctx.ledgerChannelId);\n\ntype WithLock = Init & {lock: ChannelLock};\n\nconst getTargetOutcome = (store: Store) => async (ctx: Init): Promise<SupportState.Init> => {\n  // TODO: Switch to feed\n  const {targetChannelId, ledgerChannelId, deductions} = ctx;\n  const {supported: ledgerState, channelConstants} = await store.getEntry(ledgerChannelId);\n\n  const {amount, finalized} = await store.chain.getChainInfo(ledgerChannelId);\n  if (finalized) throw new Error(Errors.finalized);\n\n  const currentlyAllocated = checkThat(ledgerState.outcome, isSimpleEthAllocation)\n    .allocationItems.map(i => i.amount)\n    .reduce(add);\n  const toDeduct = deductions.map(i => i.amount).reduce(add);\n\n  if (BN.lt(amount, currentlyAllocated)) throw new Error(Errors.underfunded);\n\n  if (BN.lt(currentlyAllocated, toDeduct)) throw new Error(Errors.underallocated);\n\n  return {\n    state: {\n      ...channelConstants,\n      ...ledgerState,\n      turnNum: ledgerState.turnNum + 1,\n      outcome: allocateToTarget(ledgerState.outcome, deductions, targetChannelId)\n    }\n  };\n};\n\nconst updateFunding = (store: Store) => async ({targetChannelId, ledgerChannelId}: Init) => {\n  const funding: Funding = {type: 'Indirect', ledgerId: ledgerChannelId};\n  await store.setFunding(targetChannelId, funding);\n};\n\nconst services = (store: Store): Record<Services, ServiceConfig<Init>> => ({\n  checkTarget: checkTarget(store),\n  getTargetOutcome: getTargetOutcome(store),\n  updateFunding: updateFunding(store),\n  supportState: SupportState.machine(store),\n  acquireLock: acquireLock(store)\n});\n\nconst actions = {\n  escalateError: escalate(({error}) => ({type: 'FAILURE', error})),\n  releaseLock: (ctx: WithLock) => ctx.lock.release()\n};\n\nconst options = (store: Store) => ({services: services(store), actions});\n\nexport const machine = (store: Store) => Machine(config, options(store));\n","import {\n  Machine,\n  MachineOptions,\n  AnyEventObject,\n  DoneInvokeEvent,\n  ServiceConfig,\n  assign,\n  StateNodeConfig,\n  ActionTypes\n} from 'xstate';\nimport {filter, map, take, flatMap, tap, first} from 'rxjs/operators';\nimport {\n  checkThat,\n  simpleEthGuarantee,\n  isSimpleEthAllocation,\n  simpleEthAllocation,\n  makeDestination,\n  FundGuarantor,\n  AllocationItem,\n  BN\n} from '@statechannels/wallet-core';\n\nimport {Store, supportedStateFeed} from '../store';\nimport {getDataAndInvoke} from '../utils/helpers';\nimport {CHALLENGE_DURATION} from '../config';\nimport {escalate} from '../actions';\nimport {assignError} from '../utils/workflow-utils';\n\nimport {SupportState, LedgerFunding} from '.';\n\nexport const enum OutcomeIdx {\n  A = 0,\n  Hub = 1,\n  B = 2\n}\nexport const enum ParticipantIdx {\n  A = 0,\n  B = 1,\n  Hub = 2\n}\n\nexport type Init = {\n  targetChannelId: string;\n  jointChannelId: string;\n};\n\ntype Deductions = {deductions: AllocationItem[]};\ntype WithDeductions = Init & Deductions;\ntype WithObjectiveData = WithDeductions & {guarantorChannelId: string; ledgerId: string};\n\nconst getFundGuarantorObjective = (store: Store) => async (ctx: Init): Promise<FundGuarantor> => {\n  const {jointChannelId, targetChannelId} = ctx;\n  const entry = await store.getEntry(jointChannelId);\n  const {participants: jointParticipants} = entry.channelConstants;\n  const participants = [jointParticipants[entry.myIndex], jointParticipants[ParticipantIdx.Hub]];\n\n  const {channelId: ledgerId} = await store.getLedger(\n    jointParticipants[ParticipantIdx.Hub].participantId\n  );\n  const {channelId: guarantorId} = await store.createChannel(participants, CHALLENGE_DURATION, {\n    turnNum: 0,\n    appData: '0x',\n    isFinal: false,\n    outcome: simpleEthGuarantee(\n      jointChannelId,\n      targetChannelId,\n      ...participants.map(p => p.destination)\n    )\n  });\n\n  // TODO: We never actually check that the guarantor channel's state is supported.\n\n  return {\n    type: 'FundGuarantor',\n    participants,\n    data: {jointChannelId, ledgerId, guarantorId}\n  };\n};\n\ntype TEvent = AnyEventObject;\n\nconst enum Actions {\n  triggerGuarantorObjective = 'triggerGuarantorObjective',\n  assignDeductions = 'assignDeductions',\n  assignGuarantorId = 'assignGuarantorId'\n}\n\nexport const enum States {\n  determineDeductions = 'determineDeductions',\n  setupJointChannel = 'setupJointChannel',\n  fundJointChannel = 'fundJointChannel',\n  fundTargetChannel = 'fundTargetChannel',\n  failure = '#workflow.failure',\n  success = 'success'\n}\n\nconst enum Services {\n  getDeductions = 'getDeductions',\n  waitForSupportedGuarantorState = 'waitForSupportedGuarantorState',\n  waitForFirstJointState = 'waitForFirstJointState',\n  jointChannelUpdate = 'jointChannelUpdate',\n  supportState = 'supportState',\n  ledgerFunding = 'ledgerFunding',\n  fundGuarantor = 'fundGuarantor',\n  updateJointChannelFunding = 'updateJointChannelFunding'\n}\n\nconst waitForSupportedGuarantorState = (store: Store) => async (ctx: WithObjectiveData) =>\n  store\n    .channelUpdatedFeed(ctx.guarantorChannelId)\n    .pipe(\n      filter(u => u.isSupported),\n      first()\n    )\n    .toPromise();\n\nexport const config: StateNodeConfig<Init, any, any> = {\n  key: 'virtual-funding-as-leaf',\n  id: 'workflow',\n  initial: States.setupJointChannel,\n  on: {\n    [ActionTypes.ErrorCustom]: '#workflow.failure'\n  },\n  states: {\n    [States.setupJointChannel]: getDataAndInvoke<Init, Services>(\n      {src: Services.waitForFirstJointState, opts: {onError: '#workflow.failure'}},\n      {src: Services.supportState},\n      States.determineDeductions\n    ),\n    [States.determineDeductions]: {\n      invoke: {src: Services.getDeductions, data: ctx => ctx, onDone: States.fundJointChannel},\n      exit: Actions.assignDeductions\n    },\n    [States.fundJointChannel]: {\n      initial: 'getObjective',\n      states: {\n        getObjective: {\n          invoke: {\n            src: Services.fundGuarantor,\n            onDone: 'preparingGuarantorChannel',\n            onError: '#workflow.failure'\n          },\n          exit: [Actions.triggerGuarantorObjective, Actions.assignGuarantorId]\n        },\n        preparingGuarantorChannel: {\n          invoke: {src: Services.waitForSupportedGuarantorState, onDone: 'runObjective'}\n        },\n        runObjective: {\n          invoke: {\n            src: Services.ledgerFunding,\n            data: (ctx: WithObjectiveData): LedgerFunding.Init => ({\n              targetChannelId: ctx.guarantorChannelId,\n              ledgerChannelId: ctx.ledgerId,\n              deductions: ctx.deductions\n            }),\n            onDone: 'updateFunding'\n          }\n        },\n        updateFunding: {invoke: {src: Services.updateJointChannelFunding, onDone: 'done'}},\n        done: {type: 'final'}\n      },\n      onDone: States.fundTargetChannel\n    },\n    [States.fundTargetChannel]: getDataAndInvoke(\n      {src: Services.jointChannelUpdate},\n      {src: Services.supportState},\n      States.success\n    ),\n    success: {type: 'final'},\n    failure: {\n      entry: [assignError, escalate(({error}: any) => ({type: 'FAILURE', error}))]\n    }\n  }\n};\n\nexport const waitForFirstJointState = (store: Store) => ({\n  jointChannelId\n}: Init): Promise<SupportState.Init> =>\n  store\n    .channelUpdatedFeed(jointChannelId)\n    .pipe(\n      flatMap(e => e.sortedStates),\n      filter(({turnNum}) => turnNum === 0),\n      tap(({outcome, participants}) => {\n        const {allocationItems} = checkThat(outcome, isSimpleEthAllocation);\n        const destinations = allocationItems.map(i => i.destination);\n        const amounts = allocationItems.map(i => i.amount);\n\n        if (\n          !(\n            destinations[OutcomeIdx.A] === participants[ParticipantIdx.A].destination &&\n            destinations[OutcomeIdx.B] === participants[ParticipantIdx.B].destination &&\n            destinations[OutcomeIdx.Hub] === participants[ParticipantIdx.Hub].destination\n          )\n        ) {\n          throw new Error('Incorrect participants');\n        } else if (\n          !(BN.add(amounts[OutcomeIdx.A], amounts[OutcomeIdx.B]) === amounts[OutcomeIdx.Hub])\n        ) {\n          throw new Error('Incorrect allocation');\n        } else return;\n      }),\n      map(s => ({state: s})),\n      take(1)\n    )\n    .toPromise();\n\nexport const jointChannelUpdate = (store: Store) => ({\n  jointChannelId,\n  targetChannelId\n}: Init): Promise<SupportState.Init> =>\n  supportedStateFeed(store, jointChannelId)\n    .pipe(\n      filter(({state}) => state.turnNum === 0),\n      map(({state}) => {\n        const oldOutcome = checkThat(state.outcome, isSimpleEthAllocation);\n        const amount = oldOutcome.allocationItems[OutcomeIdx.Hub].amount;\n        const outcome = simpleEthAllocation([\n          {destination: makeDestination(targetChannelId), amount},\n          {destination: state.participants[ParticipantIdx.Hub].destination, amount}\n        ]);\n        return {state: {...state, turnNum: 1, outcome}};\n      }),\n      take(1)\n    )\n    .toPromise();\n\nconst getDeductions = (store: Store) => async (ctx: Init): Promise<Deductions> => {\n  const {latestSignedByMe: latestSupportedByMe, myIndex} = await store.getEntry(ctx.jointChannelId);\n  const {allocationItems} = checkThat(latestSupportedByMe.outcome, isSimpleEthAllocation);\n\n  const outcomeIdx = myIndex === ParticipantIdx.A ? OutcomeIdx.A : OutcomeIdx.B;\n\n  return {\n    deductions: [\n      {\n        destination: allocationItems[OutcomeIdx.Hub].destination,\n        amount: allocationItems[2 - outcomeIdx].amount\n      },\n      allocationItems[outcomeIdx]\n    ]\n  };\n};\n\nconst updateJointChannelFunding = (store: Store) => async (ctx: WithObjectiveData) => {\n  const {jointChannelId, guarantorChannelId} = ctx;\n  await store.setFunding(jointChannelId, {type: 'Guarantee', guarantorChannelId});\n};\n\nexport const options = (\n  store: Store\n): Pick<MachineOptions<Init, TEvent>, 'actions' | 'services'> => {\n  const actions: Record<Actions, any> = {\n    [Actions.triggerGuarantorObjective]: (_, {data}: DoneInvokeEvent<FundGuarantor>) =>\n      store.addObjective(data),\n    [Actions.assignDeductions]: assign(\n      (ctx: Init, {data}: DoneInvokeEvent<Deductions>): WithDeductions => ({...ctx, ...data})\n    ),\n    [Actions.assignGuarantorId]: assign({\n      guarantorChannelId: (_, {data}: DoneInvokeEvent<FundGuarantor>) => data.data.guarantorId,\n      ledgerId: (_, {data}: DoneInvokeEvent<FundGuarantor>) => data.data.ledgerId\n    })\n  };\n\n  const services: Record<Services, ServiceConfig<Init>> = {\n    waitForSupportedGuarantorState: waitForSupportedGuarantorState(store),\n    getDeductions: getDeductions(store),\n    supportState: SupportState.machine(store),\n    ledgerFunding: LedgerFunding.machine(store),\n    waitForFirstJointState: waitForFirstJointState(store),\n    jointChannelUpdate: jointChannelUpdate(store),\n    fundGuarantor: getFundGuarantorObjective(store),\n    updateJointChannelFunding: updateJointChannelFunding(store)\n  };\n\n  return {actions, services};\n};\n\nexport const machine = (store: Store) => Machine(config, options(store));\n","import {\n  StateNodeConfig,\n  MachineConfig,\n  Machine,\n  MachineOptions,\n  AnyEventObject,\n  DoneInvokeEvent,\n  ServiceConfig,\n  assign,\n  spawn,\n  AssignAction\n} from 'xstate';\nimport {filter, flatMap} from 'rxjs/operators';\nimport {\n  checkThat,\n  isSimpleEthAllocation,\n  FundGuarantor,\n  AllocationItem,\n  isFundGuarantor,\n  Participant,\n  State\n} from '@statechannels/wallet-core';\nimport {Observable} from 'rxjs';\n\nimport {Store} from '../store';\n\nimport {ParticipantIdx, States, OutcomeIdx} from './virtual-funding-as-leaf';\n\nimport {LedgerFunding, VirtualFundingAsLeaf, SupportState} from '.';\n\ntype RoleData = {\n  ledgerId: string;\n  guarantorId: string;\n  guarantorState: State;\n};\ntype Deductions = {\n  [ParticipantIdx.A]: AllocationItem[];\n  [ParticipantIdx.B]: AllocationItem[];\n};\nexport type Init = VirtualFundingAsLeaf.Init & {\n  [ParticipantIdx.A]: Partial<RoleData>;\n  [ParticipantIdx.B]: Partial<RoleData>;\n};\n\ntype WithDeductions = Init & {deductions: Deductions};\n\ntype TEvent = AnyEventObject;\n\nconst enum Actions {\n  assignDeductions = 'assignDeductions',\n  watchObjectives = 'watchObjectives'\n}\n\nconst enum Services {\n  getDeductions = 'getDeductions',\n  waitForFirstJointState = 'waitForFirstJointState',\n  jointChannelUpdate = 'jointChannelUpdate',\n  supportState = 'supportState',\n  ledgerFunding = 'ledgerFunding'\n}\n\nconst enum Events {\n  FundGuarantorWithA = 'FundGuarantorWithA',\n  FundGuarantorWithB = 'FundGuarantorWithB'\n}\n\ntype Objective = Pick<FundGuarantor, 'data' | 'participants'> & {state: State; type: Events};\nconst assignObjectiveData = (\n  role: ParticipantIdx.A | ParticipantIdx.B\n): AssignAction<Init, Objective> =>\n  assign<Init>({\n    [role]: (_, {data, state}: Objective): RoleData => ({\n      guarantorId: data.guarantorId,\n      ledgerId: data.ledgerId,\n      guarantorState: state\n    })\n  });\n\nconst waitThenFundGuarantor = (\n  role: ParticipantIdx.A | ParticipantIdx.B\n): StateNodeConfig<any, any, any> => {\n  const event = role === ParticipantIdx.A ? Events.FundGuarantorWithA : Events.FundGuarantorWithB;\n  return {\n    initial: 'waitForObjective',\n    states: {\n      waitForObjective: {\n        on: {[event]: {target: 'supportingGuarantorState', actions: assignObjectiveData(role)}}\n      },\n      supportingGuarantorState: {\n        invoke: {\n          src: Services.supportState,\n          data: (ctx: Init): SupportState.Init => ({state: (ctx[role] as RoleData).guarantorState}),\n          onDone: 'runObjective'\n        }\n      },\n      runObjective: {\n        invoke: {\n          src: Services.ledgerFunding,\n          data: (ctx: WithDeductions): LedgerFunding.Init => {\n            // We know that the data has already been assigned in the\n            // transition out of waitForObjective\n            const {guarantorId: targetChannelId, ledgerId: ledgerChannelId} = ctx[role] as RoleData;\n            const deductions = ctx.deductions[role];\n            return {targetChannelId, ledgerChannelId, deductions};\n          },\n          onDone: 'done'\n        }\n      },\n      done: {type: 'final'}\n    }\n  };\n};\n\nexport const config: MachineConfig<Init, any, any> = {\n  key: 'virtual-funding-as-hub',\n  id: 'workflow',\n  initial: States.setupJointChannel,\n  states: {\n    ...VirtualFundingAsLeaf.config.states,\n    [States.fundJointChannel]: {\n      type: 'parallel',\n      entry: [Actions.watchObjectives, Actions.assignDeductions],\n      states: {\n        fundGuarantorAH: waitThenFundGuarantor(ParticipantIdx.A),\n        fundGuarantorBH: waitThenFundGuarantor(ParticipantIdx.B)\n      },\n      onDone: States.fundTargetChannel\n    }\n  }\n};\n\nconst getDeductions = (store: Store) => async (ctx: Init): Promise<Deductions> => {\n  const entry = await store.getEntry(ctx.jointChannelId);\n  const {latestSignedByMe: latestSupportedByMe} = entry;\n  const {allocationItems} = checkThat(latestSupportedByMe.outcome, isSimpleEthAllocation);\n\n  return {\n    [ParticipantIdx.A]: [\n      {\n        destination: allocationItems[OutcomeIdx.Hub].destination,\n        amount: allocationItems[OutcomeIdx.B].amount\n      },\n      allocationItems[OutcomeIdx.A]\n    ],\n    [ParticipantIdx.B]: [\n      {\n        destination: allocationItems[OutcomeIdx.Hub].destination,\n        amount: allocationItems[OutcomeIdx.A].amount\n      },\n      allocationItems[OutcomeIdx.B]\n    ]\n  };\n};\n\nconst watchObjectives = (store: Store) => (ctx: Init): Observable<Objective> =>\n  store.objectiveFeed.pipe(\n    filter(isFundGuarantor),\n    filter(o => o.data.jointChannelId === ctx.jointChannelId),\n    flatMap(async o => {\n      const participant = o.participants[0].participantId;\n      const jointParticipants: Participant[] = await (await store.getEntry(ctx.jointChannelId))\n        .channelConstants.participants;\n\n      const {latest} = await store.getEntry(o.data.guarantorId);\n\n      switch (participant) {\n        case jointParticipants[ParticipantIdx.A].participantId:\n          return {...o, type: Events.FundGuarantorWithA, state: latest};\n        case jointParticipants[ParticipantIdx.B].participantId:\n          return {...o, type: Events.FundGuarantorWithB, state: latest};\n        default:\n          throw 'Participant not found';\n      }\n    })\n  );\n\nexport const options = (store: Store): Partial<MachineOptions<Init, TEvent>> => {\n  const actions: Record<Actions, any> = {\n    watchObjectives: assign<any>({watcher: (ctx: Init) => spawn(watchObjectives(store)(ctx))}),\n    [Actions.assignDeductions]: assign({\n      deductions: (_, {data}: DoneInvokeEvent<Deductions>) => data\n    })\n  };\n\n  const leafServices = VirtualFundingAsLeaf.options(store).services;\n  const services: Record<Services, ServiceConfig<Init>> = {\n    getDeductions: getDeductions(store),\n    supportState: leafServices.supportState,\n    ledgerFunding: leafServices.ledgerFunding,\n    waitForFirstJointState: leafServices.waitForFirstJointState,\n    jointChannelUpdate: leafServices.jointChannelUpdate\n  };\n\n  return {actions, services};\n};\n\nexport const machine = (store: Store) => Machine(config, options(store));\n","import {\n  Machine,\n  MachineConfig,\n  StateNodeConfig,\n  ActionTypes,\n  DoneInvokeEvent,\n  assign\n} from 'xstate';\nimport {filter, map, first} from 'rxjs/operators';\nimport _ from 'lodash';\nimport {\n  isVirtuallyFund,\n  StateVariables,\n  Outcome,\n  isSimpleEthAllocation,\n  simpleEthAllocation,\n  checkThat,\n  Zero,\n  BN\n} from '@statechannels/wallet-core';\n\nimport {Store} from '../store';\nimport {CHALLENGE_DURATION, HUB, ETH_ASSET_HOLDER_ADDRESS} from '../config';\nimport {MessagingServiceInterface} from '../messaging';\nimport {getDataAndInvoke} from '../utils';\n\nimport {SupportState, VirtualFundingAsLeaf, Depositing} from '.';\nconst PROTOCOL = 'create-and-fund';\nconst {add} = BN;\n\nexport type Init = {\n  channelId: string;\n  funding: 'Direct' | 'Virtual' | 'Ledger';\n};\n\nconst isDirect = (ctx: Init) => ctx.funding === 'Direct';\nconst isVirtual = (ctx: Init) => ctx.funding === 'Virtual';\nconst preFundSetup = getDataAndInvoke<Init, Service>(\n  {src: 'getPreFundSetup'},\n  {src: 'supportState'},\n  [\n    {target: 'direct', cond: isDirect},\n    {target: 'virtual', cond: isVirtual}\n  ]\n);\n\nconst direct: StateNodeConfig<any, any, any> = {\n  initial: 'depositing',\n  states: {\n    depositing: getDataAndInvoke<Init, Service>(\n      {src: 'getDepositingInfo'},\n      {src: 'depositing'},\n      'updateFunding'\n    ),\n    updateFunding: {invoke: {src: 'setFundingToDirect', onDone: 'done'}},\n    done: {type: 'final'}\n  },\n  onDone: 'postFundSetup'\n};\n\nconst triggerObjective = (store: Store) => async (ctx: Init): Promise<void> => {\n  const {channelConstants, supported: supportedState, myIndex} = await store.getEntry(\n    ctx.channelId\n  );\n  if (myIndex !== 0) return;\n\n  const {participants: targetParticipants} = channelConstants;\n  const participants = [...targetParticipants, HUB];\n\n  const {allocationItems} = checkThat(supportedState.outcome, isSimpleEthAllocation);\n\n  const outcome: Outcome = simpleEthAllocation([\n    allocationItems[0],\n    {destination: HUB.destination, amount: allocationItems.map(i => i.amount).reduce(add)},\n    allocationItems[1]\n  ]);\n\n  const stateVars: StateVariables = {turnNum: 0, outcome, appData: '0x', isFinal: false};\n\n  const {channelId: jointChannelId} = await store.createChannel(\n    participants,\n    CHALLENGE_DURATION,\n    stateVars\n  );\n\n  store.addObjective({\n    type: 'VirtuallyFund',\n    participants,\n    data: {jointChannelId, targetChannelId: ctx.channelId}\n  });\n};\n\n// Uses the any type to avoid flickering compile errors\nconst assignJointChannelId = assign<any>({\n  jointChannelId: (_, event: DoneInvokeEvent<{jointChannelId: string}>) => event.data.jointChannelId\n});\n\nconst reserveFunds = (\n  store: Store,\n  messagingService: MessagingServiceInterface\n) => async context => {\n  const channelEntry = await store.getEntry(context.channelId);\n  const {allocationItems} = checkThat(channelEntry.supported.outcome, isSimpleEthAllocation);\n  const playerAddress = await store.getAddress();\n  const playerDestination =\n    channelEntry.supported.participants.find(p => p.signingAddress === playerAddress)\n      ?.destination || '0x00';\n  const receive = allocationItems.find(a => a.destination !== playerDestination)?.amount || Zero;\n  const send = allocationItems.find(a => a.destination === playerDestination)?.amount || Zero;\n\n  const budget = await store.reserveFunds(ETH_ASSET_HOLDER_ADDRESS, context.channelId, {\n    receive,\n    send\n  });\n  await messagingService.sendBudgetNotification(budget);\n};\n\ntype VirtualFundingComplete = Init & {jointChannelId: string};\nconst virtual: StateNodeConfig<Init, any, any> = {\n  initial: 'reserveFunds',\n  entry: [triggerObjective.name],\n  states: {\n    reserveFunds: {invoke: {src: 'reserveFunds', onDone: 'virtualFunding'}},\n    virtualFunding: getDataAndInvoke<Init, Service>(\n      {src: 'getObjective'},\n      {src: 'virtualFunding', opts: {entry: 'assignJointChannelId'}},\n      'updateFunding'\n    ),\n    updateFunding: {invoke: {src: 'setFundingToVirtual', onDone: 'done'}},\n    done: {type: 'final'}\n  },\n  onDone: 'postFundSetup'\n};\n\nconst postFundSetup = getDataAndInvoke<Init, Service>(\n  {src: 'getPostFundSetup'},\n  {src: 'supportState'},\n  'success'\n);\n\nexport const config: MachineConfig<Init, any, any> = {\n  key: PROTOCOL,\n  initial: 'preFundSetup',\n\n  on: {[ActionTypes.ErrorCustom]: {target: 'failure'}},\n  states: {\n    preFundSetup,\n    direct,\n    virtual,\n    postFundSetup,\n    success: {type: 'final'},\n    failure: {}\n  }\n};\n\nexport const services = (store: Store, messagingService: MessagingServiceInterface) => ({\n  depositing: Depositing.machine(store),\n  supportState: SupportState.machine(store),\n  virtualFunding: VirtualFundingAsLeaf.machine(store),\n  getDepositingInfo: getDepositingInfo(store),\n  getPreFundSetup: getPreFundSetup(store),\n  getPostFundSetup: getPostFundSetup(store),\n  setFundingToDirect: setFundingToDirect(store),\n  setFundingToVirtual: setFundingToVirtual(store),\n  getObjective: getObjective(store),\n  reserveFunds: reserveFunds(store, messagingService)\n});\n\ntype Service = keyof ReturnType<typeof services>;\n\nconst options = (store: Store, messagingService: MessagingServiceInterface) => ({\n  services: services(store, messagingService),\n  actions: {\n    triggerObjective: triggerObjective(store),\n    assignJointChannelId\n  }\n});\n\nexport const machine = (store: Store, messagingService: MessagingServiceInterface) =>\n  Machine(config).withConfig(options(store, messagingService));\n\nconst getObjective = (store: Store) => (ctx: Init): Promise<VirtualFundingAsLeaf.Init> =>\n  store.objectiveFeed\n    .pipe(\n      filter(isVirtuallyFund),\n      map(\n        ({data}): VirtualFundingAsLeaf.Init => ({\n          targetChannelId: data.targetChannelId,\n          jointChannelId: data.jointChannelId\n        })\n      ),\n      filter(({targetChannelId}) => targetChannelId === ctx.channelId),\n      first()\n    )\n    .toPromise();\n\n/*\nIt's safe to use support state instead of advance-channel:\n- If the latest state that I support has turn `n`, then other participants can support a state\n  of turn at most `n + numParticipants - 1`\nIn the 2-party case,\n- if I support state 1, then 2 is the highest supported state, and the appData\n  cannot change\n- if I am player A, and I support 3 instead of 2, then 3 is the highest supported state,\n  since 4 needs to be signed by me\n- if I am player B, then I would sign state 3 using advanceChannel anyway\n*/\nconst getPreFundSetup = (store: Store) => (ctx: Init): Promise<SupportState.Init> =>\n  store\n    .channelUpdatedFeed(ctx.channelId)\n    .pipe(\n      map(e => _.sortBy(e.sortedStates, s => s.turnNum)[0]),\n      filter(s => s.turnNum === 0),\n      map(state => ({state})),\n      first()\n    )\n    .toPromise();\n\nconst getPostFundSetup = (store: Store) => (ctx: Init): Promise<SupportState.Init> =>\n  store\n    .channelUpdatedFeed(ctx.channelId)\n    .pipe(\n      map(e => _.sortBy(e.sortedStates, s => s.turnNum)[0]),\n      filter(s => s.turnNum === 0),\n      map(s => ({state: {...s, turnNum: 3}})),\n      first()\n    )\n    .toPromise();\n\nconst getDepositingInfo = (store: Store) => async ({channelId}: Init): Promise<Depositing.Init> => {\n  const {supported: supportedState, myIndex} = await store.getEntry(channelId);\n  const {allocationItems} = checkThat(supportedState.outcome, isSimpleEthAllocation);\n\n  const fundedAt = allocationItems.map(a => a.amount).reduce(add);\n  let depositAt = Zero;\n  for (let i = 0; i < allocationItems.length; i++) {\n    const {amount} = allocationItems[i];\n    if (i !== myIndex) depositAt = add(depositAt, amount);\n    else {\n      const totalAfterDeposit = add(depositAt, amount);\n      return {channelId, depositAt, totalAfterDeposit, fundedAt};\n    }\n  }\n\n  throw Error(`Could not find an allocation for participant id ${myIndex}`);\n};\n\nconst setFundingToDirect = (store: Store) => async (ctx: Init) =>\n  await store.setFunding(ctx.channelId, {type: 'Direct'});\n\nconst setFundingToVirtual = (store: Store) => async (ctx: VirtualFundingComplete) => {\n  await store.setFunding(ctx.channelId, {type: 'Virtual', jointChannelId: ctx.jointChannelId});\n};\n","import {\n  checkThat,\n  isSimpleEthAllocation,\n  simpleEthAllocation,\n  nextState,\n  isVirtualFunding,\n  isIndirectFunding,\n  isGuarantee,\n  BN\n} from '@statechannels/wallet-core';\nimport {StateNodeConfig, assign, DoneInvokeEvent, Machine, ServiceConfig} from 'xstate';\nimport _ from 'lodash';\n\nimport {ChannelLock} from '../store/store';\nimport {Store} from '../store';\nimport {getDataAndInvoke} from '../utils/helpers';\nimport {ETH_ASSET_HOLDER_ADDRESS} from '../config';\nimport {MessagingServiceInterface} from '../messaging';\n\nimport {OutcomeIdx, ParticipantIdx} from './virtual-funding-as-leaf';\n\nimport {SupportState} from '.';\n\nexport type Init = {targetChannelId: string};\nconst PROTOCOL = 'virtual-defunding-as-leaf';\n\nexport const enum Errors {\n  finalized = 'Ledger channel is finalized',\n  invalidOutcome = 'Invalid ledger channel outcome',\n  targetNotFinalized = 'Target channel not finalized',\n  noSupportedJointState = 'No supported state in joint channel'\n}\n\nconst enum Services {\n  checkChannelsService = 'checkChannelsService',\n  defundGuarantorInLedger = 'defundGuarantorInLedger',\n  finalJointChannelUpdate = 'finalJointChannelUpdate',\n  finalTargetState = 'finalTargetState',\n  supportState = 'supportState',\n  releaseFunds = 'releaseFunds',\n  acquireLock = 'acquireLock',\n  getApplicationDomain = 'getApplicationDomain'\n}\n\nconst checkChannelsService = (store: Store) => async (ctx: Init): Promise<ChannelIds> => {\n  const {funding: targetFunding} = await store.getEntry(ctx.targetChannelId);\n  const {jointChannelId} = checkThat(targetFunding, isVirtualFunding);\n\n  const {funding: jointFunding, myIndex} = await store.getEntry(jointChannelId);\n  const {guarantorChannelId} = checkThat(jointFunding, isGuarantee);\n  const role = myIndex === ParticipantIdx.A ? OutcomeIdx.A : OutcomeIdx.B;\n\n  const {funding: guarantorFunding} = await store.getEntry(guarantorChannelId);\n  const {ledgerId} = checkThat(guarantorFunding, isIndirectFunding);\n\n  return {jointChannelId, guarantorChannelId, ledgerId, role};\n};\n\ntype ChannelIds = {\n  jointChannelId: string;\n  guarantorChannelId: string;\n  ledgerId: string;\n  role: OutcomeIdx;\n};\ntype ChannelsSet = Init & ChannelIds;\n\nconst checkChannels: StateNodeConfig<ChannelsSet, any, any> = {\n  invoke: {src: checkChannelsService.name, onDone: 'closeTarget'},\n  exit: assign<ChannelsSet>((_: Init, {data}: DoneInvokeEvent<ChannelIds>) => data)\n};\n\nconst finalTargetState = (store: Store) => async (ctx: Init): Promise<SupportState.Init> => {\n  const {supported} = await store.getEntry(ctx.targetChannelId);\n  return {state: {...supported, turnNum: supported.turnNum + 1, isFinal: true}};\n};\n\nconst closeTarget: StateNodeConfig<any, any, any> = getDataAndInvoke(\n  {src: finalTargetState.name},\n  {src: Services.supportState},\n  'defundTarget'\n);\n\nconst finalJointChannelUpdate = (store: Store) => async (\n  ctx: ChannelsSet\n): Promise<SupportState.Init> => {\n  const {jointChannelId, targetChannelId} = ctx;\n\n  const {supported: targetChannelState} = await store.getEntry(targetChannelId);\n  if (!targetChannelState.isFinal) throw Error(Errors.targetNotFinalized);\n\n  const {supported: jointState} = await store.getEntry(jointChannelId);\n  if (!jointState) throw Error(Errors.noSupportedJointState);\n\n  const jointAllocation = checkThat(jointState.outcome, isSimpleEthAllocation).allocationItems;\n  const targetOutcome = checkThat(targetChannelState.outcome, isSimpleEthAllocation)\n    .allocationItems;\n  const outcome = simpleEthAllocation([\n    targetOutcome[0],\n    jointAllocation[OutcomeIdx.Hub],\n    targetOutcome[1]\n  ]);\n\n  return {state: nextState(jointState, outcome)};\n};\n\nconst defundTarget: StateNodeConfig<any, any, any> = _.merge(\n  getDataAndInvoke(\n    {src: finalJointChannelUpdate.name},\n    {src: Services.supportState},\n    'defundGuarantor'\n  ),\n  {exit: ['deleteTargetChannel']}\n);\n\nconst defundGuarantorInLedger = (store: Store) => async ({\n  jointChannelId,\n  ledgerId,\n  guarantorChannelId,\n  role\n}: ChannelsSet): Promise<SupportState.Init> => {\n  if ((await store.chain.getChainInfo(ledgerId)).finalized) throw Error(Errors.finalized);\n\n  const {supported: jointState} = await store.getEntry(jointChannelId);\n  const jAlloc = checkThat(jointState.outcome, isSimpleEthAllocation).allocationItems;\n\n  const {supported: ledgerState} = await store.getEntry(ledgerId);\n  const {allocationItems: lAlloc} = checkThat(ledgerState.outcome, isSimpleEthAllocation);\n  const ledgerWithoutGuarantor = _.filter(lAlloc, a => a.destination !== guarantorChannelId);\n\n  const [hub, leaf] = ledgerWithoutGuarantor.slice(0, 2);\n\n  const BadOutcome = new Error(Errors.invalidOutcome);\n  if (hub.destination !== jAlloc[OutcomeIdx.Hub].destination) throw BadOutcome;\n  if (leaf.destination !== jAlloc[role].destination) throw BadOutcome;\n\n  const outcome = simpleEthAllocation([\n    {destination: hub.destination, amount: BN.add(hub.amount, jAlloc[2 - role].amount)},\n    {destination: leaf.destination, amount: BN.add(leaf.amount, jAlloc[role].amount)},\n    ...ledgerWithoutGuarantor.slice(2)\n  ]);\n  return {state: nextState(ledgerState, outcome)};\n};\nexport {defundGuarantorInLedger};\n\nconst acquireLock = (store: Store) => ({ledgerId}: ChannelsSet): Promise<ChannelLock> =>\n  store.acquireChannelLock(ledgerId);\n\ntype WithLock = Init & {lock: ChannelLock};\n\nconst releaseLock = (ctx: WithLock) => ctx.lock.release();\n\nconst defundGuarantor: StateNodeConfig<any, any, any> = {\n  initial: 'acquireLock',\n  states: {\n    acquireLock: {\n      invoke: {src: acquireLock.name, onDone: 'ledgerUpdate'},\n      exit: assign<WithLock>({lock: (_, event: DoneInvokeEvent<ChannelLock>) => event.data})\n    },\n    ledgerUpdate: getDataAndInvoke(\n      {src: defundGuarantorInLedger.name},\n      {src: Services.supportState},\n      'done'\n    ),\n    done: {type: 'final'}\n  },\n  exit: ['deleteJointChannel', 'deleteGuarantorChannel', releaseLock.name],\n  onDone: 'releaseFundsFromBudget'\n};\n\nconst releaseFundsFromBudget: StateNodeConfig<any, any, any> = {\n  invoke: {\n    src: Services.releaseFunds,\n    onDone: {target: 'success'}\n  }\n};\n\nconst releaseFunds = (store: Store, messagingService: MessagingServiceInterface) => async (\n  context: ChannelsSet\n) => {\n  const budget = await store.releaseFunds(\n    ETH_ASSET_HOLDER_ADDRESS,\n    context.ledgerId,\n    context.targetChannelId\n  );\n  await messagingService.sendBudgetNotification(budget);\n};\n\nconst getApplicationDomain = (store: Store) => async (context: ChannelsSet) => {\n  const ledgerEntry = await store.getEntry(context.ledgerId);\n  if (!ledgerEntry.applicationDomain) {\n    throw new Error(`No app domain set for ledger channel ${context.ledgerId}`);\n  }\n  return ledgerEntry.applicationDomain;\n};\n\nexport const config: StateNodeConfig<any, any, any> = {\n  key: PROTOCOL,\n  initial: 'checkChannels',\n  states: {\n    checkChannels,\n    closeTarget,\n    defundTarget,\n    defundGuarantor,\n    releaseFundsFromBudget,\n    success: {type: 'final'}\n  }\n};\n\ntype WorkflowServices = Record<Services, ServiceConfig<any>>;\n\nconst services = (store: Store, messagingService: MessagingServiceInterface): WorkflowServices => ({\n  checkChannelsService: checkChannelsService(store),\n  acquireLock: acquireLock(store),\n  defundGuarantorInLedger: defundGuarantorInLedger(store),\n  finalJointChannelUpdate: finalJointChannelUpdate(store),\n  finalTargetState: finalTargetState(store),\n  supportState: SupportState.machine(store),\n  releaseFunds: releaseFunds(store, messagingService),\n  getApplicationDomain: getApplicationDomain(store)\n});\nconst options = (store: Store, messagingService: MessagingServiceInterface) => ({\n  services: services(store, messagingService),\n  actions: {releaseLock}\n});\n\nexport const machine = (store: Store, messagingService: MessagingServiceInterface) =>\n  Machine(config).withConfig(options(store, messagingService));\n","import {\n  StateNodeConfig,\n  ServiceConfig,\n  AnyEventObject,\n  Machine,\n  AssignAction,\n  StateMachine,\n  DoneInvokeEvent,\n  assign,\n  ConditionPredicate,\n  ActionTypes\n} from 'xstate';\nimport {\n  SimpleAllocation,\n  Objective,\n  Participant,\n  StateVariables,\n  checkThat,\n  isSimpleEthAllocation,\n  Zero,\n  BN\n} from '@statechannels/wallet-core';\n\nimport {Store} from '../store';\nimport {CHALLENGE_DURATION} from '../config';\nimport {getDataAndInvoke} from '../utils';\n\nimport * as Depositing from './depositing';\n\nimport {SupportState} from '.';\nconst {add} = BN;\n\ntype WorkflowActions = {\n  assignChannelId: AssignAction<WorkflowContext, DoneInvokeEvent<string>>;\n};\ntype WorkflowGuards = {\n  doesChannelIdExist: ConditionPredicate<WorkflowContext, WorkflowEvent>;\n};\nexport type WorkflowEvent = AnyEventObject;\nexport type WorkflowContext = {\n  initialOutcome: SimpleAllocation;\n  participants: Participant[];\n  ledgerId?: string;\n};\nexport type LedgerIdExists = WorkflowContext & {ledgerId: string};\nexport interface WorkflowServices extends Record<string, ServiceConfig<WorkflowContext>> {\n  createObjective: (context: LedgerIdExists, event: any) => Promise<void>;\n  initializeChannel: (context: WorkflowContext, event: WorkflowEvent) => Promise<string>;\n  supportState: StateMachine<any, any, any>;\n  getPreFundState: (context: LedgerIdExists, event: WorkflowEvent) => Promise<SupportState.Init>;\n  depositing: StateMachine<any, any, any>;\n  getDepositingInfo: (context: LedgerIdExists, event: any) => Promise<Depositing.Init>;\n}\n\nexport const config: StateNodeConfig<WorkflowContext, any, any> = {\n  initial: 'isChannelIdDefined',\n  on: {[ActionTypes.ErrorCustom]: {target: 'failure'}},\n  states: {\n    isChannelIdDefined: {\n      on: {\n        '': [{cond: 'doesChannelIdExist', target: 'supportPreFundState'}, {target: 'initialize'}]\n      }\n    },\n    initialize: {\n      initial: 'initializeChannel',\n\n      states: {\n        initializeChannel: {\n          invoke: {\n            src: 'initializeChannel',\n            onDone: {target: 'createObjective', actions: ['assignChannelId']}\n          }\n        },\n        createObjective: {\n          invoke: {\n            src: 'createObjective',\n\n            onDone: [{target: 'done'}]\n          }\n        },\n        done: {type: 'final'}\n      },\n      onDone: 'supportPreFundState'\n    },\n\n    supportPreFundState: getDataAndInvoke<WorkflowContext, any>(\n      {src: 'getPreFundState'},\n      {src: 'supportState'},\n      'fundChannel'\n    ),\n\n    fundChannel: getDataAndInvoke<WorkflowContext, any>(\n      {src: 'getDepositingInfo'},\n      {src: 'depositing'},\n      'done'\n    ),\n\n    done: {type: 'final'},\n    failure: {type: 'final'}\n  }\n};\n\nconst initializeChannel = (\n  store: Store\n): WorkflowServices['initializeChannel'] => async context => {\n  const {initialOutcome: outcome} = context;\n  const stateVars: StateVariables = {outcome, turnNum: 0, isFinal: false, appData: '0x00'};\n  const entry = await store.createChannel(context.participants, CHALLENGE_DURATION, stateVars);\n  await store.setFunding(entry.channelId, {type: 'Direct'});\n  await store.setLedger(entry.channelId);\n  return entry.channelId;\n};\n\nconst createObjective = (store: Store): WorkflowServices['createObjective'] => async context => {\n  const objective: Objective = {\n    type: 'FundLedger',\n    participants: context.participants,\n    data: {ledgerId: context.ledgerId}\n  };\n  return store.addObjective(objective);\n};\nconst getPreFundState = (store: Store): WorkflowServices['getPreFundState'] => async context => {\n  const {latestState} = await store.getEntry(context.ledgerId);\n  return {state: latestState};\n};\n\nconst getDepositingInfo = (\n  store: Store\n): WorkflowServices['getDepositingInfo'] => async context => {\n  const {supported, myIndex} = await store.getEntry(context.ledgerId);\n  const {allocationItems} = checkThat(supported?.outcome, isSimpleEthAllocation);\n\n  const fundedAt = allocationItems.map(a => a.amount).reduce(add);\n  const depositAt = myIndex === 0 ? allocationItems[0].amount : Zero;\n  return {channelId: context.ledgerId, depositAt, totalAfterDeposit: fundedAt, fundedAt};\n};\n\nexport const options = (\n  store: Store\n): {actions: WorkflowActions; services: WorkflowServices; guards: WorkflowGuards} => ({\n  actions: {\n    assignChannelId: assign({\n      ledgerId: (_, event: DoneInvokeEvent<string>) => event.data\n    })\n  },\n  guards: {\n    doesChannelIdExist: (context: WorkflowContext) => !!context.ledgerId\n  },\n  services: {\n    initializeChannel: initializeChannel(store),\n    supportState: SupportState.machine(store),\n    createObjective: createObjective(store),\n    depositing: Depositing.machine(store),\n    getDepositingInfo: getDepositingInfo(store),\n    getPreFundState: getPreFundState(store)\n  }\n});\n\nexport const mockGuards: WorkflowGuards = {\n  doesChannelIdExist: () => true\n};\n\nexport const mockOptions = {guards: mockGuards};\n\nexport const createAndFundLedgerWorkflow = (store: Store, context: WorkflowContext) =>\n  Machine(config)\n    .withConfig(options(store))\n    .withContext(context);\n","const PROTOCOL = 'virtual-defunding-as-hub';\nimport {\n  checkThat,\n  isSimpleEthAllocation,\n  BN,\n  isGuarantees,\n  isIndirectFunding,\n  AllocationItem\n} from '@statechannels/wallet-core';\nimport {StateNodeConfig, assign, DoneInvokeEvent, Machine} from 'xstate';\nimport {map, filter, tap, first} from 'rxjs/operators';\nimport _ from 'lodash';\n\nimport {getDataAndInvoke} from '../utils/helpers';\nimport {ChannelStoreEntry} from '../store/channel-store-entry';\nimport {Store} from '../store';\n\nimport {OutcomeIdx} from './virtual-funding-as-leaf';\nimport {defundGuarantorInLedger} from './virtual-defunding-as-leaf';\n\nimport {SupportState} from '.';\n\nexport type Init = {jointChannelId: string};\nconst {add} = BN;\n\ntype IDs = [string, string];\ntype ChannelIds = {guarantorChannelIds: IDs; ledgerChannelIds: IDs};\ntype ChannelsSet = Init & ChannelIds;\nconst enum Leaf {\n  A = 0,\n  B = 1\n}\n\nconst checkChannelsService = (store: Store) => async ({\n  jointChannelId\n}: Init): Promise<ChannelIds> => {\n  const {funding: jointFunding} = await store.getEntry(jointChannelId);\n  const {guarantorChannelIds} = checkThat(jointFunding, isGuarantees);\n\n  const {funding: leftGuarantorFunding} = await store.getEntry(guarantorChannelIds[Leaf.A]);\n  const {ledgerId: leftLedgerId} = checkThat(leftGuarantorFunding, isIndirectFunding);\n\n  const {funding: rightGuarantorFunding} = await store.getEntry(guarantorChannelIds[Leaf.B]);\n  const {ledgerId: rightLedgerId} = checkThat(rightGuarantorFunding, isIndirectFunding);\n\n  return {guarantorChannelIds, ledgerChannelIds: [leftLedgerId, rightLedgerId]};\n};\n\nconst checkChannels: StateNodeConfig<ChannelsSet, any, any> = {\n  invoke: {src: checkChannelsService.name, onDone: 'defundTarget'},\n  exit: assign<ChannelsSet>((_: Init, {data}: DoneInvokeEvent<ChannelIds>) => data)\n};\n\nconst finalJointChannelUpdate = (store: Store) => async ({\n  jointChannelId\n}: ChannelsSet): Promise<SupportState.Init> =>\n  store\n    .channelUpdatedFeed(jointChannelId)\n    .pipe(\n      // Wait for the new update\n      filter(({latest, supported}) => latest.turnNum > supported.turnNum),\n      // Validate the update\n      tap(({latest, supported}: ChannelStoreEntry) => {\n        const newItems = checkThat(latest.outcome, isSimpleEthAllocation).allocationItems;\n        const supportedItems = checkThat(supported.outcome, isSimpleEthAllocation).allocationItems;\n\n        const invariantHubAllocation = _.isEqual(newItems[1], supportedItems[1]);\n\n        if (!invariantHubAllocation) throw new Error('Hub allocation changed');\n\n        const amount = (i: AllocationItem) => i.amount;\n        const supportedAmount = supportedItems.map(amount).reduce(add);\n        const newAmount = newItems.map(amount).reduce(add);\n        const invariantTotal = supportedAmount === newAmount;\n\n        if (!invariantTotal) throw new Error('Total allocation changed');\n      }),\n      map(({latest}) => ({state: latest})),\n      first()\n    )\n    .toPromise();\n\nconst defundTarget: StateNodeConfig<any, any, any> = getDataAndInvoke(\n  {src: finalJointChannelUpdate.name},\n  {src: 'supportState'},\n  'defundGuarantors'\n);\n\nconst defundGuarantor = (leaf: Leaf, store: Store) => async ({\n  guarantorChannelIds,\n  jointChannelId,\n  ledgerChannelIds\n}: ChannelsSet) => {\n  const role = leaf === 0 ? OutcomeIdx.A : OutcomeIdx.B;\n  const {supported} = await store.getEntry(jointChannelId);\n  const {allocationItems} = checkThat(supported.outcome, isSimpleEthAllocation);\n  const targetChannelId = allocationItems[0].destination;\n\n  return defundGuarantorInLedger(store)({\n    role,\n    ledgerId: ledgerChannelIds[leaf],\n    guarantorChannelId: guarantorChannelIds[leaf],\n    jointChannelId,\n    targetChannelId\n  });\n};\nconst defundLeftGuarantor = (store: Store) => async (\n  ctx: ChannelsSet\n): Promise<SupportState.Init> => defundGuarantor(0, store)(ctx);\nconst defundRightGuarantor = (store: Store) => async (\n  ctx: ChannelsSet\n): Promise<SupportState.Init> => defundGuarantor(0, store)(ctx);\n\nconst supportState = (store: Store) => SupportState.machine(store);\n\nconst defundGuarantors: StateNodeConfig<any, any, any> = {\n  type: 'parallel',\n  states: {\n    defundLeft: getDataAndInvoke({src: defundLeftGuarantor.name}, {src: supportState.name}),\n    defundRight: getDataAndInvoke({src: defundRightGuarantor.name}, {src: supportState.name})\n  },\n  exit: 'deleteChannels',\n  onDone: 'success'\n};\n\nexport const config: StateNodeConfig<any, any, any> = {\n  key: PROTOCOL,\n  initial: 'checkChannels',\n  states: {\n    checkChannels,\n    defundTarget,\n    defundGuarantors,\n    success: {type: 'final'}\n  }\n};\n\nconst options = (store: Store) => ({\n  services: {\n    checkChannelsService: checkChannelsService(store),\n    defundLeftGuarantor: defundLeftGuarantor(store),\n    defundRightGuarantor: defundRightGuarantor(store),\n    finalJointChannelUpdate: finalJointChannelUpdate(store),\n    supportState: supportState(store)\n  }\n});\n\nexport const machine = (store: Store) => Machine(config).withConfig(options(store));\n","import {\n  assign,\n  createMachine,\n  DoneInvokeEvent,\n  State,\n  StateMachine,\n  StateSchema,\n  Guard,\n  spawn,\n  actions\n} from 'xstate';\nimport {map} from 'rxjs/operators';\n\nimport {ChannelChainInfo} from '../chain';\nimport {Store} from '../store';\n\nconst {log} = actions;\nexport interface Initial {\n  channelId: string;\n}\n\ninterface Transaction {\n  transactionId: string;\n}\n\ntype Typestate =\n  | {value: 'init'; context: Initial}\n  | {value: 'waitForResponseOrTimeout'; context: Initial & Transaction}\n  | {value: 'submitTransaction'; context: Initial}\n  | {value: 'retry'; context: Initial & Transaction}\n  | {value: 'waitMining'; context: Initial & Transaction}\n  | {value: 'done'; context: Initial}\n  | {value: 'failure'; context: Initial};\n\ntype Context = Typestate['context'];\n\ninterface Schema extends StateSchema<Context> {\n  states: {\n    init: {};\n    submitTransaction: {};\n    retry: {};\n    waitMining: {};\n    waitForResponseOrTimeout: {};\n    done: {};\n    failure: {};\n  };\n}\n\nexport type WorkflowState = State<Context, Event, Schema, Typestate>;\n\nexport type StateValue = keyof Schema['states'];\n\ninterface ChainEvent {\n  type: 'CHAIN_EVENT';\n  turnNumRecord: number;\n  finalizesAt: number;\n  finalized: boolean;\n}\n\nconst noChallengeOnchain: Guard<Initial, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'noChallengeOnchain',\n  predicate: (context, {finalizesAt}) => finalizesAt === 0\n};\n\n// const someOtherChallengeOnchain: Guard<Initial, ChainEvent> = {\n//   type: 'xstate.guard',\n//   name: 'myTurnNow',\n//   predicate: (context, event) => false // TODO: Add challenge state to context\n// };\n\nconst challengeOnchainAsExpected: Guard<Initial, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'challengeOnchainAsExpected',\n  predicate: (context, {finalizesAt, finalized}) => finalizesAt > 0 && !finalized\n};\n\nconst challengeFinalized: Guard<Initial, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'challengeFinalized',\n  predicate: (context, {finalized}) => finalized\n};\n\nconst submitChallengeTransaction = (store: Store) => async ({channelId}: Initial) => {\n  const {support, myAddress} = await store.getEntry(channelId);\n  const privateKey = await store.getPrivateKey(myAddress);\n  return await store.chain.challenge(support, privateKey);\n};\n\nconst observeOnChainChannelStorage = (store: Store, channelId: string) =>\n  store.chain.chainUpdatedFeed(channelId).pipe(\n    map<ChannelChainInfo, ChainEvent>(({finalized, channelStorage}) => ({\n      type: 'CHAIN_EVENT',\n      finalized,\n      ...channelStorage\n    }))\n  );\n\nconst setTransactionId = assign<Context, DoneInvokeEvent<string>>({\n  transactionId: (context, {data}) => data\n});\n\nexport const machine = (\n  store: Store,\n  context: Initial\n): StateMachine<Context, Schema, Event, Typestate> =>\n  createMachine<Context, Event, Typestate>({\n    context,\n\n    strict: true,\n    id: 'challenge-channel',\n    initial: 'init',\n\n    on: {\n      CHANNEL_UPDATED: {actions: log('CHANNEL_UPDATED sent to challenge channel machine')},\n      CHAIN_EVENT: [\n        {\n          target: 'waitForResponseOrTimeout',\n          cond: challengeOnchainAsExpected\n        },\n        {\n          target: 'done',\n          cond: challengeFinalized\n        }\n      ]\n    },\n\n    states: {\n      init: {\n        // TODO: Figure out how to make invoke work at root-level here. Seems to cause\n        // an infinite loop if entry is on the root-level of the machine.\n        entry: assign<any>({\n          chainWatcher: ({channelId}) => spawn(observeOnChainChannelStorage(store, channelId))\n        }),\n\n        on: {\n          CHAIN_EVENT: {\n            target: 'submitTransaction',\n            cond: noChallengeOnchain\n          }\n        }\n      },\n\n      waitForResponseOrTimeout: {},\n\n      submitTransaction: {\n        invoke: {\n          id: 'submitTransaction',\n          src: submitChallengeTransaction(store),\n          onDone: {\n            target: 'waitMining',\n            actions: setTransactionId\n          }\n          // onError: {target: 'retry'}\n        }\n      },\n\n      waitMining: {},\n\n      retry: {\n        on: {\n          USER_APPROVES_RETRY: {target: 'submitTransaction'},\n          USER_REJECTS_RETRY: {target: 'failure'}\n        }\n      },\n\n      done: {\n        id: 'done',\n        type: 'final'\n      },\n\n      failure: {\n        id: 'failure',\n        type: 'final'\n      }\n    }\n  });\n","import {\n  StateSchema,\n  StateMachine,\n  ActionObject,\n  createMachine,\n  Guard,\n  assign,\n  DoneInvokeEvent,\n  Interpreter\n} from 'xstate';\nimport {\n  DomainBudget,\n  Participant,\n  SimpleAllocation,\n  AssetBudget,\n  State as ChannelState,\n  statesEqual,\n  checkThat,\n  exists,\n  simpleEthAllocation,\n  BN,\n  Uint256,\n  serializeDomainBudget\n} from '@statechannels/wallet-core';\nimport {filter, map, first} from 'rxjs/operators';\n\nimport {ChannelChainInfo} from '../chain';\nimport {Store} from '../store';\nimport {MessagingServiceInterface} from '../messaging';\nimport {sendUserDeclinedResponse, hideUI, displayUI} from '../utils/workflow-utils';\nimport {CHALLENGE_DURATION, ETH_ASSET_HOLDER_ADDRESS} from '../config';\nconst {add} = BN;\ninterface ChainEvent {\n  type: 'CHAIN_EVENT';\n  blockNum: number;\n  balance: Uint256;\n}\n\ntype Event =\n  | {type: 'USER_APPROVES_BUDGET'}\n  | {type: 'USER_REJECTS_BUDGET'}\n  | {type: 'USER_APPROVES_RETRY'}\n  | {type: 'USER_REJECTS_RETRY'}\n  | {type: 'SUFFICIENT_FUNDS_DETECTED'}\n  | {type: 'INSUFFICIENT_FUNDS_DETECTED'}\n  | ChainEvent;\n\ninterface Initial {\n  budget: DomainBudget;\n  player: Participant;\n  hub: Participant;\n  requestId: number;\n}\ninterface LedgerExists extends Initial {\n  ledgerId: string;\n  ledgerState: ChannelState;\n}\ninterface Deposit {\n  depositAt: Uint256;\n  totalAfterDeposit: Uint256;\n  fundedAt: Uint256;\n}\n\ninterface Chain {\n  ledgerTotal: Uint256;\n  lastChangeBlockNum: number;\n  currentBlockNum: number;\n}\n\ninterface Transaction {\n  transactionId: string;\n}\n\ntype Typestate =\n  | {value: 'waitForUserApproval'; context: Initial}\n  | {value: {waitForSufficientFunds: 'init'}; context: Initial}\n  | {value: {waitForSufficientFunds: 'waitForFunds'}; context: Initial}\n  | {value: 'createLedger'; context: Initial}\n  | {value: 'createBudget'; context: Initial}\n  | {value: 'waitForPreFS'; context: LedgerExists}\n  | {value: {deposit: 'init'}; context: LedgerExists & Deposit}\n  | {value: {deposit: 'waitTurn'}; context: LedgerExists & Deposit & Chain}\n  | {value: {deposit: 'submitTransaction'}; context: LedgerExists & Deposit & Chain}\n  | {value: {deposit: 'retry'}; context: LedgerExists & Deposit & Chain}\n  | {value: {deposit: 'waitMining'}; context: LedgerExists & Deposit & Chain & Transaction}\n  | {value: {deposit: 'waitFullyFunded'}; context: LedgerExists & Deposit & Chain}\n  | {value: 'done'; context: LedgerExists}\n  | {value: 'failure'; context: Initial};\n\ntype Context = Typestate['context'];\n\nexport interface Schema extends StateSchema<Context> {\n  states: {\n    waitForSufficientFunds: {};\n    createLedger: {};\n    createBudget: {};\n    waitForPreFS: {};\n    deposit: {\n      states: {\n        init: {};\n        waitTurn: {};\n        submitTransaction: {};\n        retry: {};\n        waitMining: {};\n        waitFullyFunded: {};\n      };\n    };\n    done: {};\n    failure: {};\n  };\n}\n\nexport const machine = (\n  store: Store,\n  messagingService: MessagingServiceInterface,\n  context: Initial\n): StateMachine<Context, Schema, Event, Typestate> =>\n  createMachine<Context, Event, Typestate>({\n    id: 'approve-budget-and-fund',\n    context,\n    initial: 'waitForUserApproval',\n    entry: displayUI(messagingService),\n    states: {\n      waitForUserApproval: {\n        on: {\n          USER_APPROVES_BUDGET: {target: 'waitForSufficientFunds'},\n          USER_REJECTS_BUDGET: {target: 'failure'}\n        }\n      },\n\n      createLedger: {\n        invoke: {\n          id: 'createLedger',\n          src: createLedger(store),\n          onDone: {target: 'waitForPreFS', actions: setLedgerInfo}\n        }\n      },\n      waitForPreFS: {\n        invoke: {\n          id: 'subscribeToLedgerUpdates',\n          src: notifyWhenPreFSSupported(store),\n          onDone: {target: 'deposit', actions: assignDepositingInfo}\n        }\n      },\n      createBudget: {\n        invoke: {\n          id: 'createBudget',\n          src: createBudget(store, messagingService),\n          onDone: {target: 'done'}\n        }\n      },\n      waitForSufficientFunds: {\n        initial: 'init',\n        invoke: {\n          id: 'subscribeToBalanceUpdates',\n          src: notifyWhenSufficientFunds(store)\n        },\n        states: {\n          init: {},\n          waitForFunds: {}\n        },\n        on: {\n          INSUFFICIENT_FUNDS_DETECTED: {target: '.waitForFunds'},\n          SUFFICIENT_FUNDS_DETECTED: {target: 'createLedger'}\n        }\n      },\n      deposit: {\n        initial: 'init',\n        invoke: {\n          id: 'observeChain',\n          src: observeLedgerOnChainBalance(store)\n        },\n        on: {\n          CHAIN_EVENT: [\n            {target: 'createBudget', actions: assignChainData, cond: fullAmountConfirmed},\n            {target: '.waitFullyFunded', actions: assignChainData, cond: myAmountConfirmed}\n          ]\n        },\n        states: {\n          init: {\n            on: {\n              CHAIN_EVENT: [\n                {target: 'submitTransaction', actions: assignChainData, cond: myTurnNow},\n                {target: 'waitTurn', actions: assignChainData, cond: notMyTurnYet}\n              ]\n            }\n          },\n          waitTurn: {\n            on: {\n              CHAIN_EVENT: [\n                {target: 'submitTransaction', actions: assignChainData, cond: myTurnNow}\n              ]\n            }\n          },\n          submitTransaction: {\n            invoke: {\n              id: 'submitTransaction',\n              src: submitDepositTransaction(store),\n              onDone: {target: 'waitMining', actions: setTransactionId}\n              // onError: {target: 'retry'}\n            }\n          },\n          retry: {\n            on: {\n              USER_APPROVES_RETRY: {target: 'submitTransaction'},\n              USER_REJECTS_RETRY: {target: '#failure'}\n            }\n          },\n          waitMining: {},\n          waitFullyFunded: {}\n        }\n      },\n      done: {\n        id: 'done',\n        type: 'final',\n        entry: [hideUI(messagingService), sendResponse(messagingService)]\n      },\n      failure: {\n        type: 'final',\n        id: 'failure',\n        entry: [hideUI(messagingService), sendUserDeclinedResponse(messagingService)]\n      }\n    }\n  });\n\ninterface LedgerInitRetVal {\n  ledgerId: string;\n  ledgerState: ChannelState;\n}\nconst createBudget = (store: Store, messagingService: MessagingServiceInterface) => async (\n  context: Initial\n): Promise<void> => {\n  // create budget\n  await store.createBudget(context.budget);\n  await messagingService.sendBudgetNotification(context.budget);\n};\nconst createLedger = (store: Store) => async (context: Initial): Promise<LedgerInitRetVal> => {\n  // create ledger\n  const initialOutcome = convertPendingBudgetToAllocation(context);\n  const participants = [context.player, context.hub];\n\n  const stateVars = {outcome: initialOutcome, turnNum: 0, isFinal: false, appData: '0x00'};\n  const entry = await store.createChannel(participants, CHALLENGE_DURATION, stateVars);\n  const ledgerId = entry.channelId;\n  await store.setFunding(entry.channelId, {type: 'Direct'});\n  await store.setLedger(entry.channelId);\n  await store.setapplicationDomain(ledgerId, context.budget.domain);\n  await store.addObjective({\n    type: 'FundLedger',\n    participants: participants,\n    data: {ledgerId}\n  });\n\n  return {\n    ledgerId,\n    ledgerState: entry.latestState\n  };\n};\n\nconst setLedgerInfo = assign<Context, DoneInvokeEvent<LedgerInitRetVal>>({\n  ledgerId: (context, event) => event.data.ledgerId,\n  ledgerState: (context, event) => event.data.ledgerState\n});\n\nfunction convertPendingBudgetToAllocation({hub, player, budget}: Context): SimpleAllocation {\n  // TODO: Eventually we will need to support more complex budgets\n  if (Object.keys(budget.forAsset).length !== 1) {\n    throw new Error('Cannot handle mixed budget');\n  }\n  // todo: this throws if the budget is undefined and casts it to a AssetBudget otherwise\n  // maybe this should be called assertBudgetExists ??\n  const ethBudget = checkThat<AssetBudget>(budget.forAsset[ETH_ASSET_HOLDER_ADDRESS], exists);\n  const playerItem = {\n    destination: player.destination,\n    amount: ethBudget.availableSendCapacity\n  };\n  const hubItem = {\n    destination: hub.destination,\n    amount: ethBudget.availableReceiveCapacity\n  };\n  return simpleEthAllocation([hubItem, playerItem]);\n}\n\nconst sendResponse = (\n  messagingService: MessagingServiceInterface\n): ActionObject<Context, Event> => ({\n  type: 'sendResponse',\n  exec: context =>\n    messagingService.sendResponse(context.requestId, serializeDomainBudget(context.budget))\n});\n\nconst assignDepositingInfo = assign<Context>({\n  // this is inefficient, but if use the other style of xstate assign, the devtools break ...\n  depositAt: context => calculateDepositInfo(context).depositAt,\n  totalAfterDeposit: context => calculateDepositInfo(context).totalAfterDeposit,\n  fundedAt: context => calculateDepositInfo(context).fundedAt\n});\n\nconst calculateDepositInfo = (context: Context) => {\n  const ethBudget = checkThat<AssetBudget>(\n    context.budget.forAsset[ETH_ASSET_HOLDER_ADDRESS],\n    exists\n  );\n  const ourAmount = ethBudget.availableSendCapacity;\n  const hubAmount = ethBudget.availableSendCapacity;\n  const totalAmount = add(ourAmount, hubAmount);\n\n  const depositAt = hubAmount; // hub goes first\n  const totalAfterDeposit = totalAmount;\n  const fundedAt = totalAmount;\n  return {depositAt, totalAfterDeposit, fundedAt};\n};\n\nconst notifyWhenPreFSSupported = (store: Store) => ({ledgerState, ledgerId}: LedgerExists) =>\n  store\n    .channelUpdatedFeed(ledgerId)\n    .pipe(\n      filter(({isSupported}) => isSupported),\n      filter(({supported}) => statesEqual(ledgerState, supported)), //store the hash?\n      map(() => 'SUPPORTED'),\n      first()\n    )\n    .toPromise();\n\nconst notifyWhenSufficientFunds = (store: Store) => ({budget}: Initial) => {\n  const ethBudget = checkThat<AssetBudget>(budget.forAsset[ETH_ASSET_HOLDER_ADDRESS], exists);\n  if (!store.chain.selectedAddress) {\n    throw new Error('No selected address');\n  }\n  const depositAmount = ethBudget.availableSendCapacity;\n  return store.chain.balanceUpdatedFeed(store.chain.selectedAddress).pipe(\n    map(b => ({\n      type: BN.gte(b, depositAmount) ? 'SUFFICIENT_FUNDS_DETECTED' : 'INSUFFICIENT_FUNDS_DETECTED'\n    }))\n  );\n};\n\nconst observeLedgerOnChainBalance = (store: Store) => ({ledgerId}: LedgerExists) =>\n  store.chain.chainUpdatedFeed(ledgerId).pipe(\n    map<ChannelChainInfo, ChainEvent>(({amount: balance, blockNum}) => ({\n      type: 'CHAIN_EVENT',\n      balance,\n      blockNum\n    }))\n  );\n\n// // for now don't wait for any number of blocks (until the chain is reporting blockNum)\nconst fullAmountConfirmed: Guard<Deposit, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'fullAmountConfirmed',\n  predicate: (context, event) => BN.gte(event.balance, context.fundedAt)\n};\nconst myTurnNow: Guard<Deposit, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'myTurnNow',\n  predicate: (context, event) =>\n    BN.gte(event.balance, context.depositAt) && BN.lt(event.balance, context.totalAfterDeposit)\n};\nconst notMyTurnYet: Guard<Deposit, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'notMyTurnYet',\n  predicate: (context, event) => BN.lt(event.balance, context.depositAt)\n};\nconst myAmountConfirmed: Guard<Deposit, ChainEvent> = {\n  type: 'xstate.guard',\n  name: 'myAmountConfirmed',\n  predicate: (context, event) =>\n    BN.gte(event.balance, context.totalAfterDeposit) && BN.lt(event.balance, context.fundedAt)\n};\n\nconst assignChainData = assign<Context, ChainEvent>({\n  ledgerTotal: (context, event: ChainEvent) => event.balance,\n  currentBlockNum: (context, event: ChainEvent) => event.blockNum,\n  lastChangeBlockNum: (context, event: ChainEvent) =>\n    context.ledgerTotal && context.ledgerTotal === event.balance\n      ? context.lastChangeBlockNum\n      : event.blockNum\n});\n\nconst setTransactionId = assign<Context, DoneInvokeEvent<string>>({\n  transactionId: (context, event) => event.data\n});\n\nconst submitDepositTransaction = (store: Store) => async (\n  ctx: LedgerExists & Deposit & Chain\n): Promise<string | undefined> => {\n  const amount = BN.sub(ctx.totalAfterDeposit, ctx.ledgerTotal);\n  if (BN.lte(amount, 0)) {\n    // sanity check: we shouldn't be in this state, if this is the case\n    throw new Error(\n      `Something is wrong! Shouldn't be trying to deposit when the remaining amount is ${amount.toString()}.`\n    );\n  }\n\n  return store.chain.deposit(ctx.ledgerId, BN.from(ctx.ledgerTotal), amount);\n};\n\nexport type ApproveBudgetAndFundService = Interpreter<Context, any, Event, Typestate>;\n","import {\n  ServiceConfig,\n  StateMachine,\n  Machine,\n  ActionFunction,\n  DoneInvokeEvent,\n  assign,\n  MachineConfig,\n  AssignAction,\n  Interpreter\n} from 'xstate';\nimport {\n  outcomesEqual,\n  Participant,\n  Objective,\n  CloseLedger,\n  DomainBudget,\n  BN\n} from '@statechannels/wallet-core';\nimport {map, filter} from 'rxjs/operators';\n\nimport {ChannelChainInfo} from '../chain';\nimport {Store} from '../store';\nimport {MessagingServiceInterface} from '../messaging';\nimport {getDataAndInvoke} from '../utils';\nimport {CommonWorkflowActions, commonWorkflowActions, CommonActions} from '../utils/workflow-utils';\n\nimport {SupportState} from '.';\n\ninterface Initial {\n  requestId: number;\n  opponent: Participant;\n  player: Participant;\n  domain: string;\n}\ninterface BudgetExists extends Initial {\n  budget: DomainBudget;\n}\ninterface LedgerExists extends BudgetExists {\n  ledgerId: string;\n}\n\ninterface Transaction {\n  transactionId: string;\n}\ninterface FundsWithdrawn {\n  type: 'FUNDS_WITHDRAWN';\n}\n\ntype WorkflowTypeState =\n  | {value: 'fetchBudget'; context: Initial}\n  | {value: 'waitForUserApproval'; context: BudgetExists}\n  | {value: 'createObjective'; context: LedgerExists}\n  | {value: {closeLedger: 'constructFinalState'}; context: LedgerExists}\n  | {value: {closeLedger: 'supportState'}; context: LedgerExists}\n  | {value: {closeLedger: 'done'}; context: LedgerExists}\n  | {value: {withdraw: 'submitTransaction'}; context: LedgerExists}\n  | {value: {withdraw: 'waitMining'}; context: LedgerExists & Transaction}\n  | {value: {withdraw: 'done'}; context: LedgerExists}\n  | {value: 'done'; context: LedgerExists}\n  | {value: 'clearBudget'; context: LedgerExists}\n  | {value: 'budgetFailure'; context: Initial}\n  | {value: 'userDeclinedFailure'; context: Initial};\n\nexport type WorkflowContext = WorkflowTypeState['context'];\n\nexport type WorkflowEvent =\n  | UserApproves\n  | UserRejects\n  | DoneInvokeEvent<CloseLedger>\n  | DoneInvokeEvent<LedgerExists>\n  | DoneInvokeEvent<DomainBudget>\n  | DoneInvokeEvent<string>\n  | FundsWithdrawn;\ninterface UserApproves {\n  type: 'USER_APPROVES_CLOSE';\n}\ninterface UserRejects {\n  type: 'USER_REJECTS_CLOSE';\n}\nenum Actions {\n  sendResponse = 'sendResponse',\n  assignLedgerId = 'assignLedgerId',\n  setTransactionId = 'setTransactionId',\n  assignBudget = 'assignBudget'\n}\n\nenum Services {\n  constructFinalState = 'constructFinalState',\n  supportState = 'supportState',\n  submitWithdrawTransaction = 'submitWithdrawTransaction',\n  createObjective = 'createObjective',\n  observeFundsWithdrawal = 'observeFundsWithdrawal',\n  fetchBudget = 'fetchBudget',\n  clearBudget = 'clearBudget'\n}\n\nexport type WorkflowActions = CommonWorkflowActions &\n  Record<\n    Actions,\n    ActionFunction<WorkflowContext, WorkflowEvent> | AssignAction<WorkflowContext, WorkflowEvent>\n  >;\nexport type WorkflowServices = Record<Services, ServiceConfig<WorkflowContext>>;\n\nexport const config: MachineConfig<WorkflowContext, any, WorkflowEvent> = {\n  id: 'close-and-withdraw',\n\n  initial: 'fetchBudget',\n  states: {\n    fetchBudget: {\n      invoke: {\n        src: Services.fetchBudget,\n        onDone: {target: 'waitForUserApproval', actions: [Actions.assignBudget]}\n      }\n    },\n    waitForUserApproval: {\n      entry: [CommonActions.displayUI],\n      on: {\n        USER_APPROVES_CLOSE: {target: 'createObjective'},\n        USER_REJECTS_CLOSE: {target: 'userDeclinedFailure'}\n      }\n    },\n\n    createObjective: {\n      invoke: {\n        src: Services.createObjective,\n        onDone: {target: 'closeLedger', actions: [Actions.assignLedgerId]}\n      }\n    },\n    closeLedger: getDataAndInvoke<LedgerExists>(\n      {src: Services.constructFinalState},\n      {src: Services.supportState},\n      'withdraw'\n    ) as any,\n    withdraw: {\n      initial: 'submitTransaction',\n      on: {\n        FUNDS_WITHDRAWN: 'clearBudget'\n      },\n      invoke: {\n        id: 'observeChain',\n        src: Services.observeFundsWithdrawal\n      },\n      states: {\n        submitTransaction: {\n          invoke: {\n            id: 'submitTransaction',\n            src: Services.submitWithdrawTransaction,\n            onDone: {\n              target: 'waitMining',\n              actions: [Actions.setTransactionId]\n            }\n          }\n        },\n        waitMining: {}\n      }\n    },\n    clearBudget: {\n      invoke: {src: Services.clearBudget, onDone: 'done', onError: 'budgetFailure'}\n    },\n    done: {type: 'final', entry: [Actions.sendResponse, CommonActions.hideUI]},\n    userDeclinedFailure: {\n      type: 'final',\n      entry: [CommonActions.hideUI, CommonActions.sendUserDeclinedErrorResponse]\n    },\n    budgetFailure: {\n      type: 'final',\n      entry: [CommonActions.hideUI] /* TODO Should we send a response?  */\n    }\n  }\n};\n\nconst constructFinalState = (store: Store) => async ({opponent: hub}) => {\n  const {latestSignedByMe: latestSupportedByMe, latest} = await store.getLedger(hub.participantId);\n\n  // If we've received a new final state that matches our outcome we support that\n  if (latest.isFinal && outcomesEqual(latestSupportedByMe.outcome, latest.outcome)) {\n    return {state: latest};\n  }\n  // Otherwise send out our final state that we support\n  if (latestSupportedByMe.isFinal) {\n    return {state: latestSupportedByMe};\n  }\n  // Otherwise create a new final state\n  return {\n    state: {\n      ...latestSupportedByMe,\n      turnNum: latestSupportedByMe.turnNum + 1,\n      isFinal: true\n    }\n  };\n};\n\nconst submitWithdrawTransaction = (store: Store) => async context => {\n  // TODO: Should we just fetch this once and store on the context\n  const ledgerEntry = await store.getLedger(context.opponent.participantId);\n  if (!ledgerEntry.hasConclusionProof) {\n    throw new Error(`Channel ${ledgerEntry.channelId} is not finalized`);\n  }\n  return store.chain.finalizeAndWithdraw(ledgerEntry.support);\n};\n\nconst createObjective = (store: Store) => async context => {\n  const ledgerEntry = await store.getLedger(context.opponent.participantId);\n\n  const objective: Objective = {\n    type: 'CloseLedger',\n    participants: [context.player, context.opponent],\n    data: {ledgerId: ledgerEntry.channelId}\n  };\n  await store.addObjective(objective);\n  return objective;\n};\nconst observeFundsWithdrawal = (store: Store) => ({ledgerId}: LedgerExists) =>\n  store.chain.chainUpdatedFeed(ledgerId).pipe(\n    filter(c => BN.eq(c.amount, 0)),\n    map<ChannelChainInfo, FundsWithdrawn>(() => ({type: 'FUNDS_WITHDRAWN'}))\n  );\n\nconst clearBudget = (store: Store): ServiceConfig<Initial> => async context => {\n  await store.clearBudget(context.domain);\n};\n\nconst fetchBudget = (store: Store): ServiceConfig<Initial> => async context =>\n  store.getBudget(context.domain);\n\nconst assignBudget = (): AssignAction<Initial, DoneInvokeEvent<DomainBudget>> =>\n  assign((context, event) => ({\n    ...context,\n    budget: event.data\n  }));\n\nconst options = (\n  store: Store,\n  messagingService: MessagingServiceInterface\n): {services: WorkflowServices; actions: WorkflowActions} => ({\n  services: {\n    constructFinalState: constructFinalState(store),\n    supportState: SupportState.machine(store),\n    submitWithdrawTransaction: submitWithdrawTransaction(store),\n    createObjective: createObjective(store),\n    observeFundsWithdrawal: observeFundsWithdrawal(store),\n    clearBudget: clearBudget(store),\n    fetchBudget: fetchBudget(store)\n  },\n  actions: {\n    ...commonWorkflowActions(messagingService),\n    assignBudget: assignBudget(),\n    setTransactionId: assign({\n      transactionId: (context, event: DoneInvokeEvent<string>) => event.data\n    }),\n\n    sendResponse: async context =>\n      await messagingService.sendResponse(context.requestId, {success: true}),\n\n    assignLedgerId: assign((context: Initial, event: DoneInvokeEvent<CloseLedger>) => ({\n      ...context,\n      ledgerId: event.data.data.ledgerId\n    }))\n  }\n});\nexport const workflow = (\n  store: Store,\n  messagingService: MessagingServiceInterface,\n  context: WorkflowContext\n): StateMachine<WorkflowContext, any, WorkflowEvent, WorkflowTypeState> =>\n  Machine(config)\n    .withConfig(options(store, messagingService))\n    .withContext(context);\n\nexport type CloseLedgerAndWithdrawService = Interpreter<\n  WorkflowContext,\n  any,\n  WorkflowEvent,\n  WorkflowTypeState\n>;\n","import {\n  MachineConfig,\n  Machine,\n  assign,\n  Action,\n  AssignAction,\n  spawn,\n  Condition,\n  DoneInvokeEvent,\n  StateSchema,\n  StateMachine,\n  State\n} from 'xstate';\nimport {filter, map, distinctUntilChanged} from 'rxjs/operators';\nimport {StateVariables, serializeChannelEntry} from '@statechannels/wallet-core';\nimport {FundingStrategy, StateChannelsError} from '@statechannels/client-api-schema';\nimport _ from 'lodash';\n\nimport {\n  PlayerStateUpdate,\n  ChannelUpdated,\n  JoinChannelEvent,\n  CreateChannelEvent,\n  PlayerRequestConclude,\n  OpenEvent\n} from '../event-types';\nimport {ChannelStoreEntry} from '../store/channel-store-entry';\nimport {Store, Errors} from '../store';\nimport {unreachable} from '../utils';\nimport {logger} from '../logger';\nimport {CONCLUDE_TIMEOUT} from '../constants';\nimport {createMockGuard} from '../utils/workflow-utils';\nimport {MessagingServiceInterface} from '../messaging';\n\nimport {ConcludeChannel, CreateAndFund, ChallengeChannel, Confirm as CCC} from './';\n\nexport interface WorkflowContext {\n  applicationDomain: string;\n  fundingStrategy: FundingStrategy;\n  channelId?: string;\n  requestObserver?: any;\n  updateObserver?: any;\n  requestId?: number;\n  channelParams?: Omit<CreateChannelEvent, 'type'>;\n}\n\ntype CreateInit = WorkflowContext & CreateChannelEvent;\ntype JoinInit = WorkflowContext & {channelId: string; type: 'JOIN_CHANNEL'};\nexport type Init = CreateInit | JoinInit;\ntype ChannelIdExists = WorkflowContext & {channelId: string};\ntype RequestIdExists = WorkflowContext & {requestId: number};\n\ntype Guards<Keys extends string> = Record<Keys, Condition<WorkflowContext, WorkflowEvent>>;\ntype WorkflowGuards = Guards<\n  | 'channelOpen'\n  | 'channelClosing'\n  | 'channelClosed'\n  | 'channelChallenging'\n  | 'isDirectFunding'\n  | 'isLedgerFunding'\n  | 'isVirtualFunding'\n  | 'amCreator'\n  | 'amJoiner'\n>;\n\nexport interface WorkflowActions {\n  sendChallengeChannelResponse: Action<RequestIdExists & ChannelIdExists, any>;\n  sendCreateChannelResponse: Action<RequestIdExists & ChannelIdExists, any>;\n  sendJoinChannelResponse: Action<RequestIdExists & ChannelIdExists, any>;\n  assignChannelId: Action<WorkflowContext, any>;\n  assignRequestId: Action<WorkflowContext, any>;\n  displayUi: Action<WorkflowContext, any>;\n  hideUi: Action<WorkflowContext, any>;\n  sendChannelUpdatedNotification: Action<WorkflowContext, any>;\n  spawnObservers: AssignAction<ChannelIdExists, any>;\n  updateChannel: Action<WorkflowContext, PlayerStateUpdate>;\n  closeChannel: Action<WorkflowContext, PlayerRequestConclude>;\n}\n\nexport type WorkflowEvent =\n  | PlayerRequestConclude\n  | PlayerStateUpdate\n  | OpenEvent\n  | ChannelUpdated\n  | JoinChannelEvent\n  | DoneInvokeEvent<keyof WorkflowServices>;\n\nexport type WorkflowServices = {\n  setapplicationDomain(ctx: ChannelIdExists, e: JoinChannelEvent): Promise<void>;\n  createChannel: (context: WorkflowContext, event: WorkflowEvent) => Promise<string>;\n  signFinalStateIfMyTurn: (context: ChannelIdExists) => Promise<any>;\n  invokeClosingProtocol: (\n    context: ChannelIdExists\n  ) => StateMachine<ConcludeChannel.Init, any, any, any>;\n  invokeChallengingProtocol: (\n    context: ChannelIdExists\n  ) => StateMachine<ChallengeChannel.Initial, any, any, any>;\n  invokeCreateChannelAndFundProtocol: StateMachine<any, any, any, any>;\n  invokeCreateChannelConfirmation: CCC.WorkflowMachine;\n};\n\ninterface WorkflowStateSchema extends StateSchema<WorkflowContext> {\n  states: {\n    branchingOnFundingStrategy: {};\n    confirmingWithUser: {};\n    creatingChannel: {};\n    joiningChannel: {};\n    openChannelAndFundProtocol: {};\n    running: {};\n    sendChallenge: {};\n    closing: {};\n    done: {};\n    failure: {};\n    fundingChannel: {};\n  };\n}\n\nexport type StateValue = keyof WorkflowStateSchema['states'];\n\nexport type WorkflowState = State<WorkflowContext, WorkflowEvent, WorkflowStateSchema, any>;\n\nconst signFinalStateIfMyTurn = (store: Store) => async ({channelId}: ChannelIdExists) =>\n  store.updateChannel(channelId, {isFinal: true});\n\nconst generateConfig = (\n  actions: WorkflowActions,\n  guards: WorkflowGuards\n): MachineConfig<WorkflowContext, WorkflowStateSchema, WorkflowEvent> => ({\n  id: 'application-workflow',\n  initial: 'joiningChannel',\n  on: {CHANNEL_UPDATED: {actions: [actions.sendChannelUpdatedNotification]}},\n  states: {\n    joiningChannel: {\n      initial: 'joining',\n      states: {\n        failure: {},\n        joining: {\n          on: {\n            '': [\n              {target: 'failure', cond: guards.isLedgerFunding}, // TODO: Should we even support ledger funding?\n              {target: 'done', cond: guards.amCreator}\n            ],\n            JOIN_CHANNEL: {\n              target: 'settingDomain',\n              actions: [actions.assignRequestId, actions.sendJoinChannelResponse]\n            }\n          }\n        },\n        settingDomain: {invoke: {src: 'setapplicationDomain', onDone: 'done'}},\n        done: {type: 'final'}\n      },\n      onDone: [\n        {target: 'confirmingWithUser', cond: guards.isDirectFunding},\n        {target: 'creatingChannel', cond: guards.isVirtualFunding}\n      ]\n    },\n    confirmingWithUser: {\n      // FIXME We should keep track of whether the UI was turned on in the context.\n      // That way, at the end, we know whether we have to send hideUI\n      entry: [actions.displayUi, 'assignUIState'],\n      invoke: {src: 'invokeCreateChannelConfirmation', onDone: 'creatingChannel'}\n    },\n    creatingChannel: {\n      on: {'': {target: 'fundingChannel', cond: guards.amJoiner}},\n      invoke: {\n        data: (_, event) => event.data,\n        src: 'createChannel',\n        onDone: {\n          target: 'fundingChannel',\n          actions: [actions.assignChannelId, actions.sendCreateChannelResponse]\n        }\n      }\n    },\n    fundingChannel: {\n      invoke: {\n        src: 'invokeCreateChannelAndFundProtocol',\n        data: (ctx: ChannelIdExists): CreateAndFund.Init => ({\n          channelId: ctx.channelId,\n          funding: ctx.fundingStrategy\n        }),\n        onDone: {target: 'running', actions: [actions.hideUi]}\n      }\n    },\n    running: {\n      entry: [actions.spawnObservers],\n      on: {\n        // TODO: It would be nice to get rid of this event, which is used\n        // in testing when starting the workflow in the 'running' state.\n        SPAWN_OBSERVERS: {actions: actions.spawnObservers},\n        PLAYER_STATE_UPDATE: {\n          target: 'running',\n          actions: [actions.updateChannel]\n        },\n        CHANNEL_UPDATED: [\n          {target: 'closing', cond: guards.channelClosing},\n          {target: 'sendChallenge', cond: guards.channelChallenging}\n        ],\n        PLAYER_REQUEST_CONCLUDE: {\n          target: 'running',\n          actions: [actions.closeChannel],\n          after: {[CONCLUDE_TIMEOUT]: {target: 'sendChallenge', cond: guards.channelClosing}}\n        },\n\n        PLAYER_REQUEST_CHALLENGE: {target: 'sendChallenge'}\n      }\n    },\n\n    // This could handled by another workflow instead of the application workflow\n    closing: {\n      invoke: {\n        id: 'closing-protocol',\n        src: 'invokeClosingProtocol',\n        data: context => context,\n        autoForward: true,\n        onDone: {target: 'done'}\n      }\n    },\n\n    // This could handled by another workflow instead of the application workflow\n    sendChallenge: {\n      entry: actions.displayUi,\n      exit: actions.hideUi,\n      invoke: {\n        id: 'challenge-protocol',\n        src: 'invokeChallengingProtocol',\n        data: context => context,\n        autoForward: true,\n        onDone: {target: 'running', actions: [actions.sendChallengeChannelResponse]}\n      }\n    },\n\n    done: {type: 'final'}\n  } as any // TODO: This is to deal with some flickering compilation issues.\n});\n\nexport const workflow = (\n  store: Store,\n  messagingService: MessagingServiceInterface,\n  context?: Init\n) => {\n  const notifyOnChannelRequest = ({channelId}: ChannelIdExists) =>\n    messagingService.requestFeed.pipe(\n      filter(\n        r =>\n          (r.type === 'PLAYER_STATE_UPDATE' ||\n            r.type === 'PLAYER_REQUEST_CONCLUDE' ||\n            r.type === 'PLAYER_REQUEST_CHALLENGE') &&\n          r.channelId === channelId\n      )\n    );\n\n  const notifyOnUpdate = ({channelId}: ChannelIdExists) =>\n    store.channelUpdatedFeed(channelId).pipe(\n      filter(storeEntry => storeEntry.isSupported),\n\n      distinctUntilChanged((entry1, entry2) =>\n        _.isEqual(serializeChannelEntry(entry1), serializeChannelEntry(entry2))\n      ),\n\n      map(storeEntry => ({\n        type: 'CHANNEL_UPDATED',\n        storeEntry\n      }))\n    );\n\n  const actions: WorkflowActions = {\n    sendCreateChannelResponse: async (context: RequestIdExists & ChannelIdExists) => {\n      const entry = await store.getEntry(context.channelId);\n      await messagingService.sendResponse(context.requestId, serializeChannelEntry(entry));\n    },\n\n    sendJoinChannelResponse: async (context: RequestIdExists & ChannelIdExists) => {\n      const entry = await store.getEntry(context.channelId);\n      await messagingService.sendResponse(context.requestId, serializeChannelEntry(entry));\n    },\n\n    sendChallengeChannelResponse: async (context: RequestIdExists & ChannelIdExists) => {\n      const entry = await store.getEntry(context.channelId);\n      await messagingService.sendResponse(context.requestId, serializeChannelEntry(entry));\n    },\n\n    spawnObservers: assign<ChannelIdExists>((context: ChannelIdExists) => ({\n      ...context,\n      updateObserver: context.updateObserver ?? spawn(notifyOnUpdate(context)),\n      requestObserver: context.requestObserver ?? spawn(notifyOnChannelRequest(context))\n    })),\n\n    sendChannelUpdatedNotification: async (\n      context: ChannelIdExists,\n      event: {storeEntry: ChannelStoreEntry}\n    ) => {\n      if (event.storeEntry.channelId === context.channelId) {\n        messagingService.sendChannelNotification(\n          'ChannelUpdated',\n          serializeChannelEntry(event.storeEntry)\n        );\n      }\n    },\n    displayUi: () => {\n      messagingService.sendDisplayMessage('Show');\n    },\n    hideUi: () => {\n      messagingService.sendDisplayMessage('Hide');\n    },\n    assignChannelId: assign((context, event: AssignChannelEvent) => {\n      if (context.channelId) return context;\n      switch (event.type) {\n        case 'PLAYER_STATE_UPDATE':\n        case 'JOIN_CHANNEL':\n          return {channelId: event.channelId};\n        case 'done.invoke.createChannel':\n          return {channelId: event.data};\n        default:\n          return unreachable(event);\n      }\n    }),\n    assignRequestId: assign((context, event: JoinChannelEvent | PlayerRequestConclude) => ({\n      requestId: event.requestId\n    })),\n    updateChannel: async (context: ChannelIdExists, event: PlayerStateUpdate) => {\n      if (context.channelId === event.channelId) {\n        try {\n          messagingService.sendResponse(\n            event.requestId,\n            serializeChannelEntry(await store.updateChannel(event.channelId, event))\n          );\n        } catch (error) {\n          const matches = reason => new RegExp(reason).test(error.message);\n\n          // TODO: Catch other errors\n          let message: StateChannelsError;\n          if (matches(Errors.channelMissing)) message = {code: 400, message: 'Channel not found'};\n          else if (matches(Errors.notMyTurn)) message = {code: 403, message: 'Not your turn'};\n          else {\n            message = {code: 500, message: 'Wallet error'};\n            logger.error({error}, 'UpdateChannel call failed with error 500');\n          }\n\n          messagingService.sendError(event.requestId, message);\n        }\n      }\n    },\n\n    closeChannel: async (context: ChannelIdExists, event: PlayerRequestConclude) => {\n      if (context.channelId === event.channelId) {\n        try {\n          messagingService.sendResponse(\n            event.requestId,\n            serializeChannelEntry(await store.updateChannel(event.channelId, {isFinal: true}))\n          );\n        } catch (error) {\n          const matches = reason => new RegExp(reason).test(error.message);\n\n          let message: StateChannelsError;\n          if (matches(Errors.notMyTurn)) message = {code: 300, message: 'Not your turn'};\n          else if (matches(Errors.channelMissing))\n            message = {code: 301, message: 'Channel not found'};\n          else {\n            message = {code: 500, message: 'Wallet error'};\n            logger.error({error}, 'CloseChannel call failed with error 500');\n          }\n\n          messagingService.sendError(event.requestId, message);\n        }\n      }\n    }\n  };\n\n  const guards: WorkflowGuards = {\n    channelOpen: (_: ChannelIdExists, event: ChannelUpdated): boolean =>\n      !event.storeEntry.latestSignedByMe.isFinal,\n\n    channelClosing: (_: ChannelIdExists, event: ChannelUpdated): boolean =>\n      !!event.storeEntry.latest?.isFinal, // TODO: Should use supported\n\n    channelChallenging: (context: ChannelIdExists, event: ChannelUpdated): boolean =>\n      !!event.storeEntry.isChallenging,\n\n    channelClosed: (_, event: any): boolean => !!event.storeEntry.supported?.isFinal,\n    isDirectFunding: (ctx: Init) => ctx.fundingStrategy === 'Direct',\n    isLedgerFunding: (ctx: Init) => ctx.fundingStrategy === 'Ledger',\n    isVirtualFunding: (ctx: Init) => ctx.fundingStrategy === 'Virtual',\n    amCreator: (ctx: Init) => ctx.type === 'CREATE_CHANNEL',\n    amJoiner: (ctx: Init) => ctx.type === 'JOIN_CHANNEL'\n  };\n\n  const services: WorkflowServices = {\n    setapplicationDomain: async (ctx: ChannelIdExists, event: JoinChannelEvent) =>\n      await store.setapplicationDomain(ctx.channelId, event.applicationDomain),\n\n    signFinalStateIfMyTurn: signFinalStateIfMyTurn(store),\n    createChannel: async (context: CreateInit) => {\n      const {\n        participants,\n        challengeDuration,\n        outcome,\n        appData,\n        appDefinition,\n        fundingStrategy,\n        applicationDomain\n      } = context;\n      const stateVars: StateVariables = {\n        outcome,\n        appData,\n        turnNum: 0,\n        isFinal: false\n      };\n      const {channelId: targetChannelId} = await store.createChannel(\n        participants,\n        challengeDuration,\n        stateVars,\n        appDefinition,\n        applicationDomain\n      );\n\n      // Create a open channel objective so we can coordinate with all participants\n      await store.addObjective({\n        type: 'OpenChannel',\n        data: {targetChannelId, fundingStrategy},\n        participants: [participants[1]]\n      });\n      return targetChannelId;\n    },\n\n    invokeClosingProtocol: (context: ChannelIdExists) =>\n      ConcludeChannel.machine(store, messagingService).withContext({channelId: context.channelId}),\n\n    invokeChallengingProtocol: ({channelId}: ChannelIdExists) =>\n      ChallengeChannel.machine(store, {channelId}),\n\n    invokeCreateChannelAndFundProtocol: CreateAndFund.machine(store, messagingService),\n    invokeCreateChannelConfirmation: CCC.workflow({})\n  };\n\n  const config = generateConfig(actions, guards);\n  return Machine(config).withConfig({services}, context);\n};\n\nconst mockGuards: WorkflowGuards = {\n  channelOpen: createMockGuard('channelOpen'),\n  channelClosing: createMockGuard('channelClosing'),\n  channelChallenging: createMockGuard('channelChallenging'),\n  channelClosed: createMockGuard('channelClosed'),\n  isDirectFunding: createMockGuard('isDirectFunding'),\n  isLedgerFunding: createMockGuard('isLedgerFunding'),\n  isVirtualFunding: createMockGuard('isVirtualFunding'),\n  amCreator: createMockGuard('amCreator'),\n  amJoiner: createMockGuard('amJoiner')\n};\n\nconst mockActions: Record<keyof WorkflowActions, string> = {\n  assignChannelId: 'assignChannelId',\n  sendChannelUpdatedNotification: 'sendChannelUpdatedNotification',\n  sendChallengeChannelResponse: 'sendChallengeChannelResponse',\n  sendCreateChannelResponse: 'sendCreateChannelResponse',\n  sendJoinChannelResponse: 'sendJoinChannelResponse',\n  hideUi: 'hideUi',\n  displayUi: 'displayUi',\n  spawnObservers: 'spawnObservers',\n  updateChannel: 'updateChannel',\n  closeChannel: 'closeChannel',\n  assignRequestId: 'assignRequestId'\n};\n\nexport const config = generateConfig(mockActions as any, mockGuards);\nexport const mockOptions = {guards: mockGuards};\n\ntype AssignChannelEvent =\n  | PlayerStateUpdate\n  | JoinChannelEvent\n  | (DoneInvokeEvent<string> & {type: 'done.invoke.createChannel'});\n","import {MachineConfig, StateSchema, Machine, StateMachine, State} from 'xstate';\n\nexport type WorkflowContext = {};\n\ninterface WorkflowStateSchema extends StateSchema<WorkflowContext> {\n  initial: 'waitForUserConfirmation';\n  states: {\n    waitForUserConfirmation: {};\n    done: {};\n    failure: {};\n  };\n}\n\nexport type StateValue = keyof WorkflowStateSchema['states'];\n\nexport type WorkflowState = State<WorkflowContext, WorkflowEvent, WorkflowStateSchema, any>;\n\ninterface UserApproves {\n  type: 'USER_APPROVES';\n}\ninterface UserRejects {\n  type: 'USER_REJECTS';\n}\ntype WorkflowEvent = UserApproves | UserRejects;\n\nexport const config: MachineConfig<WorkflowContext, WorkflowStateSchema, WorkflowEvent> = {\n  id: 'confirm-create-channel',\n  initial: 'waitForUserConfirmation',\n  states: {\n    waitForUserConfirmation: {on: {USER_APPROVES: 'done', USER_REJECTS: 'failure'}},\n    done: {type: 'final', data: context => context},\n    failure: {}\n  }\n};\n\nexport const workflow = (ctx: WorkflowContext): WorkflowMachine => Machine(config).withContext(ctx);\nexport type WorkflowMachine = StateMachine<WorkflowContext, any, WorkflowEvent, any>;\n","// A workflow to guide the user through enabling window.ethereum\n\nimport {\n  StateSchema,\n  State,\n  Action,\n  MachineConfig,\n  Machine,\n  StateMachine,\n  ServiceConfig,\n  assign\n} from 'xstate';\n\nimport {Store} from '../store';\nimport {MessagingServiceInterface} from '../messaging';\nimport {GIT_VERSION} from '../config';\n\ninterface UserApproves {\n  type: 'USER_APPROVES_ENABLE';\n}\ninterface UserRejects {\n  type: 'USER_REJECTS_ENABLE';\n}\nexport type WorkflowEvent = UserApproves | UserRejects;\n\nexport interface WorkflowContext {\n  requestId: number;\n  enabledAddress?: string;\n}\n\ninterface EthereumEnabled extends WorkflowContext {\n  enabledAddress: string;\n}\n\nexport interface WorkflowServices extends Record<string, ServiceConfig<WorkflowContext>> {\n  enableEthereum: () => Promise<string>;\n  setDestinationAddressIfEmpty: (context: EthereumEnabled) => Promise<string>;\n}\nexport interface WorkflowStateSchema extends StateSchema<WorkflowContext> {\n  states: {\n    explainToUser: {};\n    enabling: {};\n    settingDestinationAddress: {};\n    done: {};\n    failure: {};\n    retry: {};\n  };\n}\nexport type WorkflowState = State<WorkflowContext, WorkflowEvent, WorkflowStateSchema, any>;\n\nexport interface WorkflowActions {\n  hideUi: Action<WorkflowContext, any>;\n  displayUi: Action<WorkflowContext, any>;\n  sendResponse: Action<WorkflowContext, any>;\n  sendErrorResponse: Action<WorkflowContext, any>;\n}\nexport type StateValue = keyof WorkflowStateSchema['states'];\n\nconst generateConfig = (\n  actions: WorkflowActions\n): MachineConfig<WorkflowContext, WorkflowStateSchema, WorkflowEvent> => ({\n  id: 'enable-ethereum',\n  initial: 'explainToUser',\n  states: {\n    explainToUser: {\n      entry: [actions.displayUi],\n      on: {\n        USER_APPROVES_ENABLE: {target: 'enabling'},\n        USER_REJECTS_ENABLE: {target: 'failure'}\n      }\n    },\n    enabling: {\n      invoke: {\n        src: 'enableEthereum',\n        onDone: {\n          target: 'settingDestinationAddress',\n          actions: assign({enabledAddress: (context, event) => event.data})\n        },\n        onError: 'failure'\n      }\n    }, // invoke ethereum enable\n    settingDestinationAddress: {\n      invoke: {\n        src: 'setDestinationAddressIfEmpty',\n        onDone: 'done',\n        onError: 'failure'\n      }\n    },\n    retry: {\n      on: {\n        USER_APPROVES_ENABLE: {target: 'enabling'},\n        USER_REJECTS_ENABLE: {target: 'failure'}\n      }\n    },\n    done: {type: 'final', entry: [actions.hideUi, actions.sendResponse]},\n    failure: {type: 'final', entry: [actions.hideUi, actions.sendErrorResponse]}\n  }\n});\n\nexport type WorkflowMachine = StateMachine<WorkflowContext, StateSchema, WorkflowEvent, any>;\n\nexport const ethereumEnableWorkflow = (\n  store: Store,\n  messagingService: MessagingServiceInterface,\n  context: WorkflowContext\n): WorkflowMachine => {\n  const services: WorkflowServices = {\n    enableEthereum: () => store.chain.ethereumEnable(),\n    setDestinationAddressIfEmpty: async (context: EthereumEnabled) =>\n      (await store.getDestinationAddress()) ||\n      (await store.setDestinationAddress(context.enabledAddress))\n  };\n  const actions = {\n    displayUi: () => {\n      messagingService.sendDisplayMessage('Show');\n    },\n    hideUi: () => {\n      messagingService.sendDisplayMessage('Hide');\n    },\n    sendResponse: async (context: WorkflowContext) => {\n      messagingService.sendResponse(context.requestId, {\n        signingAddress: await store.getAddress(),\n        walletVersion: GIT_VERSION,\n        destinationAddress: await store.getDestinationAddress()\n      });\n    },\n    sendErrorResponse: (context: WorkflowContext) => {\n      messagingService.sendError(context.requestId, {code: 100, message: 'Ethereum Not Enabled'});\n    }\n  };\n  const config = generateConfig(actions);\n  return Machine(config).withConfig({services}, context) as WorkflowMachine;\n};\n\n// Mock values for diagram generation\n// ==================================\n\nconst mockActions: WorkflowActions = {\n  hideUi: 'hideUi',\n  displayUi: 'displayUi',\n  sendResponse: 'sendResponse',\n  sendErrorResponse: 'sendErrorResponse'\n};\n\nexport const mockServices: WorkflowServices = {\n  enableEthereum: () =>\n    new Promise(() => {\n      /* Mock call */\n    }) as any,\n  setDestinationAddressIfEmpty: () =>\n    new Promise(() => {\n      /* Mock call */\n    })\n};\nexport const mockOptions = {services: mockServices, actions: mockActions};\nexport const config = generateConfig(mockActions);\n","import React from 'react';\n\nexport const WindowContext = React.createContext(window);\n","import React from 'react';\nimport './wallet.scss';\nimport {Blockie, Tooltip, Avatar} from 'rimble-ui';\n\ninterface Props {\n  channelId?: string;\n}\n\nexport const ChannelId = (props: Props) => {\n  if (props.channelId) {\n    return (\n      <Tooltip message={props.channelId}>\n        <Avatar src=\"\" ml=\"auto\" mr=\"auto\">\n          <Blockie\n            opts={{\n              seed: props.channelId,\n              color: '#2728e2',\n              bgcolor: '#46A5D0',\n              size: 15,\n              scale: 3,\n              spotcolor: '#000'\n            }}\n          />\n        </Avatar>\n      </Tooltip>\n    );\n  } else return <div></div>;\n};\n","import {DomainBudget, unreachable, Uint256} from '@statechannels/wallet-core';\nimport {Interpreter} from 'xstate';\n\nimport {ETH_ASSET_HOLDER_ADDRESS} from '../config';\nimport {WorkflowState as CCCWorkflowState} from '../workflows/confirm';\nimport {\n  WorkflowState as AppWorkflowState,\n  StateValue as AppStateValue\n} from '../workflows/application';\n\nexport function getApplicationStateValue(\n  applicationWorkflowState: AppWorkflowState\n): AppStateValue {\n  if (typeof applicationWorkflowState.value === 'string') {\n    return applicationWorkflowState.value as AppStateValue;\n  } else {\n    return Object.keys(applicationWorkflowState.value)[0] as AppStateValue;\n  }\n}\n\nexport function getConfirmCreateChannelState(\n  applicationWorkflowState: AppWorkflowState\n): CCCWorkflowState {\n  return applicationWorkflowState.children[Object.keys(applicationWorkflowState.children)[0]]\n    .state as CCCWorkflowState;\n}\nexport function getConfirmCreateChannelService(\n  applicationWorkflowState: AppWorkflowState\n): Interpreter<any> {\n  return applicationWorkflowState.children.invokeCreateChannelConfirmation as any;\n}\n\nexport function getChallengeChannelService(\n  applicationWorkflowState: AppWorkflowState\n): Interpreter<any> {\n  return applicationWorkflowState.children.invokeChallengingProtocol as any;\n}\n\n// TODO:Ideally this should be a type guard\nexport function isConfirmCreateChannel(applicationWorkflowState: AppWorkflowState): boolean {\n  return applicationWorkflowState.value === 'confirmingWithUser';\n}\n\nexport function isApplicationChallenging(applicationWorkflowState: AppWorkflowState): boolean {\n  const stateValue = getApplicationStateValue(applicationWorkflowState);\n  return stateValue === 'sendChallenge';\n}\n\nexport function isApplicationOpening(applicationWorkflowState: AppWorkflowState): boolean {\n  const stateValue = getApplicationStateValue(applicationWorkflowState);\n  return (\n    stateValue === 'joiningChannel' ||\n    stateValue === 'creatingChannel' ||\n    stateValue === 'openChannelAndFundProtocol'\n  );\n}\n\nexport function getApplicationOpenProgress(applicationWorkflowState: AppWorkflowState): number {\n  const stateValue = getApplicationStateValue(applicationWorkflowState);\n  switch (stateValue) {\n    case 'confirmingWithUser':\n      return 0.25;\n    case 'joiningChannel':\n    case 'creatingChannel':\n    case 'fundingChannel':\n      return 0.5;\n\n    case 'openChannelAndFundProtocol':\n      return 0.75;\n    case 'running':\n      return 1;\n    case 'closing':\n    case 'sendChallenge':\n    case 'done':\n    case 'failure':\n    case 'branchingOnFundingStrategy':\n      throw Error('Should not be in this state');\n    default:\n      return unreachable(stateValue);\n  }\n}\n\nexport function getAmountsFromBudget(\n  budget: DomainBudget\n): {playerAmount: Uint256; hubAmount: Uint256} {\n  const pending = budget.forAsset[ETH_ASSET_HOLDER_ADDRESS];\n  if (!pending) throw new Error('No eth budget found');\n  const {availableReceiveCapacity, availableSendCapacity} = pending;\n  return {playerAmount: availableSendCapacity, hubAmount: availableReceiveCapacity};\n}\n","import React from 'react';\nimport {Interpreter} from 'xstate';\n\nimport './wallet.scss';\n\ninterface Props {\n  service: Interpreter<any>;\n}\n\nexport const ChallengeChannel = (props: Props) => (\n  <p>Application has requested a challenge. Check your wallet.</p>\n);\n","import _ from 'lodash';\n\n/*\nSegment analytics are injected in index.html\nThis exposes them for ease of use, without having to refer to the window object,\nor worry about undefined functions\nSince segment re-defines window.analytics after it's been loaded, at runtime,\nwe need to make sure we're referring to the fresh ones.\nSo, we intercept calls to track/identify, and fetch the latest window.analytics value\n*/\n\ntype Action = 'track' | 'identify';\nconst segmentFunction = (action: 'track' | 'identify') =>\n  window.analytics ? window.analytics[action] : _.noop;\n\nexport const analytics: Pick<SegmentAnalytics.AnalyticsJS, Action> = {\n  track: (event, ...args) => segmentFunction('track')(event, ...args),\n  identify: (event, ...args) => segmentFunction('identify')(event, ...args)\n};\n\nconst {track, identify} = analytics;\nexport {track, identify};\n","import React from 'react';\nimport './wallet.scss';\nimport {Button, Flex, Text} from 'rimble-ui';\nimport {useService} from '@xstate/react';\nimport {Interpreter} from 'xstate';\nimport {track} from '../segment-analytics';\n\ninterface Props {\n  service: Interpreter<any>;\n}\n\nexport const ConfirmCreateChannel = (props: Props) => {\n  const [current, _send] = useService(props.service);\n  const send = (event: 'USER_APPROVES' | 'USER_REJECTS') => () => {\n    track(event);\n    _send(event);\n  };\n\n  const prompt = (\n    <Flex alignItems=\"left\" flexDirection=\"column\">\n      <Text fontSize={2} pb={2}>\n        Do you wish to create a channel?\n      </Text>\n      <Button id=\"yes\" onClick={send('USER_APPROVES')}>\n        Yes\n      </Button>\n      <Button.Text onClick={send('USER_REJECTS')}>No</Button.Text>\n    </Flex>\n  );\n  if (current?.value.toString() === 'waitForUserConfirmation') {\n    return prompt;\n  } else {\n    return <div></div>;\n  }\n};\n","import React from 'react';\nimport {State, EventData} from 'xstate';\nimport './wallet.scss';\nimport {Flex, Heading, Progress} from 'rimble-ui';\nimport {ChannelId} from './channel-id';\nimport {\n  isConfirmCreateChannel,\n  getConfirmCreateChannelService,\n  getChallengeChannelService,\n  getApplicationOpenProgress,\n  isApplicationOpening,\n  getApplicationStateValue,\n  isApplicationChallenging\n} from './selectors';\nimport {ChallengeChannel} from './challenge-channel-workflow';\nimport {ConfirmCreateChannel} from './confirm-create-channel-workflow';\nimport {Application} from '../workflows';\n\ninterface Props {\n  current: Application.WorkflowState;\n  send: (event: any, payload?: EventData | undefined) => State<any, any, any, any>;\n}\n\nexport const ApplicationWorkflow = (props: Props) => {\n  const current = props.current;\n  const messages: Record<Application.StateValue, string> = {\n    branchingOnFundingStrategy: '', // UI never sees this state\n    confirmingWithUser: 'Confirming with user...',\n    creatingChannel: 'Creating channel...',\n    joiningChannel: 'Joining channel ... ',\n    openChannelAndFundProtocol: 'Opening channel...',\n    running: 'Running channel...',\n    sendChallenge: 'Challenging channel...',\n    closing: 'Closing channel...',\n    done: 'Channel closed',\n    failure: 'Something went wrong ...',\n    fundingChannel: 'Funding channel ... '\n  };\n  return (\n    <div\n      style={{\n        paddingTop: '50px',\n        textAlign: 'center'\n      }}\n      className=\"application-workflow-prompt\"\n    >\n      <div\n        id={\n          getApplicationStateValue(current) === 'joiningChannel' ? 'joiningChannel' : 'noPromptId'\n        }\n      />\n      <Heading textAlign=\"center\" mb={0}>\n        {messages[getApplicationStateValue(current)]}\n      </Heading>\n      {!isConfirmCreateChannel(current) && !isApplicationChallenging(current) && (\n        <Flex px={3} height={3} mt={'0.8'} mx={'0.4'}>\n          <ChannelId channelId={current.context.channelId} />\n        </Flex>\n      )}\n      {isConfirmCreateChannel(current) && (\n        <ConfirmCreateChannel service={getConfirmCreateChannelService(current)} />\n      )}\n      {isApplicationChallenging(current) && (\n        <ChallengeChannel service={getChallengeChannelService(current)} />\n      )}\n      {!isConfirmCreateChannel(current) && isApplicationOpening(current) && (\n        <Progress value={getApplicationOpenProgress(current)} />\n      )}\n    </div>\n  );\n};\n\nexport default ApplicationWorkflow;\n","import React, {useContext} from 'react';\nimport {EventData} from 'xstate';\nimport './wallet.scss';\nimport {Button, Box, Flex, Icon, Text, MetaMaskButton, Flash, Heading} from 'rimble-ui';\n\nimport ConnectionBanner from '@rimble/connection-banner';\nimport RimbleUtils from '@rimble/utils';\nimport {WorkflowState} from '../workflows/ethereum-enable';\nimport {WindowContext} from './window-context';\nimport {CHAIN_NETWORK_ID} from '../config';\nimport {track} from '../segment-analytics';\n\ninterface Props {\n  current: WorkflowState;\n  send: (event: any, payload?: EventData | undefined) => WorkflowState;\n}\n\nexport const EnableEthereum = (props: Props) => {\n  const {current: currentState, send: _send} = props;\n  const send = (event: 'USER_APPROVES_ENABLE' | 'USER_REJECTS_ENABLE') => () => {\n    track(event, {enabledAddress: currentState.context.enabledAddress});\n    _send(event);\n  };\n\n  const targetNetwork = Number(CHAIN_NETWORK_ID);\n\n  const window = useContext(WindowContext);\n  const networkVersion = window?.ethereum?.networkVersion;\n  const currentNetwork = networkVersion && Number(networkVersion);\n\n  const metaMaskButton = (disabled, message) => (\n    <MetaMaskButton.Outline\n      disabled={disabled}\n      id=\"connect-with-metamask-button\"\n      onClick={send('USER_APPROVES_ENABLE')}\n    >\n      {message}\n    </MetaMaskButton.Outline>\n  );\n\n  const NoNetwork = () => (\n    <div>\n      <Flash variant={'danger'}>\n        <Flex alignItems=\"center\" justifyContent=\"space-between\" flexDirection=\"column\">\n          <Flex alignItems=\"center\" pb={3} flexDirection=\"column\">\n            <Box>\n              <Icon name=\"Warning\" size=\"44\" />\n            </Box>\n            <Flex flexDirection=\"column\">\n              <Text fontWeight=\"bold\" color={'inherit'} textAlign=\"center\">\n                Install the MetaMask browser extension to use our blockchain features in your\n                current browser\n              </Text>\n            </Flex>\n          </Flex>\n\n          <MetaMaskButton as=\"a\" href=\"https://metamask.io/\" target=\"_blank\" color={'white'}>\n            Install MetaMask\n          </MetaMaskButton>\n        </Flex>\n      </Flash>\n    </div>\n  );\n\n  const WrongNetwork = () => (\n    <div>\n      <Flash variant={'danger'}>\n        <Flex alignItems=\"center\" flexDirection=\"column\">\n          <Box>\n            <Icon name=\"Warning\" size=\"44\" />\n          </Box>\n          <Flex flexDirection=\"column\">\n            <Text fontWeight=\"bold\" color={'inherit'} textAlign=\"center\" pb={3}>\n              Switch to the {RimbleUtils.getEthNetworkNameById(targetNetwork)} network in MetaMask\n            </Text>\n            <Text color={'inherit'} textAlign=\"center\">\n              To use our blockchain features, you need to be on the{' '}\n              {RimbleUtils.getEthNetworkNameById(targetNetwork)} network. You are currently on{' '}\n              {RimbleUtils.getEthNetworkNameById(currentNetwork)}.\n            </Text>\n          </Flex>\n        </Flex>\n      </Flash>\n    </div>\n  );\n\n  const NotWeb3Browser = () => (\n    <div>\n      <Flash variant={'danger'}>\n        <Flex alignItems=\"center\" flexDirection=\"column\">\n          <Box>\n            <Icon name=\"Warning\" size=\"44\" />\n          </Box>\n          <Flex flexDirection=\"column\">\n            <Text fontWeight=\"bold\" color={'inherit'}>\n              Your browser does not support our blockchain features\n            </Text>\n            {RimbleUtils.isMobileDevice() ? (\n              <Text color={'inherit'}>\n                Try a mobile wallet browser like Status, Coinbase wallet or Cipher\n              </Text>\n            ) : (\n              <Text color={'inherit'}>\n                Switch to either Brave, FireFox, Opera, or Chrome to continue\n              </Text>\n            )}\n          </Flex>\n        </Flex>\n      </Flash>\n    </div>\n  );\n\n  const button = () => {\n    switch (currentState.value.toString()) {\n      case 'explainToUser':\n      case 'retry':\n        return metaMaskButton(false, 'Connect with MetaMask');\n      case 'enabling':\n        return metaMaskButton(true, 'Connecting..');\n      case 'done':\n        return metaMaskButton(true, 'Connected!');\n      case 'failure':\n        return metaMaskButton(true, 'Connection failed :(');\n      default:\n        return '';\n    }\n  };\n\n  const connectionBanner = (\n    <ConnectionBanner currentNetwork={currentNetwork} requiredNetwork={targetNetwork}>\n      {{\n        notWeb3CapableBrowserMessage: <NotWeb3Browser />,\n        noNetworkAvailableMessage: <NoNetwork />,\n        onWrongNetworkMessage: <WrongNetwork />\n      }}\n    </ConnectionBanner>\n  );\n\n  const prompt = (\n    <Flex flexDirection=\"column\" alignItems=\"center\">\n      <Heading>Connect to Blockchain</Heading>\n\n      <Text pb={3}>\n        This app uses state channels. It order to continue you need to connect to the blockchain.\n      </Text>\n\n      <div>{button()}</div>\n      <div>\n        <Button.Text onClick={send('USER_REJECTS_ENABLE')}>Cancel</Button.Text>\n      </div>\n    </Flex>\n  );\n\n  // need currentNetwork to be defined, and equal to the targetNetwork\n  return currentNetwork === targetNetwork ? (\n    prompt\n  ) : (\n    <div style={{paddingTop: '10px'}}>{connectionBanner}</div>\n  );\n};\n","import {theme as rimbleTheme} from 'rimble-ui';\n\nexport const theme = {\n  ...rimbleTheme,\n  fonts: {\n    serif: 'athelas, georgia, times, serif',\n    sansSerif: 'WoodfordBourne'\n  }\n};\n","export default __webpack_public_path__ + \"static/media/logo.53348272.svg\";","import React, {FunctionComponent} from 'react';\nimport {theme} from './theme';\nimport {ThemeProvider} from 'styled-components';\nimport {Modal, Card, Flex, Image} from 'rimble-ui';\nimport logo from '../images/logo.svg';\n\nexport const Layout: FunctionComponent = ({children}) => {\n  return (\n    <ThemeProvider theme={theme}>\n      <Modal isOpen={true}>\n        <Card width={'320px'} height={'450px'}>\n          <Flex px={[3, 3, 4]} borderBottom={1} borderColor={'#E8E8E8'} mt={'0.8'}>\n            <Image alt=\"State Channels\" pb={2} height=\"auto\" src={logo} />\n          </Flex>\n          {children}\n        </Card>\n      </Modal>\n    </ThemeProvider>\n  );\n};\n","import React, {useEffect, useState} from 'react';\nimport './wallet.scss';\nimport {useService} from '@xstate/react';\nimport {formatEther} from '@ethersproject/units';\nimport {Button, Heading, Flex, Text, Box, Link, Loader, Tooltip, Icon} from 'rimble-ui';\nimport {BN} from '@statechannels/wallet-core';\nimport {ApproveBudgetAndFundService} from '../workflows/approve-budget-and-fund';\n\nimport {track} from '../segment-analytics';\nimport {getAmountsFromBudget} from './selectors';\nimport {ETH_ASSET_HOLDER_ADDRESS, TARGET_NETWORK, FAUCET_LINK} from '../config';\ninterface Props {\n  service: ApproveBudgetAndFundService;\n}\n\nexport const ApproveBudgetAndFund = (props: Props) => {\n  const [current, _send] = useService(props.service);\n  const {budget} = current.context;\n  const {playerAmount, hubAmount} = getAmountsFromBudget(budget);\n\n  const send = (\n    event:\n      | 'USER_APPROVES_BUDGET'\n      | 'USER_REJECTS_BUDGET'\n      | 'USER_APPROVES_RETRY'\n      | 'USER_REJECTS_RETRY'\n  ) => () => {\n    track(event, {domain: current.context.budget.domain});\n    _send(event);\n  };\n\n  // Sets a timer that expires after 1.5 minutes\n  // Used to determine if we've timed out waiting for the hub\n  let stateTimer;\n  const [stateTimerExpired, setStateTimerExpired] = useState(false);\n  useEffect(() => {\n    setStateTimerExpired(false);\n    stateTimer = setTimeout(() => setStateTimerExpired(true), 90_000 /* 1.5 min */);\n    return () => {\n      clearTimeout(stateTimer);\n    };\n  }, [current]);\n\n  const waitForSufficientFundsInit = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>App Budget</Heading>\n\n      <Text textAlign=\"center\">Checking if your Metamask account has sufficient ETH</Text>\n    </Flex>\n  );\n\n  const waitForSufficientFunds = (\n    <Flex alignItems=\"left\" flexDirection=\"column\">\n      <Heading textAlign=\"center\" mb={2}>\n        App Budget\n      </Heading>\n      <Text pb={3} fontSize={1}>\n        You don&#39;t have enough ETH in your wallet!\n      </Text>\n      <Text pb={3} fontSize={1}>\n        You&#39;ll need at least {formatEther(BN.from(playerAmount))} ETH in your Metamask wallet to\n        fund the channel. You can get more ETH{' '}\n        <Link target=\"_blank\" href={FAUCET_LINK}>\n          here.\n        </Link>\n      </Text>\n    </Flex>\n  );\n  const waitForUserApproval = ({waiting}: {waiting: boolean} = {waiting: false}) => (\n    <Flex alignItems=\"left\" flexDirection=\"column\">\n      <Heading textAlign=\"center\" mb={2}>\n        App Budget\n      </Heading>\n\n      <Text fontSize={1} pb={2}>\n        Approve budget?\n      </Text>\n\n      <Flex justifyContent=\"center\" pb={2}>\n        <Box>\n          <Text>Send: {formatEther(BN.from(playerAmount))} ETH</Text>\n          <Text>Receive: {formatEther(BN.from(hubAmount))} ETH</Text>\n        </Box>\n      </Flex>\n      <Text fontSize={1} pb={2}>\n        <strong>{budget.domain}</strong> will manage these funds.\n      </Text>\n      <Text pb={3} fontSize={1}>\n        You will deposit {formatEther(BN.from(playerAmount))} ETH into a channel. Our hub will also\n        make a deposit.\n        <Tooltip message=\"This allows you to transact with anyone else connected to the same hub.\">\n          <Icon name=\"Info\" size=\"20\" />\n        </Tooltip>\n      </Text>\n      <Button\n        disabled={waiting}\n        onClick={send('USER_APPROVES_BUDGET')}\n        className=\"approve-budget-button\"\n      >\n        Approve budget\n      </Button>\n      <Button.Text onClick={send('USER_REJECTS_BUDGET')}>Cancel</Button.Text>\n    </Flex>\n  );\n\n  const waitForPreFS = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text textAlign=\"center\">Waiting for the hub to respond.</Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  const depositInit = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text textAlign=\"center\">Querying blockchain</Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  const depositWaitTurn = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text pb=\"2\">The hub is now depositing funds on-chain. This may take a moment.</Text>\n\n      <Text id=\"wait-for-transaction\">\n        Click{' '}\n        <Link\n          target=\"_blank\"\n          href={`https://${TARGET_NETWORK}.etherscan.io/address/${ETH_ASSET_HOLDER_ADDRESS}`}\n        >\n          here\n        </Link>{' '}\n        to follow the progress on etherscan.\n      </Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  const depositSubmitTransaction = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text textAlign=\"center\" id=\"please-approve-transaction\">\n        Please approve the transaction in metamask\n      </Text>\n    </Flex>\n  );\n\n  const depositWaitMining = ({transactionId}: {transactionId: string}) => (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text pb={2}>Waiting for your transaction to be mined.</Text>\n\n      <Text id=\"wait-for-transaction\">\n        Click{' '}\n        <Link target=\"_blank\" href={`https://${TARGET_NETWORK}.etherscan.io/tx/${transactionId}`}>\n          here\n        </Link>{' '}\n        to follow the progress on etherscan.\n      </Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  const depositRetry = () => (\n    <Flex alignItems=\"left\" justifyContent=\"space-between\" flexDirection=\"column\">\n      <Heading textAlign=\"center\">Deposit Funds</Heading>\n\n      <Text pb={4}>Your deposit transaction failed. Do you want to retry?</Text>\n\n      <Button onClick={send('USER_APPROVES_RETRY')}>Resubmit transaction</Button>\n      <Button.Text onClick={send('USER_REJECTS_RETRY')}>Cancel</Button.Text>\n    </Flex>\n  );\n\n  // in the current setup, the hub deposits first, so this should never be shown\n  const depositFullyFunded = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit funds</Heading>\n\n      <Text textAlign=\"center\">Waiting for hub to deposit</Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  const hubTimeout = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Deposit Funds</Heading>\n      <Text pb={4} textAlign=\"center\">\n        We haven&apos;t heard back from the hub in a bit so something might have gone wrong.\n      </Text>\n      <Text pb={4} textAlign=\"center\">\n        You can click{' '}\n        <Link\n          target=\"_blank\"\n          href={`https://${TARGET_NETWORK}.etherscan.io/address/${ETH_ASSET_HOLDER_ADDRESS}`}\n        >\n          here\n        </Link>{' '}\n        to see the progress on etherscan or you can download your log files and reach out to us on{' '}\n        <Link target=\"_blank\" href={'https://github.com/statechannels/monorepo/issues'}>\n          {' '}\n          github.\n        </Link>\n      </Text>\n      <Button\n        onClick={() => {\n          window.parent.postMessage('SAVE_WEB3_TORRENT_LOGS', '*');\n        }}\n      >\n        Download logs\n      </Button>\n    </Flex>\n  );\n\n  if (current.matches('waitForUserApproval')) {\n    return waitForUserApproval();\n  } else if (current.matches({waitForSufficientFunds: 'init'})) {\n    return waitForSufficientFundsInit;\n  } else if (current.matches({waitForSufficientFunds: 'waitForFunds'})) {\n    return waitForSufficientFunds;\n  } else if (current.matches('createLedger')) {\n    return waitForSufficientFunds;\n  } else if (current.matches('waitForPreFS')) {\n    return waitForPreFS;\n  } else if (current.matches({deposit: 'init'})) {\n    return depositInit;\n  } else if (current.matches({deposit: 'waitTurn'})) {\n    if (stateTimerExpired) {\n      return hubTimeout;\n    } else {\n      return depositWaitTurn;\n    }\n  } else if (current.matches({deposit: 'submitTransaction'})) {\n    return depositSubmitTransaction;\n  } else if (current.matches({deposit: 'waitMining'})) {\n    return depositWaitMining(current.context);\n  } else if (current.matches({deposit: 'retry'})) {\n    return depositRetry();\n  } else if (current.matches({deposit: 'waitFullyFunded'})) {\n    return depositFullyFunded;\n  } else if (current.matches('createBudget')) {\n    return depositFullyFunded;\n  } else if (current.matches('done')) {\n    // workflow hides ui, so user shouldn't ever see this\n    return <div>Success! Returning to app..</div>;\n  } else if (current.matches('failure')) {\n    // workflow hides ui, so user shouldn't ever see this\n    return <div>Failed :(. Returning to app..</div>;\n  } else {\n    return <div>Todo</div>;\n  }\n};\n","import React from 'react';\nimport './wallet.scss';\nimport {useService} from '@xstate/react';\n\nimport {formatEther} from '@ethersproject/units';\nimport {Button, Heading, Flex, Text, Link, Loader} from 'rimble-ui';\nimport {DomainBudget, BN} from '@statechannels/wallet-core';\nimport {track} from '../segment-analytics';\nimport {getAmountsFromBudget} from './selectors';\nimport {CloseLedgerAndWithdrawService} from '../workflows/close-ledger-and-withdraw';\nimport {TARGET_NETWORK} from '../config';\n\ninterface Props {\n  service: CloseLedgerAndWithdrawService;\n}\n\nexport const CloseLedgerAndWithdraw = (props: Props) => {\n  const [current, _send] = useService(props.service);\n\n  const send = (event: 'USER_APPROVES_CLOSE' | 'USER_REJECTS_CLOSE') => () => {\n    track(event, {domain: current.context.domain});\n    _send(event);\n  };\n\n  const waitForUserApproval = ({waiting, budget}: {waiting: boolean; budget: DomainBudget}) => {\n    const {playerAmount} = getAmountsFromBudget(budget);\n    return (\n      <Flex alignItems=\"left\" flexDirection=\"column\">\n        <Heading textAlign=\"center\" mb={0}>\n          Withdraw Funds\n        </Heading>\n        <Heading textAlign=\"center\" as=\"h4\" mt={0} mb={2}>\n          {budget.domain}\n        </Heading>\n        <Text fontSize={1} pb={2}>\n          Close your hub connection with <strong>{budget.domain}</strong> and withdraw your funds?\n        </Text>\n\n        <Text pb={3} fontSize={1}>\n          You will receive {formatEther(BN.from(playerAmount))} ETH and the budget will be closed\n          with the channel hub.\n        </Text>\n        <Button disabled={waiting} onClick={send('USER_APPROVES_CLOSE')} id=\"approve-withdraw\">\n          Close and Withdraw\n        </Button>\n        <Button.Text onClick={send('USER_REJECTS_CLOSE')}>Cancel</Button.Text>\n      </Flex>\n    );\n  };\n\n  const talkingToHub = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Withdraw funds</Heading>\n\n      <Text textAlign=\"center\">Communicating with the hub</Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n  const working = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Withdraw funds</Heading>\n\n      <Text textAlign=\"center\">Working...</Text>\n    </Flex>\n  );\n\n  const withdrawSubmitTransaction = (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Withdraw funds</Heading>\n\n      <Text textAlign=\"center\">Please approve the transaction in metamask</Text>\n    </Flex>\n  );\n\n  const withdrawWaitMining = ({transactionId}: {transactionId: string}) => (\n    <Flex alignItems=\"center\" flexDirection=\"column\">\n      <Heading>Withdraw funds</Heading>\n\n      <Text pb={2}>Waiting for your transaction to be mined.</Text>\n\n      <Text id=\"wait-for-transaction\">\n        Click{' '}\n        <Link target=\"_blank\" href={`https://${TARGET_NETWORK}.etherscan.io/tx/${transactionId}`}>\n          here\n        </Link>{' '}\n        to follow the progress on etherscan.\n      </Text>\n      <Text>\n        <br></br>\n        <Loader color=\"#2728e2\" size=\"60px\" />\n      </Text>\n    </Flex>\n  );\n\n  if (current.matches('waitForUserApproval')) {\n    const {budget} = current.context;\n    return waitForUserApproval({waiting: false, budget});\n  } else if (\n    current.matches('createObjective') ||\n    current.matches('fetchBudget') ||\n    current.matches('clearBudget')\n  ) {\n    return working;\n  } else if (\n    current.matches({closeLedger: 'constructFinalState'}) ||\n    current.matches({closeLedger: 'supportState'})\n  ) {\n    return talkingToHub;\n  } else if (current.matches({withdraw: 'submitTransaction'})) {\n    return withdrawSubmitTransaction;\n  } else if (current.matches({withdraw: 'waitMining'})) {\n    return withdrawWaitMining(current.context);\n  } else if (current.matches('done')) {\n    // workflow hides ui, so user shouldn't ever see this\n    return <div>Success! Returning to app..</div>;\n  } else if (current.matches('budgetFailure')) {\n    // workflow hides ui, so user shouldn't ever see this\n    return <div>Failed :(. Returning to app..</div>;\n  } else {\n    return <div>Todo</div>;\n  }\n};\n","import React from 'react';\nimport {WindowContext} from './window-context';\nimport {Interpreter} from 'xstate';\nimport {useService} from '@xstate/react';\nimport './wallet.scss';\nimport {ApplicationWorkflow} from './application-workflow';\nimport {EnableEthereum} from './enable-ethereum-workflow';\nimport {Layout} from './layout';\nimport {ApproveBudgetAndFund} from './approve-budget-and-fund-workflow';\n\nimport {CloseLedgerAndWithdraw} from './close-ledger-and-withdraw';\n\ninterface Props {\n  workflow: Interpreter<any, any, any>;\n}\n\nexport const Wallet = (props: Props) => {\n  const [current, send] = useService(props.workflow);\n  return (\n    <WindowContext.Provider value={window}>\n      <Layout>\n        {props.workflow.id === 'application-workflow' && (\n          <ApplicationWorkflow current={current} send={send} />\n        )}\n        {props.workflow.id === 'enable-ethereum' && (\n          <EnableEthereum current={current} send={send} />\n        )}\n        {props.workflow.id === 'approve-budget-and-fund' && (\n          <ApproveBudgetAndFund service={props.workflow} />\n        )}\n        {props.workflow.id === 'close-and-withdraw' && (\n          <CloseLedgerAndWithdraw service={props.workflow} />\n        )}\n      </Layout>\n    </WindowContext.Provider>\n  );\n};\n","import ReactDOM from 'react-dom';\nimport React from 'react';\nimport {interpret, Interpreter, State} from 'xstate';\nimport {Guid} from 'guid-typescript';\nimport {\n  StateChannelsNotification,\n  StateChannelsResponse,\n  StateChannelsErrorResponse\n} from '@statechannels/client-api-schema';\nimport {filter, take} from 'rxjs/operators';\nimport {\n  Message,\n  isOpenChannel,\n  OpenChannel,\n  serializeChannelEntry\n} from '@statechannels/wallet-core';\n\nimport {AppRequestEvent} from './event-types';\nimport {Store} from './store';\nimport {ApproveBudgetAndFund, CloseLedgerAndWithdraw, Application} from './workflows';\nimport {ethereumEnableWorkflow} from './workflows/ethereum-enable';\nimport {Wallet as WalletUi} from './ui/wallet';\nimport {MessagingServiceInterface} from './messaging';\nimport {ADD_LOGS} from './config';\nimport {logger} from './logger';\n\nexport interface Workflow {\n  id: string;\n  service: Interpreter<any, any, any>;\n  domain: string; // TODO: Is this useful?\n}\nexport class ChannelWallet {\n  public workflows: Workflow[];\n\n  constructor(\n    private store: Store,\n    private messagingService: MessagingServiceInterface,\n    public id?: string\n  ) {\n    this.workflows = [];\n\n    // Whenever the store wants to send something call sendMessage\n    store.outboxFeed.subscribe(async (m: Message) => {\n      this.messagingService.sendMessageNotification(m);\n    });\n    // Whenever an OpenChannel objective is received\n    // we alert the user that there is a new channel\n    // It is up to the app to call JoinChannel\n    this.store.objectiveFeed.pipe(filter(isOpenChannel)).subscribe(async objective => {\n      const channelEntry = await this.store\n        .channelUpdatedFeed(objective.data.targetChannelId)\n        .pipe(take(1))\n        .toPromise();\n\n      // TODO: Currently receiving a duplicate JOIN_CHANNEL event\n      if (this.isWorkflowIdInUse(this.calculateWorkflowId(objective))) {\n        logger.warn(\n          `There is already a workflow running with id ${this.calculateWorkflowId(\n            objective\n          )}, no new workflow will be spawned`\n        );\n      } else {\n        // Note that it's important to start the workflow first, before sending ChannelProposed.\n        // This way, the workflow is listening to JOIN_CHANNEL right from the get go.\n        this.startWorkflow(\n          Application.workflow(this.store, this.messagingService, {\n            type: 'JOIN_CHANNEL',\n            fundingStrategy: objective.data.fundingStrategy,\n            channelId: objective.data.targetChannelId,\n            applicationDomain: 'TODO' // FIXME\n          }),\n          this.calculateWorkflowId(objective)\n        );\n\n        this.messagingService.sendChannelNotification('ChannelProposed', {\n          ...serializeChannelEntry(channelEntry)\n        });\n      }\n    });\n\n    this.messagingService.requestFeed.subscribe(x => this.handleRequest(x));\n  }\n\n  private isWorkflowIdInUse(workflowId: string): boolean {\n    return this.workflows.map(w => w.id).indexOf(workflowId) > -1;\n  }\n\n  public getWorkflow(workflowId: string): Workflow {\n    const workflow = this.workflows.find(w => w.id === workflowId);\n    if (!workflow) throw Error('Workflow not found');\n    return workflow;\n  }\n\n  // Deterministic workflow ids for certain workflows allows us to avoid spawning a duplicate workflow if the app sends duplicate requests\n  private calculateWorkflowId(request: AppRequestEvent | OpenChannel): string {\n    switch (request.type) {\n      case 'JOIN_CHANNEL':\n        return `${request.type}-${request.channelId}`;\n      case 'OpenChannel':\n        return `JOIN_CHANNEL-${request.data.targetChannelId}`;\n      case 'APPROVE_BUDGET_AND_FUND':\n        return `${request.type}-${request.player.participantId}-${request.hub.participantId}`;\n      default:\n        return `${request.type}-${Guid.create().toString()}`;\n    }\n  }\n  private handleRequest(request: AppRequestEvent) {\n    const workflowId = this.calculateWorkflowId(request);\n    switch (request.type) {\n      case 'CREATE_CHANNEL': {\n        if (!this.isWorkflowIdInUse(workflowId)) {\n          this.startWorkflow(\n            Application.workflow(this.store, this.messagingService, request),\n            workflowId\n          );\n        } else {\n          // TODO: To allow RPS to keep working we just warn about duplicate events\n          // Eventually this could probably be an error\n          logger.warn(\n            `There is already a workflow running with id ${workflowId}, no new workflow will be spawned`\n          );\n        }\n        break;\n      }\n      case 'JOIN_CHANNEL':\n        this.getWorkflow(this.calculateWorkflowId(request)).service.send(request);\n        break;\n      case 'APPROVE_BUDGET_AND_FUND': {\n        const workflow = this.startWorkflow(\n          ApproveBudgetAndFund.machine(this.store, this.messagingService, {\n            player: request.player,\n            hub: request.hub,\n            budget: request.budget,\n            requestId: request.requestId\n          }),\n          workflowId,\n          true // devtools\n        );\n\n        workflow.service.send(request);\n        break;\n      }\n      case 'CLOSE_AND_WITHDRAW': {\n        this.startWorkflow(\n          CloseLedgerAndWithdraw.workflow(this.store, this.messagingService, {\n            opponent: request.hub,\n            player: request.player,\n            requestId: request.requestId,\n            domain: request.domain\n          }),\n          workflowId\n        );\n        break;\n      }\n      case 'ENABLE_ETHEREUM': {\n        this.startWorkflow(\n          ethereumEnableWorkflow(this.store, this.messagingService, {requestId: request.requestId}),\n          workflowId\n        );\n        break;\n      }\n    }\n  }\n  private startWorkflow(machineConfig: any, workflowId: string, devTools = false): Workflow {\n    if (this.isWorkflowIdInUse(workflowId)) {\n      throw new Error(`There is already a workflow running with id ${workflowId}`);\n    }\n    const service = interpret(machineConfig, {devTools})\n      .onTransition((state, event) => ADD_LOGS && logTransition(state, event, workflowId))\n      .onDone(() => (this.workflows = this.workflows.filter(w => w.id !== workflowId)))\n      .start();\n    // TODO: Figure out how to resolve rendering priorities\n    this.renderUI(service);\n\n    const workflow = {id: workflowId, service, domain: 'TODO'};\n    this.workflows.push(workflow);\n    return workflow;\n  }\n\n  private renderUI(machine) {\n    if (document.getElementById('root')) {\n      ReactDOM.render(\n        React.createElement(WalletUi, {workflow: machine}),\n        document.getElementById('root')\n      );\n    }\n  }\n\n  public async pushMessage(jsonRpcMessage: object, fromDomain: string) {\n    // Update any workflows waiting on an observable\n    await this.messagingService.receiveRequest(jsonRpcMessage, fromDomain);\n  }\n\n  public onSendMessage(\n    callback: (\n      jsonRpcMessage: StateChannelsNotification | StateChannelsResponse | StateChannelsErrorResponse\n    ) => void\n  ) {\n    this.messagingService.outboxFeed.subscribe(m => callback(m));\n  }\n}\n\nconst alreadyLogging = {};\nconst key = (v, id) => `${JSON.stringify(v)}-${id}`;\n\nconst transitionLogger = logger.child({module: 'wallet'});\nconst log = transitionLogger.trace.bind(transitionLogger);\n\nexport function logTransition(state: State<any, any, any, any>, event, id?: string): void {\n  const k = key(state.value, id);\n  if (alreadyLogging[k]) return;\n  alreadyLogging[k] = true;\n\n  const eventType = event.type ? event.type : event;\n  const {context, value: to} = state;\n  if (!state.history) {\n    log(\n      {id, workflow: state.configuration[0].id, to, context, event},\n      'WORKFLOW STARTED id %s event %s',\n      id,\n      eventType\n    );\n  } else {\n    const from = state.history.value;\n\n    log({id, from, to, context, event}, 'WORKFLOW TRANSITION id %s event %o', id, event.type);\n  }\n\n  Object.keys(state.children).forEach(k => {\n    const child = state.children[k];\n\n    if (child.state && 'onTransition' in child) {\n      const subId = (child as any).state.configuration[0].id;\n      (child as any).onTransition((state, event) => logTransition(state, event, `${id}/${subId}`));\n    }\n  });\n}\n","import React from 'react';\nimport {Route, Switch, BrowserRouter} from 'react-router-dom';\nimport {ChannelWallet} from '../channel-wallet';\nimport {FactoryReset} from './factory-reset';\n\nenum RoutePath {\n  Root = '/',\n  FactoryReset = '/factory-reset/'\n}\n\ninterface Props {\n  wallet: ChannelWallet;\n}\n\nconst App = (props: Props) => (\n  <BrowserRouter>\n    <main>\n      <Switch>\n        <Route exact path={RoutePath.Root}></Route>\n        <Route exact path={RoutePath.FactoryReset}>\n          <FactoryReset store={(props.wallet as any).store}></FactoryReset>\n        </Route>\n      </Switch>\n    </main>\n  </BrowserRouter>\n);\n\nexport default App;\n","import React, {useState} from 'react';\nimport './wallet.scss';\nimport Dexie from 'dexie';\nimport {Store} from '../store';\nimport {logger} from '../logger';\nimport {DB_NAME} from '../constants';\nimport {track} from '../segment-analytics';\n\ninterface Props {\n  store: Store;\n}\n\nexport const FactoryReset = (props: Props) => {\n  const [destroyed, setDestroyed] = useState(false);\n\n  return destroyed ? (\n    <div>Success! Check your console to see your old store.</div>\n  ) : (\n    <div>\n      <div>If you press this button, we will destroy your wallet. </div>\n      <div>We will dump the contents of your wallet in your console.</div>\n      <div>Contact us, and we can try to recover your funds.</div>\n      <button id=\"destroy\" onClick={() => destroyStore(props.store, setDestroyed)}>\n        Factory reset\n      </button>\n    </div>\n  );\n};\n\nconst destroyStore = async (store: Store, setDestroyed) => {\n  track('clicked factory reset');\n  if (!(await Dexie.exists(DB_NAME))) {\n    logger.error('No store detected.');\n    track('did not have a store');\n    setDestroyed(true);\n  } else if (confirm('Are you sure you want to delete your store?')) {\n    track('approved factory reset');\n    logger.error({store: await (store as any).backend.dump()}, 'Wallet destroyed');\n    await Dexie.delete(DB_NAME);\n\n    setDestroyed(true);\n    track('destroyed store');\n  } else {\n    track('rejected factory reset');\n  }\n};\n","import * as Sentry from '@sentry/browser';\nimport Url from 'url-parse';\nimport ReactDOM from 'react-dom';\nimport {isStateChannelsRequest, WalletReady} from '@statechannels/client-api-schema';\n\nimport {Backend} from './store/dexie-backend';\nimport {Store} from './store';\nimport {MemoryBackend} from './store/memory-backend';\nimport {ChainWatcher} from './chain';\nimport {logger} from './logger';\nimport {CLEAR_STORAGE_ON_START, USE_INDEXED_DB, ADD_LOGS, NODE_ENV, GIT_VERSION} from './config';\nimport {MessagingService} from './messaging';\nimport {ChannelWallet} from './channel-wallet';\nimport App from './ui/app';\n\nif (NODE_ENV === 'production') {\n  Sentry.init({\n    dsn: 'https://8706e073ecb646a6b7589c87f0468652@o344922.ingest.sentry.io/5236239',\n    release: 'xstate-wallet@' + GIT_VERSION\n  });\n}\n\nconst log = logger.trace.bind(logger);\n\n(async function() {\n  log({version: GIT_VERSION}, 'Wallet initializing');\n\n  const chain = new ChainWatcher();\n\n  const backend = USE_INDEXED_DB ? new Backend() : new MemoryBackend();\n  const store = new Store(chain, backend);\n\n  await store.initialize([], CLEAR_STORAGE_ON_START);\n  const messagingService = new MessagingService(store);\n  const channelWallet = new ChannelWallet(store, messagingService);\n\n  if (NODE_ENV === 'production') {\n    Sentry.configureScope(async scope => {\n      scope.setUser({id: await store.getAddress()});\n    });\n  }\n\n  // Communicate via postMessage\n  window.addEventListener('message', event => {\n    if (isStateChannelsRequest(event.data)) {\n      ADD_LOGS && log({jsonRpcRequest: event.data}, 'INCOMING JSONRPC REQUEST:');\n      const {host} = new Url(event.origin);\n      channelWallet.pushMessage(event.data, host);\n    }\n  });\n  channelWallet.onSendMessage(message => {\n    window.parent.postMessage(message, '*');\n    ADD_LOGS && log({jsonRpcResponse: message}, 'OUTGOING JSONRPC REQUEST:');\n  });\n\n  const walletReadyMessage: WalletReady = {\n    jsonrpc: '2.0',\n    method: 'WalletReady',\n    params: {}\n  };\n  window.parent.postMessage(walletReadyMessage, '*');\n\n  ReactDOM.render(App({wallet: channelWallet}), document.getElementById('root'));\n})();\n","\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(require(\"./types\"));\n\n__export(require(\"./state-utils\"));\n\n__export(require(\"./utils\"));\n\n__export(require(\"./bignumber\"));\n\n__export(require(\"./serde/app-messages/deserialize\"));\n\n__export(require(\"./serde/app-messages/serialize\"));\n\n__export(require(\"./serde/wire-format/deserialize\"));\n\n__export(require(\"./serde/wire-format/serialize\"));","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar NitroAdjudicator_json_1 = __importDefault(require(\"../build/contracts/NitroAdjudicator.json\"));\n\nvar TrivialApp_json_1 = __importDefault(require(\"../build/contracts/TrivialApp.json\"));\n\nvar Token_json_1 = __importDefault(require(\"../build/contracts/Token.json\"));\n\nvar AssetHolder_json_1 = __importDefault(require(\"../build/contracts/AssetHolder.json\"));\n\nvar ERC20AssetHolder_json_1 = __importDefault(require(\"../build/contracts/ERC20AssetHolder.json\"));\n\nvar ETHAssetHolder_json_1 = __importDefault(require(\"../build/contracts/ETHAssetHolder.json\"));\n\nexports.ContractArtifacts = {\n  NitroAdjudicatorArtifact: NitroAdjudicator_json_1.default,\n  TrivialAppArtifact: TrivialApp_json_1.default,\n  Erc20AssetHolderArtifact: ERC20AssetHolder_json_1.default,\n  EthAssetHolderArtifact: ETHAssetHolder_json_1.default,\n  TokenArtifact: Token_json_1.default,\n  AssetHolderArtifact: AssetHolder_json_1.default\n};\n\nvar test_helpers_1 = require(\"../test/test-helpers\");\n\nexports.getTestProvider = test_helpers_1.getTestProvider;\nexports.randomChannelId = test_helpers_1.randomChannelId;\nexports.randomExternalDestination = test_helpers_1.randomExternalDestination;\nexports.replaceAddressesAndBigNumberify = test_helpers_1.replaceAddressesAndBigNumberify;\nexports.setupContracts = test_helpers_1.setupContracts;\n\nvar asset_holder_1 = require(\"./contract/asset-holder\");\n\nexports.getAssetTransferredEvent = asset_holder_1.getAssetTransferredEvent;\nexports.getDepositedEvent = asset_holder_1.getDepositedEvent;\nexports.convertBytes32ToAddress = asset_holder_1.convertBytes32ToAddress;\nexports.convertAddressToBytes32 = asset_holder_1.convertAddressToBytes32;\n\nvar challenge_1 = require(\"./contract/challenge\");\n\nexports.getChallengeRegisteredEvent = challenge_1.getChallengeRegisteredEvent;\nexports.getChallengeClearedEvent = challenge_1.getChallengeClearedEvent;\n\nvar channel_1 = require(\"./contract/channel\");\n\nexports.getChannelId = channel_1.getChannelId;\n\nvar force_move_app_1 = require(\"./contract/force-move-app\");\n\nexports.validTransition = force_move_app_1.validTransition;\nexports.ForceMoveAppContractInterface = force_move_app_1.ForceMoveAppContractInterface;\nexports.createValidTransitionTransaction = force_move_app_1.createValidTransitionTransaction;\n\nvar outcome_1 = require(\"./contract/outcome\");\n\nexports.encodeAllocation = outcome_1.encodeAllocation;\nexports.encodeOutcome = outcome_1.encodeOutcome;\nexports.decodeOutcome = outcome_1.decodeOutcome;\nexports.isAllocationOutcome = outcome_1.isAllocationOutcome;\nexports.isGuaranteeOutcome = outcome_1.isGuaranteeOutcome;\nexports.encodeGuarantee = outcome_1.encodeGuarantee;\nexports.hashOutcome = outcome_1.hashOutcome;\n\nvar channel_storage_1 = require(\"./contract/channel-storage\");\n\nexports.channelDataToChannelStorageHash = channel_storage_1.channelDataToChannelStorageHash;\n\nvar state_1 = require(\"./contract/state\");\n\nexports.getVariablePart = state_1.getVariablePart;\nexports.getFixedPart = state_1.getFixedPart;\nexports.hashAppPart = state_1.hashAppPart;\nexports.hashState = state_1.hashState;\n\nvar erc20_asset_holder_1 = require(\"./contract/transaction-creators/erc20-asset-holder\");\n\nexports.createERC20DepositTransaction = erc20_asset_holder_1.createDepositTransaction;\n\nvar eth_asset_holder_1 = require(\"./contract/transaction-creators/eth-asset-holder\");\n\nexports.createETHDepositTransaction = eth_asset_holder_1.createDepositTransaction;\nexports.createTransferAllTransaction = eth_asset_holder_1.createTransferAllTransaction;\n\nvar signatures_1 = require(\"./signatures\");\n\nexports.signState = signatures_1.signState;\nexports.getStateSignerAddress = signatures_1.getStateSignerAddress;\nexports.signChallengeMessage = signatures_1.signChallengeMessage;\nexports.signStates = signatures_1.signStates;\n\nvar Signatures = __importStar(require(\"./signatures\"));\n\nexports.Signatures = Signatures;\n\nvar Transactions = __importStar(require(\"./transactions\"));\n\nexports.Transactions = Transactions;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar AssetOutcomeType;\n\n(function (AssetOutcomeType) {\n  AssetOutcomeType[AssetOutcomeType[\"AllocationOutcomeType\"] = 0] = \"AllocationOutcomeType\";\n  AssetOutcomeType[AssetOutcomeType[\"GuaranteeOutcomeType\"] = 1] = \"GuaranteeOutcomeType\";\n})(AssetOutcomeType = exports.AssetOutcomeType || (exports.AssetOutcomeType = {}));\n\nfunction encodeGuarantee(guarantee) {\n  return ethers_1.utils.defaultAbiCoder.encode(['tuple(bytes32 targetChannelId, bytes32[] destinations)'], [[guarantee.targetChannelId, guarantee.destinations]]);\n}\n\nexports.encodeGuarantee = encodeGuarantee;\n\nfunction decodeGuarantee(encodedGuarantee) {\n  var _a = ethers_1.utils.defaultAbiCoder.decode(['tuple(bytes32 targetChannelId, bytes32[] destinations)'], encodedGuarantee)[0],\n      targetChannelId = _a.targetChannelId,\n      destinations = _a.destinations;\n  return {\n    targetChannelId: targetChannelId,\n    destinations: destinations\n  };\n}\n\nexports.decodeGuarantee = decodeGuarantee;\n\nfunction isGuarantee(allocationOrGuarantee) {\n  return !isAllocation(allocationOrGuarantee);\n}\n\nexports.isGuarantee = isGuarantee;\n\nfunction encodeAllocation(allocation) {\n  return ethers_1.utils.defaultAbiCoder.encode(['tuple(bytes32 destination, uint256 amount)[]'], [allocation]);\n}\n\nexports.encodeAllocation = encodeAllocation;\n\nfunction decodeAllocation(encodedAllocation) {\n  var allocationItems = ethers_1.utils.defaultAbiCoder.decode(['tuple(bytes32 destination, uint256 amount)[]'], encodedAllocation)[0];\n  return allocationItems.map(function (a) {\n    return {\n      destination: a.destination,\n      amount: a.amount.toHexString()\n    };\n  });\n}\n\nexports.decodeAllocation = decodeAllocation;\n\nfunction isAllocation(allocationOrGuarantee) {\n  return Array.isArray(allocationOrGuarantee);\n}\n\nexports.isAllocation = isAllocation;\n\nfunction isGuaranteeOutcome(assetOutcome) {\n  return 'guarantee' in assetOutcome;\n}\n\nexports.isGuaranteeOutcome = isGuaranteeOutcome;\n\nfunction isAllocationOutcome(assetOutcome) {\n  return 'allocationItems' in assetOutcome;\n}\n\nexports.isAllocationOutcome = isAllocationOutcome;\n\nfunction encodeAssetOutcomeFromBytes(assetOutcomeType, encodedAllocationOrGuarantee) {\n  return ethers_1.utils.defaultAbiCoder.encode(['tuple(uint8 assetOutcomeType, bytes allocationOrGuarantee)'], [{\n    assetOutcomeType: assetOutcomeType,\n    allocationOrGuarantee: encodedAllocationOrGuarantee\n  }]);\n}\n\nexports.encodeAssetOutcomeFromBytes = encodeAssetOutcomeFromBytes;\n\nfunction decodeOutcomeItem(encodedAssetOutcome, assetHolderAddress) {\n  var _a = ethers_1.utils.defaultAbiCoder.decode(['tuple(uint8 outcomeType, bytes allocationOrGuarantee)'], encodedAssetOutcome)[0],\n      outcomeType = _a.outcomeType,\n      allocationOrGuarantee = _a.allocationOrGuarantee;\n\n  switch (outcomeType) {\n    case AssetOutcomeType.AllocationOutcomeType:\n      return {\n        assetHolderAddress: assetHolderAddress,\n        allocationItems: decodeAllocation(allocationOrGuarantee)\n      };\n\n    case AssetOutcomeType.GuaranteeOutcomeType:\n      return {\n        assetHolderAddress: assetHolderAddress,\n        guarantee: decodeGuarantee(allocationOrGuarantee)\n      };\n\n    default:\n      throw new Error(\"Received invalid outcome type \" + outcomeType);\n  }\n}\n\nexports.decodeOutcomeItem = decodeOutcomeItem;\n\nfunction hashAssetOutcome(allocationOrGuarantee) {\n  return ethers_1.utils.keccak256(encodeAssetOutcome(allocationOrGuarantee));\n}\n\nexports.hashAssetOutcome = hashAssetOutcome;\n\nfunction encodeAssetOutcome(allocationOrGuarantee) {\n  var encodedData;\n  var outcomeType;\n\n  if (isAllocation(allocationOrGuarantee)) {\n    encodedData = encodeAllocation(allocationOrGuarantee);\n    outcomeType = AssetOutcomeType.AllocationOutcomeType;\n  } else {\n    encodedData = encodeGuarantee(allocationOrGuarantee);\n    outcomeType = AssetOutcomeType.GuaranteeOutcomeType;\n  }\n\n  return encodeAssetOutcomeFromBytes(outcomeType, encodedData);\n}\n\nexports.encodeAssetOutcome = encodeAssetOutcome;\n\nfunction hashOutcome(outcome) {\n  var encodedOutcome = encodeOutcome(outcome);\n  return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode(['bytes'], [encodedOutcome]));\n}\n\nexports.hashOutcome = hashOutcome;\n\nfunction decodeOutcome(encodedOutcome) {\n  var assetOutcomes = ethers_1.utils.defaultAbiCoder.decode(['tuple(address assetHolderAddress, bytes outcomeContent)[]'], encodedOutcome)[0];\n  return assetOutcomes.map(function (a) {\n    return decodeOutcomeItem(a.outcomeContent, a.assetHolderAddress);\n  });\n}\n\nexports.decodeOutcome = decodeOutcome;\n\nfunction encodeOutcome(outcome) {\n  var encodedAssetOutcomes = outcome.map(function (o) {\n    var encodedData;\n    var outcomeType;\n\n    if (isAllocationOutcome(o)) {\n      encodedData = encodeAllocation(o.allocationItems);\n      outcomeType = AssetOutcomeType.AllocationOutcomeType;\n    } else {\n      encodedData = encodeGuarantee(o.guarantee);\n      outcomeType = AssetOutcomeType.GuaranteeOutcomeType;\n    }\n\n    return {\n      assetHolderAddress: o.assetHolderAddress,\n      outcomeContent: encodeAssetOutcomeFromBytes(outcomeType, encodedData)\n    };\n  });\n  return ethers_1.utils.defaultAbiCoder.encode(['tuple(address assetHolderAddress, bytes outcomeContent)[]'], [encodedAssetOutcomes]);\n}\n\nexports.encodeOutcome = encodeOutcome;","\"use strict\";\n\nvar _classCallCheck = require(\"/home/caleb/hypernet-protocol/subtrees/statechannels/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar binaryOperator = function binaryOperator(name) {\n  return function (a, b) {\n    if (typeof ethers_1.BigNumber.from(a)[name] !== 'function') throw Error(\"Invalid method \".concat(name));\n    var result = ethers_1.BigNumber.from(a)[name](b);\n    return ethers_1.BigNumber.isBigNumber(result) ? result.toHexString() : result;\n  };\n};\n\nvar unaryOperator = function unaryOperator(name) {\n  return function (a) {\n    if (typeof ethers_1.BigNumber.from(a)[name] !== 'function') throw Error(\"Invalid method \".concat(name));\n    var result = ethers_1.BigNumber.from(a)[name]();\n    return ethers_1.BigNumber.isBigNumber(result) ? result.toHexString() : result;\n  };\n};\n\nvar BN = function BN() {\n  _classCallCheck(this, BN);\n};\n\nexports.BN = BN;\nBN.eq = binaryOperator('eq');\nBN.lt = binaryOperator('lt');\nBN.gt = binaryOperator('gt');\nBN.lte = binaryOperator('lte');\nBN.gte = binaryOperator('gte');\nBN.add = binaryOperator('add');\nBN.sub = binaryOperator('sub');\nBN.mul = binaryOperator('mul');\nBN.div = binaryOperator('div');\nBN.mod = binaryOperator('mod');\nBN.pow = binaryOperator('pow');\nBN.abs = unaryOperator('abs');\nBN.isNegative = unaryOperator('isNegative');\nBN.isZero = unaryOperator('isZero');\nBN.toNumber = unaryOperator('toNumber');\nBN.toHexString = unaryOperator('toHexString');\n\nBN.from = function (n) {\n  return ethers_1.BigNumber.from(n).toHexString();\n};\n\nBN.isUint256 = function (val) {\n  return typeof val === 'string' && !!val.match(/^0x[0-9A-Fa-f]{0,64}$/);\n};\n\nexports.Zero = BN.from(0);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar channel_1 = require(\"./channel\");\n\nvar outcome_1 = require(\"./outcome\");\n\nfunction getFixedPart(state) {\n  var appDefinition = state.appDefinition,\n      challengeDuration = state.challengeDuration,\n      channel = state.channel;\n  var chainId = channel.chainId,\n      participants = channel.participants,\n      channelNonce = channel.channelNonce;\n  return {\n    chainId: chainId,\n    participants: participants,\n    channelNonce: channelNonce,\n    appDefinition: appDefinition,\n    challengeDuration: challengeDuration\n  };\n}\n\nexports.getFixedPart = getFixedPart;\n\nfunction getVariablePart(state) {\n  return {\n    outcome: outcome_1.encodeOutcome(state.outcome),\n    appData: state.appData\n  };\n}\n\nexports.getVariablePart = getVariablePart;\n\nfunction hashAppPart(state) {\n  var challengeDuration = state.challengeDuration,\n      appDefinition = state.appDefinition,\n      appData = state.appData;\n  return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode(['uint256', 'address', 'bytes'], [challengeDuration, appDefinition, appData]));\n}\n\nexports.hashAppPart = hashAppPart;\n\nfunction hashState(state) {\n  var turnNum = state.turnNum,\n      isFinal = state.isFinal;\n  var channelId = channel_1.getChannelId(state.channel);\n  var appPartHash = hashAppPart(state);\n  var outcomeHash = outcome_1.hashOutcome(state.outcome);\n  return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode(['tuple(uint256 turnNum, bool isFinal, bytes32 channelId, bytes32 appPartHash, bytes32 outcomeHash)'], [{\n    turnNum: turnNum,\n    isFinal: isFinal,\n    channelId: channelId,\n    appPartHash: appPartHash,\n    outcomeHash: outcomeHash\n  }]));\n}\n\nexports.hashState = hashState;","\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(require(\"./helpers\"));\n\n__export(require(\"./outcome\"));\n\n__export(require(\"./budget-utils\"));\n\n__export(require(\"./contract-utils\"));\n\n__export(require(\"./messages\"));"],"sourceRoot":""}